<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[BLOG_YHUJ]]></title><description><![CDATA[yhuj79's Blog]]></description><link>https://yhuj79.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 09 Oct 2024 09:24:44 GMT</lastBuildDate><item><title><![CDATA[Gatsby Blog 2년 사용 후기]]></title><description><![CDATA[지난 2년간 커스텀 블로그를 생성 후 관리하며 느낀 점, 주요 플러그인 등 후기를 간략하게 정리. 커스텀 블로그의 시작 블로그를 만들어야겠다 느낀 건 2022년…]]></description><link>https://yhuj79.github.io/Gatsby/240926/</link><guid isPermaLink="false">https://yhuj79.github.io/Gatsby/240926/</guid><pubDate>Thu, 26 Sep 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;지난 2년간 커스텀 블로그를 생성 후 관리하며 느낀 점, 주요 플러그인 등 후기를 간략하게 정리.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;커스텀 블로그의 시작&lt;/h2&gt;
&lt;p&gt;블로그를 만들어야겠다 느낀 건 2022년 9월 경, 개발을 배워가면서 얻은 지식들을 정리하여 기록물로 남겨두고 싶다 생각이 든 것이 시작이었다. 맨 처음에는 Tistory, Velog 등 내가 배울 때 유용하게 정보를 얻었던 블로그 플랫폼을 통해 개설하고 포스팅을 하려 했다.&lt;/p&gt;
&lt;p&gt;그렇게 여러가지 방안을 생각해 보다가 문득, 그냥 블로그를 직접 만들어 보는 것이 재밌겠다는 생각이 들었다.&lt;/p&gt;
&lt;img alt=&apos;minimal-mistakes&apos; src=&apos;https://raw.githubusercontent.com/mmistakes/minimal-mistakes/master/screenshot-layouts.png&apos;&gt;
&lt;p&gt;&lt;a href=&quot;https://mmistakes.github.io/minimal-mistakes&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Minimal Mistakes Jekyll theme&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mmistakes/minimal-mistakes&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Github Repository&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;color:gray&quot;&gt;(Jekyll을 사용할 때의 블로그 스크린샷이 현재 남아 있지 않다)&lt;/p&gt;
&lt;p&gt;시작은 Jekyll를 통해 블로그를 만드는 것을 선택했다. Jekyll은 정적 사이트 생성기로, Ruby로 만들어진 프레임워크이다. 사용하게 된 이유로는 여러 블로그들 중에서도 아주 심플하고 가독성 좋은 구조로 되어 있었고, 이용자가 많기 때문에 그만큼 다양한 템플릿과 정보가 갖추어져 있었다. 처음 Jekyll 환경을 구축할 때 많은 고생을 했다. rbenv 설치, 버전 설정, 의존성 관리 세팅 등 Ruby를 다뤄본 적이 크게 없었기에 그려러니 하면서 블로그 개발 환경을 완성해 나갔다. 그리고 최종적으로 배포에 성공한 나의 블로그 모습은 나름 만족스러웠다.&lt;/p&gt;
&lt;p&gt;하지만 결국 나는 Jekyll을 버렸다.&lt;/p&gt;
&lt;p&gt;첫 번째 이유는 Ruby에 있다. 블로그 플랫폼으로 나와있는 것을 사용하지 않고 커스텀 블로그를 생성하여 사용하는 것은 결국 자유도가 핵심적인 이유다. 본인의 입맛대로 구조와 디자인 변경이 용이해야 한다. 하지만 Javascript를 주로 다뤄왔던 나로써는 커스텀에 많은 불편함을 느꼈다.&lt;/p&gt;
&lt;p&gt;두 번째 이유는 생각보다 개발 환경, 플러그인 설정 등에 문제가 많았던 것이다. 처음이다보니 익숙하지 않아서 사소한 실수를 겪은 것인지는 명확하지 않지만, 미루고 미루다가 댓글 기능조차 제대로 구현해보지 못했다. 처음부터 프레임워크의 문제라 생각하지는 않았고, 나의 부족함을 탓하며 여러가지 방안을 강구하며 연구해 봤지만, 시간이 흐르면서 문득 그런 생각이 들었다. 이렇게까지 힘들게 사용해야 한다면 이게 의미가 있을까? 차라리 플랫폼을 사용하거나 더 개선된 버전의 Jekyll Blog 또는 다른 프레임워크를 쓰는 것이 맞지 않을까?&lt;/p&gt;
&lt;h2&gt;Gatsby로 블로그 리뉴얼&lt;/h2&gt;
&lt;p&gt;그동안 제작한 블로그를 날리고, Gatsby를 사용하여 다시 제작했다.&lt;/p&gt;
&lt;div align=&quot;center&quot; style=&quot;color:gray&quot;&gt;
    &lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;
        &lt;img alt=&quot;apple1&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/yhuj79.github.io/master/content/assets/apple1.png&quot; width=&quot;49%&quot; style=&quot;box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);&quot;&gt;
        &lt;img alt=&quot;apple2&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/yhuj79.github.io/master/content/assets/apple2.png&quot; width=&quot;49%&quot; style=&quot;box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);&quot;&gt;
    &lt;/div&gt;
    &lt;p style=&quot;padding: 0 4px 12px&quot;&gt;&lt;a href=&quot;https://gatsby-starter-apple.netlify.app&quot;&gt;Gatsby Starter Apple&lt;/a&gt; 테마를 사용하여 생성한 초기 블로그&lt;/p&gt;
&lt;/div&gt;
&lt;div align=&quot;center&quot; style=&quot;color:gray&quot;&gt;
    &lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;
        &lt;img alt=&quot;custom1&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/yhuj79.github.io/master/content/assets/custom1.png&quot; width=&quot;49%&quot; style=&quot;box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);&quot;&gt;
        &lt;img alt=&quot;custom2&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/yhuj79.github.io/master/content/assets/custom2.png&quot; width=&quot;49%&quot; style=&quot;box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);&quot;&gt;
    &lt;/div&gt;
    &lt;p style=&quot;padding: 0 4px 12px&quot;&gt;Post List 형태 변경, 글 태그 추가, 측면에 카테고리 표시 등의 커스텀 진행됨.&lt;/p&gt;
&lt;/div&gt;
&lt;div align=&quot;center&quot; style=&quot;color:gray&quot;&gt;
    &lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;
        &lt;img alt=&quot;custom3&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/yhuj79.github.io/master/content/assets/custom3.png&quot; width=&quot;49%&quot; style=&quot;box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);&quot;&gt;
        &lt;img alt=&quot;custom4&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/yhuj79.github.io/master/content/assets/custom4.png&quot; width=&quot;49%&quot; style=&quot;box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);&quot;&gt;
    &lt;/div&gt;
    &lt;p style=&quot;padding: 0 4px 12px&quot;&gt;최근과 가장 비슷한 모습. 삭제했던 썸네일이 다른 형태로 추가되었다.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Gatsby는 Jekyll과 유사하게 정적 사이트 생성기로 많이 사용되며, React 기반으로 만들어졌기 때문에 나에겐 굉장히 적응하기 쉬웠다. 취향에 맞게끔 디자인을 쉽게 수정할 수 있었고, 총 포스트 개수를 표시하는 것과 같은 기능도 편하게 추가할 수 있었다. 각종 플러그인 또한 안정적으로 작동되어 블로그의 역할을 수행하게 해주는 여러가지 기능들을 성공적으로 추가할 수 있었다.&lt;/p&gt;
&lt;h2&gt;주요 사용 플러그인&lt;/h2&gt;
&lt;h3&gt;Utterances&lt;/h3&gt;
&lt;p&gt;처음 블로그를 생성하게 되면 댓글 기능은 존재하지 않는다. 사용자가 직접 추가해야 한다. Gatsby에서는 Utterances 플러그인을 설치하여 댓글 시스템을 구축할 수 있다. Comment Repository를 생성하고 Issue를 통해 신규 댓글을 받아볼 수 있다. Github와 연동된 메일로 Issue 알림을 확인할 수 있기에, 댓글이 달리면 즉각적인 리액션이 가능하다.&lt;/p&gt;
&lt;img alt=&apos;utterances&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240926/utterances.png&apos;&gt;
&lt;p&gt;&lt;a href=&quot;https://sungchul-p.github.io/gatsby-utterances&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby 블로그에 utterances 댓글 앱 추가하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://min9nim.vercel.app/2020-05-14-gasby-utterances&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby 블로그 댓글 플러그인(utterances)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wwlee94.github.io/category/blog/getting-started-utterances&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby 블로그 - utterances 소셜 댓글 기능 도입하기&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Google Search Console&lt;/h3&gt;
&lt;p&gt;내가 작성한 블로그 글이 검색 엔진에 노출되기 위해서는 색인이 등록되어야 한다. 이를 도와주는 시스템이라 보면 된다. Sitemap.xml, Robots.txt를 생성하고 Google Search Console에 등록하여 구글에 내 글이 검색되게 할 수 있다.&lt;/p&gt;
&lt;img alt=&apos;gsc&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240926/gsc.png&apos;&gt;
&lt;p&gt;위와 같이 색인이 생성된 페이지 정보, 총 노출수, 클릭수 통계가 확인 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.dantechblog.xyz/posts/27c3184b-2bca-4109-9e0f-0414e3dd51c3?ref=codenary&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby Blog Google Search Console에 등록하는 방법&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mnxmnz.github.io/gatsby/google-search-console&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gastby 블로그 검색엔진 최적화 방법&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://streamls.tistory.com/entry/%EA%B0%9C%EC%B8%A0%EB%B9%84Gatsby-%EA%B5%AC%EA%B8%80-%EC%84%9C%EC%B9%98%EC%BD%98%EC%86%94-%EB%93%B1%EB%A1%9D-Google-Search-Console&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;개츠비(Gatsby) 구글 서치콘솔 등록&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Google Adsense&lt;/h3&gt;
&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;
    &lt;img alt=&apos;adsense1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240926/adsense1.png&apos; width=&quot;49%&quot;&gt;
    &lt;img alt=&apos;adsense2&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240926/adsense2.png&apos; width=&quot;49%&quot;&gt;
&lt;/div&gt;
&lt;p&gt;자신의 블로그에 광고를 기재함으로써 수익을 창출할 수 있는 플러그인이다. 엄청난 조회수가 아닌 이상 수익을 발생시키기에는 무리가 있으나, 한 번 사용해 보는 것이 나쁠 것은 없어 보였다. 블로그 이용에 지장이 생길 정도의 광고 과다 표기는 오히려 역효과를 일으킬 수 있기 때문에 주의해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bluemiv.tistory.com/15&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;개츠비(Gatsby) 블로그에 구글 애드센스(Adsense) 적용하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hello-gatsby.usefulparadigm.com/posts/adding-google-adsense-code-to-gatsby-site&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby 사이트에 Google AdSense 추가하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://doubly8f.netlify.app/%EA%B0%9C%EB%B0%9C/2020/08/26/gatsby-adsense&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby에 Google Adsense를 추가하는 방법&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;정리&lt;/h2&gt;
&lt;p&gt;지난 2년간 커스텀 블로그를 만들어 오면서 최종적으로 현재 Gatsby를 사용중인 상태다. 기존에 Javascript, React에 익숙한 유저라면 강력 추천한다. React 기반이기 때문에 커스텀이 Jekyll보다 훨씬 쉬웠다. 또한 플러그인 접근성이 좋고 안정적으로 느껴졌다. 위에서 다룬 플러그인들 또한 별다른 문제를 마주하지 않고 성공적으로 세팅할 수 있었다.&lt;/p&gt;
&lt;p&gt;그리고 한 가지 알아야 할 것으로, 무엇보다 중요한 것은 사용자가 Markdown 사용에 불편함을 느끼지 않아야 블로그를 계속 지속시킬 수 있다는 것이다.&lt;/p&gt;
&lt;img alt=&apos;markdown&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240926/markdown.png&apos;&gt;
&lt;p&gt;결국 모든 포스트는 Markdown을 통해 작성한다. 이에 익숙해야 꾸준히 포스팅을 하는데 있어 지장이 없을 것이다. 블로그 구축과 디자인 커스텀, 포스팅 등 이러한 과정들이 귀찮고 어렵게 느껴진다면 다른 블로그 플랫폼을 이용하는 편이 훨씬 낫다.&lt;/p&gt;
&lt;p&gt;나는 아직까지 Gatsby에 대해 완벽하게 이해하고 있다고 생각하지는 않는다. 하지만 Gatsby에 대한 이해도가 부족하다고 생각해도, 개인 커스텀 블로그 생성을 원한다면 일단 시작해 보자.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mmistakes/minimal-mistakes&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Minimal Mistakes Jekyll theme&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sungik-choi/gatsby-starter-apple&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby Starter Apple&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sungchul-p.github.io/gatsby-utterances&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby 블로그에 utterances 댓글 앱 추가하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://min9nim.vercel.app/2020-05-14-gasby-utterances&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby 블로그 댓글 플러그인(utterances)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wwlee94.github.io/category/blog/getting-started-utterances&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby 블로그 - utterances 소셜 댓글 기능 도입하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.dantechblog.xyz/posts/27c3184b-2bca-4109-9e0f-0414e3dd51c3?ref=codenary&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby Blog Google Search Console에 등록하는 방법&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mnxmnz.github.io/gatsby/google-search-console&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gastby 블로그 검색엔진 최적화 방법&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://streamls.tistory.com/entry/%EA%B0%9C%EC%B8%A0%EB%B9%84Gatsby-%EA%B5%AC%EA%B8%80-%EC%84%9C%EC%B9%98%EC%BD%98%EC%86%94-%EB%93%B1%EB%A1%9D-Google-Search-Console&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;개츠비(Gatsby) 구글 서치콘솔 등록&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bluemiv.tistory.com/15&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;개츠비(Gatsby) 블로그에 구글 애드센스(Adsense) 적용하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hello-gatsby.usefulparadigm.com/posts/adding-google-adsense-code-to-gatsby-site&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby 사이트에 Google AdSense 추가하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://doubly8f.netlify.app/%EA%B0%9C%EB%B0%9C/2020/08/26/gatsby-adsense&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gatsby에 Google Adsense를 추가하는 방법&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React에서 ApexCharts로 차트 그리기]]></title><description><![CDATA[…]]></description><link>https://yhuj79.github.io/React/240909/</link><guid isPermaLink="false">https://yhuj79.github.io/React/240909/</guid><pubDate>Mon, 09 Sep 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;데이터 시각화란 데이터를 그래프, 차트, 지도, 인포그래픽 등 시각적인 형태로 표현하여 복잡한 정보나 패턴을 쉽게 이해할 수 있도록 하는 방법이다. 대량의 데이터를 시각적으로 표현함으로써 숨겨진 경향, 상관관계, 이상치 등을 더 직관적으로 파악할 수 있게 하며, 이를 통해 의사 결정 과정에서 통찰력을 제공한다. 차트는 데이터를 시각적으로 표현하여 정보를 효과적으로 전달하는 데 매우 유용하다. React와 같은 프레임워크에서 다양한 차트를 쉽게 구현할 수 있는 라이브러리 중 대표적으로 ApexCharts가 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;ApexCharts.js&lt;/h2&gt;
&lt;img alt=&apos;apexchart1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/Past-Weather/main/assets/readme-3.gif&apos;&gt;
&lt;br&gt;
&lt;img alt=&apos;apexchart1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/Past-Weather/main/assets/readme-4.gif&apos;&gt;
&lt;p&gt;&lt;a href=&quot;https://past-weather.vercel.app&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;ApexCharts를 적용하여 개발한 프로젝트 - 과거 기상 데이터 차트 분석 웹 서비스&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ApexCharts&lt;/strong&gt;는 다양한 유형의 차트를 지원하는 JavaScript 차트 라이브러리이다. 데이터 시각화라고 하면 대표적인 것으로 D3.js가 있지만 사실 난이도가 굉장히 높아 진압장벽이 느껴진다. 그에 비해 React에서 사용할 수 있는 차트 라이브러리 중에서 ApexCharts는 다양한 종류의 차트를 간편하게 설정할 수 있다.&lt;/p&gt;
&lt;p&gt;라이브러리를 둘러보다 보면 커스텀 측면에서 자유도가 낮은 경우도 있고 데이터를 직관적으로 풀기 어렵게 설계된 경우도 많다. 하지만 ApexCharts는 &lt;strong&gt;전체적인 코드 설정이 비교적 간편하고, 특히 옵션 설정에서 많은 기능을 지원하기 때문에 다양한 커스터마이징이 가능하다.&lt;/strong&gt; 위에 나온 프로젝트는 ApexCharts를 통해 선택한 날씨 데이터를 시각화하여 볼 수 있게 제작되었다. 데이터 시각화에 메인으로 사용되었던 &lt;strong&gt;라인, 원형 차트&lt;/strong&gt;를 비롯하여, 사용하고 싶었으나 사용 데이터에 부합하지 않아 폐기되었던 &lt;strong&gt;레이더 차트&lt;/strong&gt;까지 간단한 예제를 통해 다루어 보았다.&lt;/p&gt;
&lt;h2&gt;React에서 ApexCharts 사용하기&lt;/h2&gt;
&lt;p&gt;React에서 ApexCharts를 사용하려면, 먼저 필요한 라이브러리를 설치해야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ npm install react-apexcharts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치 후, 차트를 구현할 컴포넌트를 만들어 차트를 렌더링하면 된다. 다음은 ApexCharts의 라인 차트(Line Chart), 원형 차트(Pie Chart), 레이더 차트(Radar Chart) 예제이다.&lt;/p&gt;
&lt;h3&gt;라인 차트(Line Chart)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;라인 차트&lt;/strong&gt;는 데이터를 선형으로 연결하여 데이터의 흐름을 파악하는 데 유용하다. 아래는 두 개의 데이터 시리즈를 보여주는 간단한 라인 차트이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import Chart from &quot;react-apexcharts&quot;

// 차트에 표시될 데이터 설정
const chartData = [
  {
    name: &quot;data A&quot;,
    data: [
      { x: 1, y: 0.6 },
      { x: 2, y: 7.9 },
      ...{ x: 9, y: 21.7 },
      { x: 10, y: 16.5 },
    ],
  },
  {
    name: &quot;data B&quot;,
    data: [
      { x: 1, y: 8.1 },
      { x: 2, y: 6.3 },
      ...{ x: 9, y: 25.7 },
      { x: 10, y: 15.2 },
    ],
  },
  {
    name: &quot;data C&quot;,
    data: [
      { x: 1, y: 4.8 },
      { x: 2, y: 3.2 },
      ...{ x: 9, y: 12.8 },
      { x: 10, y: 7.6 },
    ],
  },
  {
    name: &quot;data D&quot;,
    data: [
      { x: 1, y: 5.7 },
      { x: 2, y: 9.9 },
      ...{ x: 9, y: 22.9 },
      { x: 10, y: 11.4 },
    ],
  },
]

// 차트 옵션 설정
const chartOptions = {
  chart: {
    type: &quot;line&quot;, // 차트 유형을 라인 차트로 설정
    toolbar: {
      show: true, // 툴바 표시 여부
      tools: {
        zoom: true, // 확대 툴
        zoomin: true, // 확대 버튼
        zoomout: true, // 축소 버튼
        download: true, // 이미지 다운로드 버튼
        pan: true, // 팬 이동 가능 여부
        reset: true, // 차트 초기화 버튼
        selection: true, // 선택 도구 활성화 여부
      },
    },
  },
  title: {
    text: &quot;Line Chart&quot;, // 차트 타이틀 텍스트
    align: &quot;center&quot;, // 타이틀 위치
    margin: 5, // 타이틀과 차트 간의 여백
    offsetY: 0, // Y축 기준으로 타이틀 위치 조정
    style: {
      fontSize: &quot;25px&quot;, // 타이틀 텍스트 크기
      color: &quot;#000&quot;, // 타이틀 텍스트 색상
    },
  },
  dataLabels: {
    enabled: false, // 데이터 라벨 표시 여부
    offsetX: -3, // 라벨의 X축 위치를 조정
    offsetY: 0, // 라벨의 Y축 위치를 조정
  },
  stroke: {
    curve: &quot;smooth&quot;, // 곡선형 라인 적용
  },
  xaxis: {
    tickAmount: 10, // X축에 표시될 틱의 수
    labels: {
      show: true, // 라벨 표시 여부
      rotate: 0, // 라벨 회전 각도
    },
  },
  legend: {
    show: true, // 범례 표시 여부
    position: &quot;bottom&quot;, // 범례 위치
  },
  tooltip: {
    enabled: true, // 툴팁 활성화 여부
    shared: true, // 여러 시리즈의 데이터 값을 동시에 툴팁에 표시
  },
  colors: [
    // 데이터 컬러 리스트
    &quot;#008FFB&quot;, // ApexChart에서 기본값으로 사용하는 색상을 일단 적용해 놓았음
    &quot;#00E396&quot;,
    &quot;#FEB019&quot;,
    &quot;#FF4560&quot;,
    &quot;#775DD0&quot;,
    &quot;#3F51B5&quot;,
    &quot;#4CAF50&quot;,
    &quot;#F9CE1D&quot;,
    &quot;#33B2DF&quot;,
    &quot;#D4526E&quot;,
  ],
}

export default function LineChart() {
  return (
    &amp;#x3C;Chart
      type=&quot;line&quot; // 차트 유형 지정
      options={chartOptions} // 차트 옵션 적용
      series={chartData} // 차트 데이터 적용
      width={&quot;100%&quot;} // 차트 너비 설정
      height={400} // 차트 높이 설정
    /&gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;line-1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240909/line-1.png&apos;&gt;
&lt;p&gt;이 예제에서는 x, y 좌표로 이루어진 데이터를 시각화하며, X축은 1부터 10까지의 숫자를, Y축은 각 데이터 포인트의 값을 표시했다. 옵션 설정 부분의 경우 라이브러리를 사용하면서 찾아본 최대한 많은 옵션을 포함해 놓았지만, 위 차트 옵션 이외에도 많은 설정 옵션들이 존재한다.&lt;/p&gt;
&lt;img alt=&apos;line-2&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240909/line-2.gif&apos;&gt;
&lt;p&gt;ApexCharts 지원 툴 중 하나인 줌 기능이다. 구역을 확대해서 데이터를 확인할 수 있다. 불필요할 경우 옵션에서 설정을 끄면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  dataLabels: {
    enabled: true, // 데이터 라벨 표시 ON
    offsetX: -3,
    offsetY: 0,
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;line-2&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240909/line-2.png&apos;&gt;
&lt;p&gt;데이터 라벨을 표시하면 위와 같이 나타나게 된다. 데이터 라벨이 차트 공간 끝에 걸려 잘리는 경우가 있으니 offset을 조절하거나 div를 따로 설정하여 처리해야 한다.&lt;/p&gt;
&lt;h3&gt;원형 차트(Pie Chart)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;원형 차트&lt;/strong&gt;는 비율을 나타내는 데 자주 사용된다. ApexCharts에서는 데이터를 섹터로 나누어 비율을 표시하고, 라벨과 중앙에 총합을 표시할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import Chart from &quot;react-apexcharts&quot;

// 차트에 표시될 데이터 설정
const chartData = [20, 19, 22, 36, 35, 0, 18, 22, 0, 30]

// 차트 옵션 설정
const chartOptions = {
  chart: {
    width: &quot;100%&quot;,
    height: &quot;100%&quot;,
    type: &quot;pie&quot;,
  },
  labels: [
    // 원형 차트의 라벨 표시
    &quot;Alpha&quot;,
    &quot;Beta&quot;,
    &quot;Gamma&quot;,
    &quot;Delta&quot;,
    &quot;Epsilon&quot;,
    &quot;Zeta&quot;,
    &quot;Eta&quot;,
    &quot;Theta&quot;,
    &quot;Iota&quot;,
    &quot;Kappa&quot;,
  ],
  title: {
    text: &quot;Pie Chart&quot;, // 차트 타이틀 텍스트
    align: &quot;center&quot;, // 타이틀의 정렬 (center로 설정)
    margin: 5, // 타이틀과 차트 간 여백
    offsetX: -35, // X축 기준으로 타이틀 위치 조정
    style: {
      fontSize: &quot;25px&quot;, // 타이틀 텍스트 크기
      color: &quot;#000&quot;, // 타이틀 색상
    },
  },
  grid: {
    padding: {
      top: 5, // 차트 상단 여백
      bottom: 5, // 차트 하단 여백
      left: 5, // 차트 왼쪽 여백
      right: 5, // 차트 오른쪽 여백
    },
  },
  tooltip: {
    enabled: false, // 툴팁 비활성화
  },
  legend: {
    show: true, // 범례 표시 여부
    width: 60, // 범례 너비 설정
    offsetY: 10, // 범례의 수직 위치 조정
    itemMargin: {
      horizontal: 2, // 범례 아이템 간의 가로 여백
      vertical: 2, // 범례 아이템 간의 세로 여백
    },
  },
  colors: [
    &quot;#FF5722&quot;, // 각 데이터의 색상 설정
    &quot;#FF9800&quot;,
    &quot;#FFC107&quot;,
    &quot;#4CAF50&quot;,
    &quot;#8BC34A&quot;,
    &quot;#80DEEA&quot;,
    &quot;#33CCFF&quot;,
    &quot;#0099FF&quot;,
    &quot;#0066CC&quot;,
    &quot;#004080&quot;,
  ],
}

export default function PieChart() {
  return (
    &amp;#x3C;Chart
      type=&quot;pie&quot;
      options={chartOptions}
      series={chartData}
      width={500}
      height={300}
    /&gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;pie-1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240909/pie-1.png&apos;&gt;
&lt;p&gt;위와 같이 각 데이터 항목의 비율을 나타내는 차트를 그릴 수 있다. 마찬가지로 옵션을 통해 원형 차트의 다양한 부분을 커스터마이징할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const chartOptions = {
  chart: {
    width: &quot;100%&quot;,
    height: &quot;100%&quot;,
    type: &quot;donut&quot;, // 타입 도넛으로 변경
  },
  labels: [
    ...
  ],
  title: {
    ...
  },
  plotOptions: {
    pie: {
      donut: {
        size: &quot;55%&quot;, // 도넛 차트의 크기
        labels: {
          show: true, // 도넛 중앙에 라벨 표시
          total: {
            show: true, // 도넛 중앙에 총합 표시
            label: &quot;All&quot;, // 총합에 대한 라벨 텍스트
            fontFamily: &quot;Noto Sans KR, sans-serif&quot;, // 폰트 패밀리 설정
            fontWeight: &quot;600&quot;, // 폰트 두께 설정
            fontSize: &quot;20px&quot;, // 폰트 크기 설정
            formatter(w) {
              // 총합을 계산하여 표시하는 함수
              return (
                w.globals.seriesTotals.reduce((a, b) =&gt; a + b, 0) + &quot; data&quot;
              );
            },
          },
          value: {
            fontFamily: &quot;Noto Sans KR, sans-serif&quot;, // 데이터 값에 대한 폰트 설정
            fontWeight: &quot;600&quot;,
            fontSize: &quot;20px&quot;,
            formatter(val) {
              // 각 데이터 값을 표시하는 함수
              return val + &quot; data&quot;;
            },
          },
        },
      },
      dataLabels: {
        offset: 0, // 데이터 라벨의 위치 조정
      },
    },
  },
  grid: {
    ...
  },
  ...
};

...
    &amp;#x3C;Chart
      type=&quot;donut&quot;
      options={chartOptions}
      series={chartData}
      width={500}
      height={300}
    /&gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;donut-1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240909/donut-1.gif&apos;&gt;
&lt;p&gt;타입을 donut으로 변경하고 이에 맞는 옵션을 추가하면 중앙이 뚫려 있고 총합을 표시하도록 설정된 &lt;strong&gt;도넛 차트&lt;/strong&gt;로 변형시킬 수 있다.&lt;/p&gt;
&lt;h3&gt;레이더 차트(Radar Chart)&lt;/h3&gt;
&lt;p&gt;레이더 차트는 다각형의 축을 따라 여러 데이터를 표현하는 차트로, 여러 카테고리 간의 비교를 시각적으로 보여준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import Chart from &quot;react-apexcharts&quot;

// 차트에 표시될 데이터 설정
const chartData = [
  {
    name: &quot;Series 1&quot;, // 첫 번째 시리즈 이름
    data: [80, 50, 30, 40, 100, 20], // 각 축에 해당하는 값
  },
  {
    name: &quot;Series 2&quot;, // 두 번째 시리즈 이름
    data: [20, 30, 40, 80, 20, 80],
  },
  {
    name: &quot;Series 3&quot;, // 세 번째 시리즈 이름
    data: [44, 76, 78, 13, 43, 10],
  },
]

// 차트 옵션 설정
const chartOptions = {
  chart: {
    type: &quot;radar&quot;, // 레이더 차트로 설정
    toolbar: {
      show: true, // 차트 상단 툴바 표시
    },
  },
  title: {
    text: &quot;Radar Chart&quot;, // 차트 타이틀 텍스트
    align: &quot;center&quot;, // 타이틀 위치 조정
    offsetX: -10, // X축 기준으로 타이틀 위치 조정
    style: {
      fontSize: &quot;25px&quot;, // 타이틀 폰트 크기
      color: &quot;#000&quot;, // 타이틀 색상
    },
  },
  xaxis: {
    // 레이더 차트의 각 축에 해당하는 라벨
    categories: [
      &quot;Category A&quot;,
      &quot;Category B&quot;,
      &quot;Category C&quot;,
      &quot;Category D&quot;,
      &quot;Category E&quot;,
      &quot;Category F&quot;,
    ],
  },
  plotOptions: {
    radar: {
      size: 100, // 레이더 차트의 크기
      polygons: {
        strokeColors: &quot;#e9e9e9&quot;, // 레이더 차트 다각형의 색상
        fill: {
          colors: [&quot;#f8f8f8&quot;, &quot;#fff&quot;], // 다각형 안의 채우기 색상
        },
      },
    },
  },
  stroke: {
    width: 2, // 라인의 두께 설정
  },
  markers: {
    size: 4, // 데이터 포인트의 크기
  },
  fill: {
    opacity: 0.2, // 채우기 색상의 불투명도 설정
  },
  tooltip: {
    enabled: true, // 툴팁 활성화
  },
  legend: {
    show: true, // 범례 표시
    position: &quot;bottom&quot;, // 범례 위치
    horizontalAlign: &quot;center&quot;, // 범례의 정렬
  },
  colors: [&quot;#FF4560&quot;, &quot;#00E396&quot;, &quot;#008FFB&quot;], // 각 데이터의 색상 설정
}

export default function RadarChart() {
  return (
    &amp;#x3C;Chart
      type=&quot;radar&quot;
      options={chartOptions}
      series={chartData}
      width={500}
      height={350}
    /&gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;radar-1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240909/radar-1.png&apos;&gt;
&lt;p&gt;이 예제에서는 각 시리즈가 여러 카테고리에 대한 값들을 다각형의 축을 따라 나타낸다. 레이더 차트는 분포도나 성능 비교를 시각화하는 데 유용하다.&lt;/p&gt;
&lt;h2&gt;사용하며 맞이했던 문제&lt;/h2&gt;
&lt;h3&gt;화면 크기 변화 시 width 문제&lt;/h3&gt;
&lt;p&gt;Chart 컴포넌트에 width를 적용할 때 &quot;100%&quot;, &quot;100vw&quot; 등의 옵션이 적용되지 않는 케이스가 발견되었다. 부모 요소의 적용 여부와 관계없이 고정적인 width 값을 입력해야 적용이 되었다. 이는 반응형 디자인을 고려할 때 문제가 발생한다.&lt;/p&gt;
&lt;img alt=&apos;width-problem&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240909/width-problem.gif&apos;&gt;
&lt;p&gt;따라서 화면 크기 변화를 수동적으로 감지하여 차트의 가로 길이를 업데이트 하는 방식을 적용해 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // 라이브러리 문제 때문에 가로 길이 수동적으로 설정
  const paperRef = useRef(null);
  const [chartWidth, setChartWidth] = useState(&quot;&quot;);
  // 컴포넌트가 렌더링될 때와 화면 크기 변화가 감지될 때 차트의 가로 길이를 업데이트
  useEffect(() =&gt; {
    const updateChartWidth = () =&gt; {
      if (paperRef.current) {
        setChartWidth(paperRef.current.offsetWidth - 15);
      }
    };
    const observer = new ResizeObserver(() =&gt; {
      updateChartWidth();
    });
    const paperElement = paperRef.current;
    if (paperElement) {
      // 요소의 크기 변화를 감시
      observer.observe(paperElement);
    }
    updateChartWidth();
    return () =&gt; {
      if (paperElement) {
        // 컴포넌트가 언마운트될 때 감시 해제
        observer.unobserve(paperElement);
      }
    };
  }, []);

  ...

    return (
    &amp;#x3C;div ref={paperRef}&gt;
        ...
        &amp;#x3C;Chart
          type=&quot;line&quot;
          options={chartOptions}
          series={chartData}
          width={chartWidth}
          height={300}
        /&gt;
        ...
    &amp;#x3C;/div&gt;
  );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;적용하려는 프로젝트의 구조나 사용 환경에 따라 다를 수 있고, 또 다른 해결 방법이 존재할 수 있다. 이 방식은 위에서 소개된 프로젝트의 방식과 유사한 구조를 생각중이라면 나쁘지 않은 해결 방법이 될 수 있다.&lt;/p&gt;
&lt;h3&gt;toString Error&lt;/h3&gt;
&lt;img alt=&apos;error&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240909/error.png&apos;&gt;
&lt;p&gt;이 문제는 Javascript React 환경에서 테스트를 하던 중 발견되었다. 차트를 생성하고 난 후 웹페이지에서 클릭을 해보면 불규칙적으로 에러가 발생한다. 비교적 간단한 차트를 구성할 경우에는 발생하지 않은 경우도 있다.&lt;/p&gt;
&lt;p&gt;원인은 아직까지 파악되지 않았다. Typescript 환경에서 개발을 할 때는 발생하지 않는 문제이기 때문에, 만약 프로젝트에 큰 데이터와 복잡한 옵션이 필요한 차트를 사용할 것이라면 Typescript를 사용하는 것을 권장한다. &lt;strong&gt;(추후 원인 파악 시 글 수정 예정)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// 옵션 타입 선언 (위에서 설치했던 것은 react-apexcharts로, apexcharts도 설치 필요)
import { ApexOptions } from &quot;apexcharts&quot;;

const chartOptions: ApexOptions = {
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://apexcharts.com&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;ApexCharts.js&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Typescript로 작성하는 디자인 패턴]]></title><description><![CDATA['바퀴를 다시 발명하지 마라(Don't reinvent the wheel…]]></description><link>https://yhuj79.github.io/Typescript/240827/</link><guid isPermaLink="false">https://yhuj79.github.io/Typescript/240827/</guid><pubDate>Tue, 27 Aug 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&apos;바퀴를 다시 발명하지 마라(Don&apos;t reinvent the wheel)&apos;&lt;/strong&gt;라는 유명한 프로그래밍 격언이 있다. 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;디자인 패턴이란?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;디자인 패턴(Design Pattern)&lt;/strong&gt;은 소프트웨어 개발에서 자주 발생하는 문제들을 해결하기 위한 반복 가능한 솔루션을 제공하는 중요한 개념이다. 이러한 패턴들은 코드의 재사용성을 높이고, 유지보수를 쉽게 하며, 코드의 가독성을 향상시키는 데 도움을 준다. 이번 포스트에서는 &lt;strong&gt;TypeScript&lt;/strong&gt;를 사용해 여러 디자인 패턴을 구현해 보았다. TypeScript는 정적 타입 검사와 객체 지향 프로그래밍 기능을 제공하므로 디자인 패턴을 적용하는 데 매우 적합한 언어다.&lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;GoF 디자인 패턴 목적 분류&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GoF 디자인 패턴&lt;/strong&gt;은 소프트웨어 개발에서 자주 사용되는 설계 패턴을 정의한 것이다. &lt;strong&gt;GoF&lt;/strong&gt;는 &apos;Gang of Four&apos;의 약자로, 이 패턴을 정의한 네 명의 저자들(Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides)을 가리킨다. 이들은 1994년에 출판한 책 &lt;em&gt;&quot;Design Patterns: Elements of Reusable Object-Oriented Software&quot;&lt;/em&gt;에서 23개의 디자인 패턴을 소개했는데, 여기서 목적에 따른 세 가지 카테고리로 분류하였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;생성 패턴(Creational Pattern)&lt;/strong&gt; : 객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해 준다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ex )&lt;/strong&gt; 추상 팩토리(Abstract Factory), 빌더(Builder), 팩토리 메서드(Factory Method), 프로토타입(Prototype), 싱글톤(Singleton)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;행위 패턴(Behavioral Pattern)&lt;/strong&gt; : 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로, 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와준다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ex )&lt;/strong&gt; 책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(Interpreter), 전략(Strategy), 옵저버(Observer)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;구조 패턴(Structural Pattern)&lt;/strong&gt; : 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴으로, 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ex )&lt;/strong&gt; 어댑터(Adapter), 브리지(Bridge), 컴포지트(Composite), 데코레이터(Decorator), 프록시(Proxy)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2&gt;생성 패턴&lt;/h2&gt;
&lt;h3&gt;싱글톤 패턴 (Singleton Pattern)&lt;/h3&gt;
&lt;p&gt;특정 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 패턴이다. 이 패턴은 주로 애플리케이션 내에서 전역적으로 접근 가능한 하나의 객체가 필요할 때 사용된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;class Singleton {
  private static instance: Singleton

  private constructor() {
    // private constructor를 사용하여 외부에서 인스턴스 생성을 방지
  }

  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton()
    }
    return Singleton.instance
  }

  public someMethod() {
    console.log(&quot;This is a method in the Singleton class.&quot;)
  }
}

const singleton1 = Singleton.getInstance()
const singleton2 = Singleton.getInstance()

console.log(singleton1 === singleton2) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Singleton 클래스의 인스턴스를 하나만 생성할 수 있으며, getInstance() 메서드를 통해 언제나 같은 인스턴스를 반환한다. 이를 통해 메모리 사용을 절약하고, 전역 상태를 관리하는 데 유용하다.&lt;/p&gt;
&lt;br&gt;
&lt;h3&gt;팩토리 메서드 패턴 (Factory Method Pattern)&lt;/h3&gt;
&lt;p&gt;객체 생성의 로직을 서브클래스에서 정의하도록 하여 객체 생성의 유연성을 제공하는 패턴이다. 이 패턴은 객체 생성의 책임을 팩토리 클래스에 위임함으로써 코드의 결합도를 낮추고, 객체 생성 로직을 중앙 집중화할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;abstract class Product {
  abstract use(): void
}

class ConcreteProductA extends Product {
  use(): void {
    console.log(&quot;Using Product A&quot;)
  }
}

class ConcreteProductB extends Product {
  use(): void {
    console.log(&quot;Using Product B&quot;)
  }
}

abstract class Creator {
  abstract factoryMethod(): Product

  createProduct(): Product {
    return this.factoryMethod()
  }
}

class ConcreteCreatorA extends Creator {
  factoryMethod(): Product {
    return new ConcreteProductA()
  }
}

class ConcreteCreatorB extends Creator {
  factoryMethod(): Product {
    return new ConcreteProductB()
  }
}

const creatorA = new ConcreteCreatorA()
const productA = creatorA.createProduct()
productA.use()

const creatorB = new ConcreteCreatorB()
const productB = creatorB.createProduct()
productB.use()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Product 클래스를 상속받아 ConcreteProductA와 ConcreteProductB를 구현했다. 각각의 Creator 서브클래스에서 팩토리 메서드를 통해 특정 제품의 인스턴스를 생성하게 된다. 이 패턴은 새로운 제품이 추가될 때 기존 코드를 수정하지 않고도 확장할 수 있도록 도와준다.&lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;행위 패턴&lt;/h2&gt;
&lt;h3&gt;전략 패턴 (Strategy Pattern)&lt;/h3&gt;
&lt;p&gt;알고리즘 군을 정의하고, 각 알고리즘을 캡슐화하여 교환 가능하게 만드는 패턴이다. 이 패턴은 런타임 시에 알고리즘을 선택할 수 있도록 유연성을 제공한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Strategy {
  execute(a: number, b: number): number
}

class AddStrategy implements Strategy {
  execute(a: number, b: number): number {
    return a + b
  }
}

class SubtractStrategy implements Strategy {
  execute(a: number, b: number): number {
    return a - b
  }
}

class Context {
  private strategy: Strategy

  constructor(strategy: Strategy) {
    this.strategy = strategy
  }

  setStrategy(strategy: Strategy) {
    this.strategy = strategy
  }

  executeStrategy(a: number, b: number): number {
    return this.strategy.execute(a, b)
  }
}

const context = new Context(new AddStrategy())
console.log(context.executeStrategy(10, 5)) // 15

context.setStrategy(new SubtractStrategy())
console.log(context.executeStrategy(10, 5)) // 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Strategy 인터페이스를 통해 다양한 알고리즘을 정의하고, Context 클래스에서 이들을 실행할 수 있다. 이를 통해 서로 다른 알고리즘을 쉽게 교체할 수 있으며, 새로운 전략을 추가할 때 기존 코드를 수정하지 않아도 된다.&lt;/p&gt;
&lt;br&gt;
&lt;h3&gt;옵저버 패턴 (Observer Pattern)&lt;/h3&gt;
&lt;p&gt;객체의 상태 변화를 관찰하는 옵저버들에게 알리는 패턴이다. 이 패턴은 이벤트 기반 시스템에서 자주 사용되며, 상태 변화에 따라 여러 객체가 동기화되어야 하는 경우 유용하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Observer {
  update(data: any): void
}

class ConcreteObserver implements Observer {
  private observerState: any

  update(data: any) {
    this.observerState = data
    console.log(`Observer state updated with data: ${data}`)
  }
}

class Subject {
  private observers: Observer[] = []

  addObserver(observer: Observer) {
    this.observers.push(observer)
  }

  removeObserver(observer: Observer) {
    this.observers = this.observers.filter((obs) =&gt; obs !== observer)
  }

  notifyObservers(data: any) {
    this.observers.forEach((observer) =&gt; observer.update(data))
  }
}

const subject = new Subject()

const observer1 = new ConcreteObserver()
const observer2 = new ConcreteObserver()

subject.addObserver(observer1)
subject.addObserver(observer2)

subject.notifyObservers(&quot;Hello, Observers!&quot;)

subject.removeObserver(observer1)
subject.notifyObservers(&quot;Observer1 removed.&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Observer 인터페이스를 구현한 ConcreteObserver가 주체(Subject)의 상태 변화를 감지하고, 주체는 notifyObservers 메서드를 통해 모든 옵저버들에게 변경 사항을 알린다. 옵저버 패턴은 이벤트 핸들링, 데이터 스트리밍 등 다양한 상황에서 유용하게 활용된다.&lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;구조 패턴&lt;/h2&gt;
&lt;h3&gt;데코레이터 패턴 (Decorator Pattern)&lt;/h3&gt;
&lt;p&gt;객체에 새로운 기능을 동적으로 추가할 수 있는 패턴이다. 이 패턴은 상속 대신 컴포지션을 사용하여 기능 확장이 가능하도록 도와준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Component {
  operation(): string
}

class ConcreteComponent implements Component {
  operation(): string {
    return &quot;ConcreteComponent&quot;
  }
}

class Decorator implements Component {
  protected component: Component

  constructor(component: Component) {
    this.component = component
  }

  operation(): string {
    return this.component.operation()
  }
}

class ConcreteDecoratorA extends Decorator {
  operation(): string {
    return `ConcreteDecoratorA(${super.operation()})`
  }
}

class ConcreteDecoratorB extends Decorator {
  operation(): string {
    return `ConcreteDecoratorB(${super.operation()})`
  }
}

const simple = new ConcreteComponent()
console.log(simple.operation())

const decoratorA = new ConcreteDecoratorA(simple)
console.log(decoratorA.operation())

const decoratorB = new ConcreteDecoratorB(decoratorA)
console.log(decoratorB.operation())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Component 인터페이스를 구현한 ConcreteComponent에 Decorator 클래스를 통해 기능을 동적으로 추가할 수 있다. 데코레이터 패턴을 사용하면 기존 객체에 새로운 기능을 추가하면서도 코드의 유연성을 유지할 수 있다.&lt;/p&gt;
&lt;br&gt;
&lt;h3&gt;프록시 패턴 (Proxy Pattern)&lt;/h3&gt;
&lt;p&gt;실제 객체에 대한 접근을 제어하기 위해 대리 객체를 사용하는 패턴이다. 프록시는 원래 객체의 기능을 확장하거나, 접근 제어를 위한 용도로 자주 사용된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Subject {
  request(): void
}

class RealSubject implements Subject {
  request(): void {
    console.log(&quot;RealSubject: Handling request.&quot;)
  }
}

class Proxy implements Subject {
  private realSubject: RealSubject

  constructor(realSubject: RealSubject) {
    this.realSubject = realSubject
  }

  request(): void {
    if (this.checkAccess()) {
      this.realSubject.request()
      this.logAccess()
    }
  }

  private checkAccess(): boolean {
    console.log(&quot;Proxy: Checking access prior to firing a real request.&quot;)
    return true
  }

  private logAccess(): void {
    console.log(&quot;Proxy: Logging the time of request.&quot;)
  }
}

const realSubject = new RealSubject()
const proxy = new Proxy(realSubject)
proxy.request()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Proxy 클래스가 실제 객체인 RealSubject에 대한 접근을 제어한다. 프록시 패턴은 원격 서버와의 통신, 캐싱, 접근 제어와 같은 다양한 시나리오에서 유용하게 사용된다.&lt;/p&gt;
&lt;br&gt;
&lt;h3&gt;어댑터 패턴 (Adapter Pattern)&lt;/h3&gt;
&lt;p&gt;기존 인터페이스를 클라이언트가 원하는 인터페이스로 변환해주는 패턴이다. 이 패턴은 서로 다른 인터페이스를 사용하는 클래스 간의 협력을 가능하게 해준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;class Target {
  request(): string {
    return &quot;Target: The default target&apos;s behavior.&quot;
  }
}

class Adaptee {
  specificRequest(): string {
    return &quot;.eetpadA eht fo roivaheb laicepS&quot;
  }
}

class Adapter extends Target {
  private adaptee: Adaptee

  constructor(adaptee: Adaptee) {
    super()
    this.adaptee = adaptee
  }

  request(): string {
    const result = this.adaptee.specificRequest().split(&quot;&quot;).reverse().join(&quot;&quot;)
    return `Adapter: (TRANSLATED) ${result}`
  }
}

const adaptee = new Adaptee()
console.log(`Adaptee: ${adaptee.specificRequest()}`)

const adapter = new Adapter(adaptee)
console.log(`Adapter: ${adapter.request()}`)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Adaptee 클래스의 인터페이스를 Adapter를 통해 Target 인터페이스로 변환한다. 어댑터 패턴은 기존 클래스를 수정하지 않고도 서로 다른 인터페이스를 사용하는 클래스들을 통합할 수 있는 강력한 방법이다.&lt;/p&gt;
&lt;p&gt;여기까지 TypeScript를 사용하여 여러가지 디자인 패턴을 구현해 보았다. 각각의 패턴이 해결하는 문제와 구현 방법을 이해함으로써 더 나은 소프트웨어 개발에 많은 도움이 될 것이다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Software_design_pattern&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Software design pattern - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Design_Patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Design Patterns - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@waoderboy/Gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Gof 디자인 패턴&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://refactoring.guru/ko/design-patterns/typescript&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;타입스크립트로 작성된 디자인 패턴들&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hanbit.co.kr/channel/category/category_view.html?cms_code=CMS8616098823&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[Design pattern] 많이 쓰는 14가지 핵심 GoF 디자인 패턴의 종류 - 한빛출판네트워크&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[react-device-detect로 기기별 최적화된 화면 만들기]]></title><description><![CDATA[웹 개발에서는 다양한 기기에 대응하는 화면을 제공하는 것 또한 중요하다. React에서 사용자의 기기 정보를 탐지하여 적절한 UI를 제공할 수 있는 라이브러리인 react-device-detect에 대해 다루어 보았다. react-device…]]></description><link>https://yhuj79.github.io/React/240804/</link><guid isPermaLink="false">https://yhuj79.github.io/React/240804/</guid><pubDate>Sun, 04 Aug 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;웹 개발에서는 다양한 기기에 대응하는 화면을 제공하는 것 또한 중요하다. React에서 사용자의 기기 정보를 탐지하여 적절한 UI를 제공할 수 있는 라이브러리인 react-device-detect에 대해 다루어 보았다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;react-device-detect란?&lt;/h2&gt;
&lt;p&gt;몇몇 사이트들은 모바일 접속을 한 경우 특정 창을 띄우거나, 모바일 버전이 개발되지 않았다면 제한을 거는 경우가 있다.&lt;/p&gt;
&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;
    &lt;img alt=&quot;ex-1&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240804/ex-1.png&quot; width=&quot;49%&quot;&gt;
    &lt;img alt=&quot;ex-2&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240804/ex-2.png&quot; width=&quot;49%&quot;&gt;
&lt;/div&gt;
&lt;p&gt;이러한 처리는 물론 반응형 디자인을 통해 적용할 수 있다. 하지만 반응형 디자인은 화면 크기, 해상도에 비례하여 작용하고, 디바이스를 구분하는 것은 아니다. (&lt;a href=&quot;https://mong-blog.tistory.com/entry/CSS-PC%EC%99%80-Mobile%EC%9D%84-%EA%B5%AC%EB%B6%84%ED%95%98%EB%8A%94-2%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;물론 조금 다른 방식으로 가능은 하다.&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;react-device-detect는 사용자의 기기와 브라우저 정보를 확인하고, 이에 맞는 컴포넌트를 렌더링할 수 있게 해주는 라이브러리이다. 이 라이브러리는 모바일, 태블릿, 데스크탑 뿐만 아니라 특정 브라우저와 버전까지 탐지할 수 있다. 예를 들어, 특정 브라우저(Chrome, Safari 등)나 특정 운영체제(Android, iOS 등)를 대상으로 한 맞춤형 UI를 제공하는 데 유용하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기기 탐지: 모바일, 태블릿, 데스크탑 등 다양한 기기를 구분할 수 있다.&lt;/li&gt;
&lt;li&gt;브라우저 탐지: Chrome, Safari, FireFox 등 특정 브라우저를 감지할 수 있다.&lt;/li&gt;
&lt;li&gt;운영체제 및 버전 탐지: Windows, MacOS, iOS, Android 등 다양한 운영체제 및 그 버전을 탐지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;react-device-detect를 설치하고 샘플 코드를 작성해 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ npm install react-device-detect
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import {
  BrowserView,
  MobileView,
  isBrowser,
  isMobile,
} from &quot;react-device-detect&quot;

function App() {
  return (
    &amp;#x3C;div style={{ margin: &quot;30px&quot; }}&gt;
      &amp;#x3C;BrowserView&gt;
        &amp;#x3C;h1&gt;Browser View&amp;#x3C;/h1&gt;
      &amp;#x3C;/BrowserView&gt;
      &amp;#x3C;MobileView&gt;
        &amp;#x3C;h1&gt;Mobile View&amp;#x3C;/h1&gt;
      &amp;#x3C;/MobileView&gt;
      {isBrowser &amp;#x26;&amp;#x26; &amp;#x3C;h3&gt;isBrowser&amp;#x3C;/h3&gt;}
      {isMobile &amp;#x26;&amp;#x26; &amp;#x3C;h3&gt;isMobile&amp;#x3C;/h3&gt;}
    &amp;#x3C;/div&gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;
    &lt;img alt=&quot;detect-1&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240804/detect-1.png&quot; width=&quot;49%&quot;&gt;
    &lt;img alt=&quot;detect-2&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240804/detect-2.png&quot; width=&quot;49%&quot;&gt;
&lt;/div&gt;
&lt;p&gt;모바일 화면은 Chrome의 반응형 디자인 모드에서 확인하였다. 위 예제에서는 BrowserView와 MobileView 컴포넌트를 사용하여 브라우저와 모바일에서 각각 다른 내용을 보여준다. 또한, isBrowser와 isMobile을 사용하여 조건부 렌더링을 구현할 수 있다.&lt;/p&gt;
&lt;h2&gt;브라우저 구분&lt;/h2&gt;
&lt;p&gt;특정 브라우저나 기기에 대한 조건부 렌더링이 필요할 때는 CustomView와 condition을 사용하면 된다. 예를 들어, 특정 브라우저에서만 메시지를 보여주고 싶을 때 아래와 같이 구현할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { CustomView, browserName } from &quot;react-device-detect&quot;

function App() {
  return (
    &amp;#x3C;div style={{ margin: &quot;30px&quot; }}&gt;
      &amp;#x3C;h1&gt;React App&amp;#x3C;/h1&gt;
      &amp;#x3C;CustomView condition={browserName === &quot;Chrome&quot;}&gt;
        &amp;#x3C;h1&gt;This is Chrome Browser.&amp;#x3C;/h1&gt;
      &amp;#x3C;/CustomView&gt;
    &amp;#x3C;/div&gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;
    &lt;img alt=&quot;detect-3&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240804/detect-3.png&quot; width=&quot;49%&quot;&gt;
    &lt;img alt=&quot;detect-4&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240804/detect-4.png&quot; width=&quot;49%&quot;&gt;
&lt;/div&gt;
&lt;h2&gt;활용 예제&lt;/h2&gt;
&lt;p&gt;예제로 모바일 기기에서 접속 시 &quot;PC에서 접속해주세요&quot;라는 메시지를 보여주는 페이지를 구현해 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { isMobile } from &quot;react-device-detect&quot;

function MobilePage() {
  return (
    &amp;#x3C;div style={{ textAlgin: &quot;center&quot;, padding: &quot;20px&quot; }}&gt;
      &amp;#x3C;h1&gt;PC에서 접속해주세요&amp;#x3C;/h1&gt;
      &amp;#x3C;p&gt;모바일에서 접근할 수 없는 페이지입니다.&amp;#x3C;/p&gt;
    &amp;#x3C;/div&gt;
  )
}

function App() {
  return (
    &amp;#x3C;div style={{ margin: &quot;30px&quot; }}&gt;
      {isMobile ? (
        &amp;#x3C;MobilePage /&gt;
      ) : (
        &amp;#x3C;div&gt;
          &amp;#x3C;h1&gt;React&amp;#x3C;/h1&gt;
          &amp;#x3C;h3&gt;사용자 인터페이스를 만들기 위한 JavaScript 라이브러리&amp;#x3C;/h3&gt;
          &amp;#x3C;p&gt;
            React (also known as React.js or ReactJS) is a free and open-source
            front-end JavaScript library for building user interfaces based on
            components by Facebook Inc. It is maintained by Meta (formerly
            Facebook) and a community of individual developers and companies.
            React can be used to develop single-page, mobile, or server-rendered
            applications with frameworks like Next.js. Because React is only
            concerned with the user interface and rendering components to the
            DOM, React applications often rely on libraries for routing and
            other client-side functionality. A key advantage of React is that it
            only rerenders those parts of the page that have changed, avoiding
            unnecessary rerendering of unchanged DOM elements. It was first
            launched on 29 May 2013.
          &amp;#x3C;/p&gt;
        &amp;#x3C;/div&gt;
      )}
    &amp;#x3C;/div&gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&quot;detect-5&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240804/detect-5.png&quot;&gt;
&lt;img alt=&quot;detect-6&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240804/detect-6.png&quot;&gt;
&lt;p&gt;위 예제에서는 isMobile 값을 사용하여 모바일 기기인지 여부를 확인하고, 모바일일 경우 MobilePage 컴포넌트를 렌더링한다. 이런 식으로 모바일 사용자가 PC로 사이트를 이용할 수 있도록 안내할 수 있다.&lt;/p&gt;
&lt;p&gt;react-device-detect는 다양한 기기 및 브라우저 감지를 통해 사용자에게 최적화된 경험을 제공하는 데 유용한 도구이다. 보통의 반응형 웹 디자인의 경우 CSS 미디어 쿼리나 UI 라이브러리에 내장된 디바이스 구분 기능을 사용하는 것이 더 적합할 수 있겠지만, 어떤 상황에서는 이 라이브러리를 사용하는 것도 좋은 방법인 것 같다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/react-device-detect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;react-device-detect - npm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/React_(JavaScript_library)&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;React (JavaScript library) - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@chaerin00/React-react-device-detect%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EC%97%AC-%EB%AA%A8%EB%B0%94%EC%9D%BC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[React] react-device-detect를 활용하여 모바일 페이지 구현하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gofo-coding.tistory.com/entry/Reactjs-react-device-detect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[React] react-device-detect&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React로 360도 돌아가는 이미지 구현 (react-360-view)]]></title><description><![CDATA[360도 회전하는 이미지를 볼 수 있고, 더 나아가 드래그 이벤트를 통해 그 물체를 조작해 볼 수 있는 기능은 다양한 웹사이트에서 사용되고 있다. 주로 자동차, 신발, 시계 등의 상품을 관찰할 수 있게 서비스하는 경우가 많다. 이 포스트는 36…]]></description><link>https://yhuj79.github.io/React/240713/</link><guid isPermaLink="false">https://yhuj79.github.io/React/240713/</guid><pubDate>Sat, 13 Jul 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;360도 회전하는 이미지를 볼 수 있고, 더 나아가 드래그 이벤트를 통해 그 물체를 조작해 볼 수 있는 기능은 다양한 웹사이트에서 사용되고 있다. 주로 자동차, 신발, 시계 등의 상품을 관찰할 수 있게 서비스하는 경우가 많다. 이 포스트는 360 뷰어를 구현할 수 있는 다양한 방법 중 react-360-view 라이브러리를 통해 구현하는 법과 오류 방지 팁, 한계점에 대해 다룬다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;react-360-view&lt;/h2&gt;
&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;
    &lt;img alt=&quot;360viewer1&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/360viewer1.gif&quot; width=&quot;49%&quot;&gt;
    &lt;img alt=&quot;360viewer2&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/360viewer2.gif&quot; width=&quot;49%&quot;&gt;
&lt;/div&gt;
&lt;p&gt;물체에 회전 효과를 주기 위해선 어떤 방법을 사용해야 할까? 자체적으로 3D 프로그램을 통해 개발을 할 수도 있겠지만, 가벼운 프로젝트나 중,소 규모 웹사이트에 적용하기에는 다소 어려워 보인다.&lt;/p&gt;
&lt;p&gt;간단하게 생각해 보면 다른 각도를 지닌 사진 여러 장을 부드럽게 전환하는 것도 좋은 방법이다.&lt;/p&gt;
&lt;div style=&quot;display: flex; flex-wrap: wrap;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-1.webp&quot; alt=&quot;car-1&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-2.webp&quot; alt=&quot;car-2&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-3.webp&quot; alt=&quot;car-3&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-4.webp&quot; alt=&quot;car-4&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-5.webp&quot; alt=&quot;car-5&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-6.webp&quot; alt=&quot;car-6&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-7.webp&quot; alt=&quot;car-7&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-8.webp&quot; alt=&quot;car-8&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-9.webp&quot; alt=&quot;car-9&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-10.webp&quot; alt=&quot;car-10&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-11.webp&quot; alt=&quot;car-11&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-12.webp&quot; alt=&quot;car-12&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-13.webp&quot; alt=&quot;car-13&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-14.webp&quot; alt=&quot;car-14&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-15.webp&quot; alt=&quot;car-15&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-16.webp&quot; alt=&quot;car-16&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-17.webp&quot; alt=&quot;car-17&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-18.webp&quot; alt=&quot;car-18&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-19.webp&quot; alt=&quot;car-19&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-20.webp&quot; alt=&quot;car-20&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-21.webp&quot; alt=&quot;car-21&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-22.webp&quot; alt=&quot;car-22&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-23.webp&quot; alt=&quot;car-23&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-24.webp&quot; alt=&quot;car-24&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-25.webp&quot; alt=&quot;car-25&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-26.webp&quot; alt=&quot;car-26&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-27.webp&quot; alt=&quot;car-27&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-28.webp&quot; alt=&quot;car-28&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-29.webp&quot; alt=&quot;car-29&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-30.webp&quot; alt=&quot;car-30&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-31.webp&quot; alt=&quot;car-31&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-32.webp&quot; alt=&quot;car-32&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-33.webp&quot; alt=&quot;car-33&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-34.webp&quot; alt=&quot;car-34&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-35.webp&quot; alt=&quot;car-35&quot; style=&quot;width: 16.66%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car/car-36.webp&quot; alt=&quot;car-36&quot; style=&quot;width: 16.66%;&quot;&gt;
&lt;/div&gt;
&lt;p&gt;위처럼 여러 각도를 가진 이미지들이 있고, 이를 부드럽게 전환시킨다면 해당 물체가 360도로 돌아가는 느낌을 줄 수 있다.&lt;/p&gt;
&lt;p&gt;라이브러리를 사용하지 않고 드래그 이벤트 처리를 통해 마우스 이동 방향에 따라 이미지 값을 바꾸어 가는 방식으로 개발을 할 수도 있지만, &lt;code&gt;react-360-view&lt;/code&gt; 라이브러리를 사용하면 복잡한 코드를 작성하지 않고 간단하게 구현해낼 수 있다. (그만큼 존재하는 단점에 대해서는 포스트 뒷 부분에)&lt;/p&gt;
&lt;img alt=&quot;img-list&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/img-list.png&quot; width=&quot;30%&quot;&gt;
&lt;p&gt;각도 변화에 따른 여러 이미지가 준비되어 있어야 한다. 구현에는 GitHub에 업로드한 차량 이미지를 사용해 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ npx create-react-app react360view
$ cd react360view
$ npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;먼저 React를 설치한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ npm install react-360-view
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;react-360-view 라이브러리를 설치한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// App.js
import ThreeSixty from &quot;react-360-view&quot;
import &quot;./App.css&quot;

function App() {
  return (
    &amp;#x3C;div&gt;
      &amp;#x3C;div
        style={{
          width: &quot;40%&quot;,
          alignItems: &quot;center&quot;,
          border: &quot;2px solid black&quot;,
          margin: &quot;30px auto&quot;,
          position: &quot;relative&quot;,
        }}
      &gt;
        &amp;#x3C;ThreeSixty
          amount={36}
          imagePath=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/car&quot;
          fileName=&quot;car-{index}.webp&quot;
          spinReverse
        /&gt;
      &amp;#x3C;/div&gt;
    &amp;#x3C;/div&gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* App.css */
@import url(&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;App.js와 App.css의 내용을 위와 같이 수정했다. 여기서 css는 라이브러리의 아이콘이 fontawesome을 사용하기 때문에 적용되었다.&lt;/p&gt;
&lt;p&gt;ThreeSixty 속성을 살펴보면 amount가 있는데, 뷰어에 적용될 총 이미지 수를 넣으면 된다. 이미지 수가 많아질수록 미세한 각도까지 표현되면서 더 부드러워질 것이다. imagePath에는 도메인을, fileName에는 이미지 이름과 형식을 적었다. 이 부분이 중요한데, {index}를 통해 이미지 순서에 따라 구현이 된다. 사용한 이미지가 car-1, car-2, car-3 ... 의 패턴이기 때문에 car-{index}.webp 로 작성하였다.&lt;/p&gt;
&lt;img alt=&quot;360viewer3&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/360viewer3.gif&quot;&gt;
&lt;p&gt;이미지가 부드럽게 돌아간다. 드래그에 따른 반응 또한 문제 없이 잘 이루어진다.&lt;/p&gt;
&lt;p&gt;다른 느낌을 보기 위해 &lt;a href=&quot;https://www.google.com/intl/ko_ALL/earth&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Google Earth&lt;/a&gt; 에서 캡쳐한 지구로 다시 테스트해 보았다.&lt;/p&gt;
&lt;div style=&quot;display: flex; flex-wrap: wrap;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-1.png&quot; alt=&quot;earth-1&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-2.png&quot; alt=&quot;earth-2&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-3.png&quot; alt=&quot;earth-3&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-4.png&quot; alt=&quot;earth-4&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-5.png&quot; alt=&quot;earth-5&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-6.png&quot; alt=&quot;earth-6&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-7.png&quot; alt=&quot;earth-7&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-8.png&quot; alt=&quot;earth-8&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-9.png&quot; alt=&quot;earth-9&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-10.png&quot; alt=&quot;earth-10&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-11.png&quot; alt=&quot;earth-11&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-12.png&quot; alt=&quot;earth-12&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-13.png&quot; alt=&quot;earth-13&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-14.png&quot; alt=&quot;earth-14&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-15.png&quot; alt=&quot;earth-15&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-16.png&quot; alt=&quot;earth-16&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-17.png&quot; alt=&quot;earth-17&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-18.png&quot; alt=&quot;earth-18&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-19.png&quot; alt=&quot;earth-19&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-20.png&quot; alt=&quot;earth-20&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-21.png&quot; alt=&quot;earth-21&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-22.png&quot; alt=&quot;earth-22&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-23.png&quot; alt=&quot;earth-23&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-24.png&quot; alt=&quot;earth-24&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-25.png&quot; alt=&quot;earth-25&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-26.png&quot; alt=&quot;earth-26&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-27.png&quot; alt=&quot;earth-27&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-28.png&quot; alt=&quot;earth-28&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-29.png&quot; alt=&quot;earth-29&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-30.png&quot; alt=&quot;earth-30&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-31.png&quot; alt=&quot;earth-31&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-32.png&quot; alt=&quot;earth-32&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-33.png&quot; alt=&quot;earth-33&quot; style=&quot;width: 11.11%;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth/earth-34.png&quot; alt=&quot;earth-34&quot; style=&quot;width: 11.11%;&quot;&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;img alt=&quot;360viewer4&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/360viewer4.gif&quot;&gt;
&lt;p&gt;지구가 열심히 돌아간다.&lt;/p&gt;
&lt;p&gt;이 이상으로는 GIF 프레임의 한계 때문에 느낌이 전달되지 않기 때문에 react-360-view에 대해 궁금하거나 관련 기능을 필요로 하고 있다면, 이미지를 구해 실제로 테스트를 해보는 것을 추천한다.&lt;/p&gt;
&lt;h2&gt;스크롤 시 오류 방지&lt;/h2&gt;
&lt;p&gt;react-360-view 라이브러리는 회전 뿐만 아니라 이미지의 확대, 축소 기능도 제공한다. 위에서 다룬 지구를 예로 들자면, Google Earth만큼 좋은 화질은 아니겠지만 원하는 부분을 확대해볼 수 있다.&lt;/p&gt;
&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;
    &lt;img alt=&quot;360viewer-zoom1&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/360viewer-zoom1.gif&quot; width=&quot;49%&quot;&gt;
    &lt;img alt=&quot;360viewer-zoom2&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/360viewer-zoom2.gif&quot; width=&quot;49%&quot;&gt;
&lt;/div&gt;
&lt;p&gt;하지만 프로젝트에 적용할 때 한 가지 문제가 발생한다. 이미지 위에 마우스가 위치할 때 확대 및 축소가 발생할 텐데, 웹페이지의 다른 부분에서부터 스크롤을 진행하다가 뷰어 위에 마우스가 위치하게 된다면 의도치 않게 확대, 축소가 작동할 가능성이 있다.&lt;/p&gt;
&lt;p&gt;확대와 축소는 이미지 아래 툴 박스를 이용하면 충분하다. 그래서 오류 방지를 위해 wheel event 발생을 차단하는 코드를 추가해 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { useEffect } from &quot;react&quot;
import ThreeSixty from &quot;react-360-view&quot;
import &quot;./App.css&quot;

function App() {
  // 스크롤 시 의도치 않게 특정 요소가 확대, 축소되는 현상 방지
  useEffect(() =&gt; {
    const element = document.getElementById(&quot;container-viewer&quot;)

    if (element) {
      const handleWheel = (event) =&gt; {
        event.stopPropagation()
      }

      // wheel event가 다른 요소로 전파되기 전에 stopPropagation에 의해 중단
      element.addEventListener(&quot;wheel&quot;, handleWheel)

      // 언마운트 될 때, wheel event listener 제거
      return () =&gt; {
        element.removeEventListener(&quot;wheel&quot;, handleWheel)
      }
    }
  }, [])

  return (
    &amp;#x3C;div&gt;
      &amp;#x3C;div
        id=&quot;container-viewer&quot;
        style={{
          width: &quot;40%&quot;,
          alignItems: &quot;center&quot;,
          border: &quot;2px solid black&quot;,
          margin: &quot;30px auto&quot;,
          position: &quot;relative&quot;,
        }}
      &gt;
        &amp;#x3C;ThreeSixty
          amount={34}
          imagePath=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240713/earth&quot;
          fileName=&quot;earth-{index}.png&quot;
          spinReverse
        /&gt;
      &amp;#x3C;/div&gt;
    &amp;#x3C;/div&gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;div에 container-viewer라는 id를 부여하여 관리한다. 이벤트 리스너를 통해 wheel event를 제어함으로써 해당 컨테이너는 스크롤이 더이상 작동하지 않게 되었다.&lt;/p&gt;
&lt;h2&gt;한계점&lt;/h2&gt;
&lt;p&gt;지금까지 다룬 부분에 대해서만 다룰 것이라면, 이 라이브러리는 기능적으로 충분하다.&lt;/p&gt;
&lt;p&gt;하지만 좀 더 깊이 다루고자 한다면 막히는 부분이 생긴다. 예시를 몇 개 들어보자면...&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;amount가 많고 고화질인 이미지의 로딩 문제&lt;/li&gt;
&lt;li&gt;이미지 교체가 필요할 때 (ex: 자동차의 타이어, 자동차의 색상, 신발 끈 색상 등)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1번 예시처럼 로딩 문제가 발생할 경우 &lt;a href=&quot;https://yhuj79.github.io/React/240608&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Pre Loading&lt;/a&gt; 과 같은 이미지 처리가 필요할 것이고, 2번의 경우 직접 드래그 이벤트를 작성하면서 뷰어를 처음부터 개발해 나가야 할 것이다. Vanilla Javascript로 코드를 작성한다면 throttle 도달 수치를 조정하여 드래그 감도를 조절하고, 자동차의 색상이나 타이어를 교체할 수 있게 추가적인 커스터마이징도 충분히 가능할 것이다. 대신 그만큼 필요한 이미지의 수 또한 늘어날 것이다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/react-360-view&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;react-360-view - npm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=CmxVQ7XV9WE&amp;#x26;ab_channel=CodeWithYd&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;360 degrees Product Viewer in React js - Code With Yd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://studio3.com/gifs-and-spins/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;GIFs and Spins: Making your Product Come to Life&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mercedes-benz.com.au/passengercars/configurator.html?group=all&amp;#x26;subgroup=see-all&amp;#x26;view=BODYTYPE&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Configurator | Mercedes-Benz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.google.com/intl/ko_ALL/earth&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Google Earth&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[NP-난해와 NP-완전의 혼용]]></title><description><![CDATA[알고리즘 문제의 복잡성에 대해 이야기할 때, P-NP, NP-완전, NP-난해와 같은 용어들이 등장하게 된다. 외판원 순회, 부분집합의 합과 같은 문제들에 대해 찾아볼 때 각 정보글마다 NP-완전이니, NP…]]></description><link>https://yhuj79.github.io/Algorithm/240624/</link><guid isPermaLink="false">https://yhuj79.github.io/Algorithm/240624/</guid><pubDate>Mon, 24 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;알고리즘 문제의 복잡성에 대해 이야기할 때, P-NP, NP-완전, NP-난해와 같은 용어들이 등장하게 된다. 외판원 순회, 부분집합의 합과 같은 문제들에 대해 찾아볼 때 각 정보글마다 NP-완전이니, NP-난해니 말이 달라서 혼란이 있었다. 이에 대해 좀 더 조사해 보니, 그렇게 헷갈리게 된 원인이 파악되었다. 이 포스트에서는 P-NP의 개념과 함께 &lt;strong&gt;NP-난해 (NP-hard)&lt;/strong&gt;와 &lt;strong&gt;NP-완전 (NP-complete)&lt;/strong&gt;의 차이를 명확히 하고, 추가적으로 외판원 순회 문제의 두 가지 종류에 대한 내용도 다루었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;P와 NP&lt;/h2&gt;
&lt;p&gt;먼저 이 개념은 결정론적, 비결정론적 튜링 머신과 관련되어 있다. &lt;strong&gt;튜링 머신 (Turing machine)&lt;/strong&gt;은 수학자 앨런 튜링(Alan Turing)이 1936년에 제시한 개념으로, 계산하는 기계의 일반적인 개념을 설명하기 위한 가상의 기계다. 튜링은 이 개념을 Automatic에서 따온 A-Machine이라고 불렀는데 튜링 사후에 창시자의 이름을 따 튜링 머신이라고 부르게 되었다.&lt;/p&gt;
&lt;p&gt;따라서 튜링 머신은 실존하는 기계가 아니라 수학적 상상이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;결정론적 튜링 머신&lt;/strong&gt;: 매 순간 다음 상태를 하나만 가질 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비결정론적 튜링 머신&lt;/strong&gt;: 매 순간 여러 개의 다음 상태를 가질 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P (Polynomial Time)&lt;/strong&gt;는 결정론적 튜링 머신이 다항 시간 내에 풀 수 있는 문제들의 집합이다. 다항식(Polynomial) 시간 이내에 그 문제의 답을 계산해낼 수 있는 알고리즘이 존재한다면, 그 문제는 P 문제에 해당된다. 결론적으로 네, 아니오로 명확히 대답할 수 있고, 답을 찾는 것에 그리 오랜 시간이 걸리지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NP (Non-Deterministic Polynomial Time)&lt;/strong&gt;는 비결정론적 튜링 머신이 다항 시간 내에 풀 수 있는 문제들이다. 문제를 푸는 각 단계에서 여러 가지의 가능성을 동시에 고려할 수 있는 비결정적 알고리즘(Non-Deterministic Algorithm)으로, 이는 &apos;알맞은 힌트&apos;를 주면 다항 시간 내에 검증할 수 있는 문제로 생각할 수도 있다. 따라서 NP는 풀이가 힘들 수 있지만, 답이 맞는지는 확인할 수 있는 문제다.&lt;/p&gt;
&lt;img alt=&apos;pnp&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240624/pnp.png&apos;&gt;
&lt;p&gt;P는 NP에 포함되며, 모든 P 문제는 NP 문제다. NP 문제 중 일부는 아직 결정론적 튜링 머신으로 다항 시간 내에 풀 수 있는지(즉, P에 속하는지) 불확실하다.&lt;/p&gt;
&lt;h2&gt;NP-난해 (NP-Hard)&lt;/h2&gt;
&lt;p&gt;다음은 NP 문제에 대한 문제 포함 관계 그림이다. 아직 완전히 증명되지는 못했으나, 대부분의 전문가들에 의해 이 형태가 맞을 것으로 추정하고 있다고 한다.&lt;/p&gt;
&lt;img alt=&apos;nphard&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240624/nphard.png&apos;&gt;
&lt;p&gt;&lt;strong&gt;NP-난해 (NP-Hard)&lt;/strong&gt;는 NP 문제를 포함한 더 어려운 문제까지 포괄하는 개념으로, 주어진 답을 빠르게 검증할 수 있는지 여부와 관계없이 모든 NP 문제를 이 문제로 변환할 수 있는 문제이다. 적어도 모든 NP 문제만큼은 어려운 문제들의 집합이다.&lt;/p&gt;
&lt;p&gt;즉, 어떤 NP-난해 문제를 풀 수 있다면, 모든 NP 문제도 다항 시간 내에 풀 수 있다는 의미다. 하지만 NP-난해 문제는 NP에 속하지 않을 수도 있어, 검증조차 다항 시간 내에 불가능할 수 있다. NP-난해 문제들은 보통 근사나 휴리스틱한 방법 등 간접적으로 해결된다.&lt;/p&gt;
&lt;h4&gt;주요 NP-난해 문제&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;외판원 순회(Traveling Salesman Problem) (최적화 버전)
정지 문제(Halting Problem)
부분 집합의 합(Subset Sum) (NP-완전에도 속함)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;NP-완전 (NP-Complete)&lt;/h2&gt;
&lt;img alt=&apos;npcomplete&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240624/npcomplete.png&apos;&gt;
&lt;p&gt;&lt;strong&gt;NP-완전 (NP-Complete)&lt;/strong&gt;는 NP-난해 문제의 하위 집합으로, NP에 속하면서 NP 난해인 문제이다. 해결 방법이 주어졌을 때 빠르게(다항 시간 내에) 검증할 수 있으며, 다른 모든 NP 문제를 다항 시간 내에 변환할 수 있는 문제를 뜻한다.&lt;/p&gt;
&lt;p&gt;NP-완전 문제를 풀 수 있는 알고리즘이 존재한다면, 모든 NP 문제를 풀 수 있는 알고리즘도 존재한다는 뜻이다. 따라서 NP-완전 문제는 NP와 P의 관계를 이해하는 데 매우 중요하다.&lt;/p&gt;
&lt;h4&gt;주요 NP-완전 문제&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;외판원 순회(Traveling Salesman Problem) (결정형 버전)
해밀턴 경로(Hamiltonian Path)
충족 가능성 문제(Satisfiability Problem)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;난해와 완전이 혼용되어 사용된 이유&lt;/h2&gt;
&lt;p&gt;어떠한 알고리즘 문제에 대해 A 글에서는 NP-완전 문제이다... B 글에서는 NP-난해 문제이다... 표현이 다르면 이 개념에 대해 처음 배우게 될 때 굉장한 혼란이 될 수 있다.&lt;/p&gt;
&lt;h4&gt;부분집합의 합 문제&lt;/h4&gt;
&lt;img alt=&apos;subsetsum&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240624/subsetsum.png&apos;&gt;
&lt;p&gt;NP-난해에 해당하는 문제 중 &lt;strong&gt;부분집합의 합 문제(Subset Sum)&lt;/strong&gt;가 있다. 이 문제는 계산 복잡도 이론과 암호학에 관련된 문제로, n개의 원소를 가진 정수의 집합 S가 주어지고, 임의의 정수 K가 주어졌을 때, 합이 K가 되는 부분집합이 있는지를 묻는 문제이다. &lt;a href=&quot;https://www.geeksforgeeks.org/subset-sum-is-np-complete/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;기본적으로 NP-완전 문제라 볼 수 있지만&lt;/a&gt;, 부분집합의 합 문제를 다룬 여러 정보글에서 NP-난해, NP-완전을 혼용하여 사용한 것이 확인되었다.&lt;/p&gt;
&lt;p&gt;앞서 다룬 개념대로 보자면 1차적으로 &lt;strong&gt;NP-완전 문제는 NP-난해 문제의 하위 집합이다.&lt;/strong&gt; 문제를 다루기에 앞서 NP-난해와 NP-완전의 문제 포함 관계에 대해 정의하고 들어가거나, &lt;code&gt;Subset Sum 문제는 NP-난해이면서 NP-완전 문제이다.&lt;/code&gt; 라고 명시하는 것이 옳게 된 표현이다.&lt;/p&gt;
&lt;h4&gt;최적화, 결정형 외판원 순회 문제&lt;/h4&gt;
&lt;img alt=&apos;tsp&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240624/tsp.png&apos;&gt;
&lt;p&gt;&lt;strong&gt;외판원 순회 문제(Traveling Salesman Problem)&lt;/strong&gt;는 주어진 모든 도시를 한 번씩 방문하고 다시 시작 도시로 돌아오는 경로에 대한 문제이다.&lt;/p&gt;
&lt;p&gt;보통의 외판원 순회 문제는 각 도시의 최소 여행 경로를 찾는 것을 원하므로, 이 경우는 NP-난해에 해당한다. &lt;strong&gt;최적해를 찾는 경우(최적화 버전, Optimization Version)&lt;/strong&gt;인 것이다.&lt;/p&gt;
&lt;p&gt;최단 경로가 아닌 특정한 조건을 원하는 경우의 형태도 있다. 가중치의 합이 어떤 값 이하인 것이라던가. 이러면 &lt;strong&gt;결정형 버전(Decision Version)&lt;/strong&gt;이 된다. 이는 최적화 문제로서의 외판원 순회 문제와 달리, 경로의 길이가 특정 임계값 이하인지를 확인하는 형태로 바뀌었기 때문에 NP-완전의 조건을 만족한다.&lt;/p&gt;
&lt;p&gt;두 가지 버전을 예시와 함께 정리해 보면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;외판원 순회 문제(최적화 버전)&lt;/strong&gt; : 한 도시에서 출발하여 모든 도시를 한 번씩 방문하고 다시 출발지로 돌아오는 최소 비용의 경로를 찾는 문제이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;외판원 순회 문제(결정형 버전)&lt;/strong&gt; : 주어진 비용 C 이하로 모든 도시를 한 번씩 방문하고 다시 출발지로 돌아오는 경로가 존재하는지를 묻는 문제로, &quot;모든 도시를 한 번씩 방문하고 다시 출발지로 돌아오는 경로의 총 비용이 C 이하인 경로가 존재하는가?&quot;라는 질문을 하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 통상적인 외판원 순회에서 변형된 버전은 NP-완전이 될 수 있다. 외판원 순회는 문제들 중에서도 어려운 편으로, 일반적인 외판원 순회 문제에 대한 다항 시간 근사 알고리즘은 P = NP가 아닌 한 존재하지 않는다는 것이 밝혀져 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://3catpapa.tistory.com/53&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;제 13강 근사 알고리즘(튜링기계,다항시간,클래스P,클래스NP)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://optboy.github.io/programming/2020/04/03/P_NP.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;P, NP 문제&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@hysong/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-P-NP-%EB%AC%B8%EC%A0%9CP-NP-Problem&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;P-NP 문제(P-NP Problem)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Alan_Turing&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Alan Turing - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/NP-%EB%82%9C%ED%95%B4&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;NP-난해 - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zeddios.tistory.com/176&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;TSP는 NP-Complete&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sevity.tistory.com/16&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;subset sum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%99%B8%ED%8C%90%EC%9B%90_%EB%AC%B8%EC%A0%9C&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;외판원 문제 - Wikipedia&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React에서 이미지 Pre Loading 처리 테스트 해보기]]></title><description><![CDATA[웹 페이지 개발을 하다 보면 이미지의 로딩에 의해 렌더링이 부자연스럽거나 끊기는 현상이 종종 발생한다. 이를 처리하기 위한 다양한 방법 중 프리 로딩(Pre Loading)을 예제를 통해 적용시켜 보았다. Image Pre Loading…]]></description><link>https://yhuj79.github.io/React/240608/</link><guid isPermaLink="false">https://yhuj79.github.io/React/240608/</guid><pubDate>Sat, 08 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;웹 페이지 개발을 하다 보면 이미지의 로딩에 의해 렌더링이 부자연스럽거나 끊기는 현상이 종종 발생한다. 이를 처리하기 위한 다양한 방법 중 프리 로딩(Pre Loading)을 예제를 통해 적용시켜 보았다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Image Pre Loading&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;이미지 프리 로딩 (Image Pre Loading)&lt;/strong&gt;이란 사용자가 실제로 요청하기 전에 미리 이미지를 다운로드하여 캐시에 저장하는 웹 성능 최적화 기술이다. 사용자가 페이지를 방문할 때 브라우저는 이미 캐시에 저장된 이미지를 로드하여 페이지 로딩 속도를 향상시킬 수 있다.&lt;/p&gt;
&lt;p&gt;Pre Loading은 다음과 같은 장점을 제공한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;로딩 속도 향상&lt;/strong&gt; : 사용자가 실제로 요청하기 전에 미리 처리하기 때문에 로딩 속도가 크게 향상된다. 이는 이미지가 많은 페이지에서 효과적일 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;사용자 경험 향상&lt;/strong&gt; : 빠른 로딩 속도는 사용자 경험을 향상시키고 사용자 참여도를 높일 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;데이터 사용량 감소&lt;/strong&gt; : 이미지가 이미 캐시에 저장되어 있으므로 사용자는 네트워크를 통해 이미지를 다시 다운로드할 필요가 없어 데이터 사용량을 줄일 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;하지만 다음과 같은 단점도 가지고 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;서버 부하 증가&lt;/strong&gt; : Pre Loading을 사용하면 서버에 추가적인 부하가 발생할 수 있다. 특히 많은 사용자가 동시에 이미지를 Pre Loading하는 경우 서버 성능에 영향을 미칠 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;캐시 공간 사용 증가&lt;/strong&gt; : Pre Loading된 이미지는 사용자 기기의 캐시 공간을 차지한다. 캐시 공간이 부족하면 다른 데이터를 저장하는 데 영향을 미칠 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Pre Loading 방법, 고려 사항&lt;/h2&gt;
&lt;p&gt;Pre Loading 방법에는 다음과 같은 것들이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;&amp;#x3C;link rel=&quot;preload&quot;&gt;&lt;/code&gt; 태그 사용&lt;/strong&gt;: HTML5에서 도입된 &lt;code&gt;&amp;#x3C;link rel=&quot;preload&quot;&gt;&lt;/code&gt; 태그는 이미지, CSS, JavaScript 파일 등을 미리 로딩하도록 지시하는 데 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JavaScript 사용&lt;/strong&gt;: JavaScript를 사용하여 이미지를 미리 로딩할 수 있다. &lt;code&gt;Image&lt;/code&gt; 객체를 사용하여 이미지를 로드하고 &lt;code&gt;onload&lt;/code&gt; 이벤트를 사용하여 이미지가 로드되었는지 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Server Pre Loading&lt;/strong&gt;: 서버 측에서 이미지를 미리 로딩하고 응답 헤더에 &lt;code&gt;Cache-Control&lt;/code&gt; 및 &lt;code&gt;Expires&lt;/code&gt; 헤더를 사용하여 캐싱하도록 지시할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pre Loading을 사용할 때는 다음 사항을 고려해야 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Pre Loading할 이미지 선택&lt;/strong&gt;: 모든 이미지를 Pre Loading하는 것은 서버 부하와 캐시 공간 사용량을 증가시킬 수 있으므로 중요하거나 자주 표시되는 이미지만 Pre Loading하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;사용자 연결 속도 고려&lt;/strong&gt;: 사용자의 연결 속도가 느린 경우 Pre Loading이 오히려 페이지 로딩 속도를 느리게 만들 수 있다. 따라서 사용자 연결 속도에 따라 Pre Loading 전략을 조정해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A/B 테스트 수행&lt;/strong&gt;: Pre Loading이 실제로 페이지 로딩 속도와 사용자 경험에 어떤 영향을 미치는지 확인하기 위해 A/B 테스트를 수행하는 것이 좋다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;다음은 JavaScript를 사용한 Pre Loading 예시이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Javascript
function preLoad(arr) {
  arr.forEach((url) =&gt; {
    const image = new Image()
    image.src = url
  })
}

preLoad([&quot;a.png&quot;, &quot;b.png&quot;, &quot;c.png&quot;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;preLoad 함수는 이미지 URL 배열을 받아 각 URL에 대해 Image 객체를 생성하고, 해당 URL을 src 속성에 할당하여 이미지를 로드한다. 이렇게 하면 사용자가 해당 이미지를 필요로 할 때 브라우저가 이미지를 캐시에서 빠르게 로드할 수 있다.&lt;/p&gt;
&lt;h2&gt;React 예제 만들기&lt;/h2&gt;
&lt;p&gt;이미지 Pre Loading의 효과를 확인하기 위해 많은 양의 이미지를 출력하는 웹 페이지를 작성하고 테스트해 보았다. 먼저 일반적으로 작성한 경우이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// React App
import { useState, useEffect } from &quot;react&quot;
import &quot;./App.css&quot;

function App() {
  const totalImages = 300
  const arrImg = Array.from(
    { length: totalImages },
    (_, index) =&gt; `https://picsum.photos/id/${index}/500/400`
  )

  const [num, setNum] = useState(0)
  const [isStarted, setIsStarted] = useState(false)

  useEffect(() =&gt; {
    let interval
    if (isStarted) {
      interval = setInterval(() =&gt; {
        setNum((prevNum) =&gt; {
          if (prevNum &gt;= totalImages) {
            clearInterval(interval)
            return prevNum
          }
          return prevNum + 1
        })
      }, 30)
    }
    return () =&gt; clearInterval(interval)
  }, [isStarted, totalImages])

  // 로딩되지 않는 picsum 이미지는 1번 이미지로 대체
  const handleImageError = (e) =&gt; {
    e.target.src = &quot;https://picsum.photos/id/1/500/400&quot;
  }

  return (
    &amp;#x3C;div className=&quot;App&quot;&gt;
      &amp;#x3C;div className=&quot;num-grid&quot;&gt;
        &amp;#x3C;h1&gt;PreLoad OFF&amp;#x3C;/h1&gt;
        &amp;#x3C;h1 className=&quot;num&quot;&gt;{num}&amp;#x3C;/h1&gt;
      &amp;#x3C;/div&gt;
      &amp;#x3C;button className=&quot;button&quot; onClick={() =&gt; setIsStarted(true)}&gt;
        Start
      &amp;#x3C;/button&gt;
      &amp;#x3C;div className=&quot;image-grid&quot;&gt;
        {arrImg.slice(0, num).map((src, index) =&gt; (
          &amp;#x3C;div key={index} className=&quot;image-container&quot;&gt;
            &amp;#x3C;div className=&quot;image-number&quot;&gt;{index + 1}&amp;#x3C;/div&gt;
            &amp;#x3C;img
              className=&quot;image&quot;
              alt={index}
              src={src}
              onError={handleImageError}
            /&gt;
          &amp;#x3C;/div&gt;
        ))}
      &amp;#x3C;/div&gt;
    &amp;#x3C;/div&gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// CSS
.App {
  text-align: center;
}

.num-grid {
  justify-content: center;
  display: flex;
}

.num {
  width: 100px;
  color: blue;
}

.button {
  width: 100px;
  height: 30px;
  font-size: 15px;
  margin: 0 20px;
}

.image-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
  gap: 10px;
  padding: 20px;
}

.image-container {
  position: relative;
  height: 56.6px;
}

.image-number {
  position: absolute;
  top: 3px;
  left: 3px;
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  border-radius: 50%;
  width: 25px;
  height: 25px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
}

.image {
  width: 100%;
  height: auto;
  display: block;
  border-radius: 10px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;preloadoff&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240608/preloadoff.gif&apos;&gt;
&lt;p&gt;이미지는 &lt;a href=&quot;https://picsum.photos/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Lorem Picsum&lt;/a&gt;의 더미 이미지를 활용하였다.&lt;/p&gt;
&lt;p&gt;Start 버튼을 누르면 1번 ~ 300번의 Picsum 이미지를 순차적으로 로드하는 방식이다. setInterval을 사용하여 일정 시간 간격으로 num 상태를 증가시키고, num에 따라 이미지를 로드한다. 위의 결과로 보다시피 로딩 시간이 걸려 렌더링이 지연되는 것을 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;Pre Loading 적용 테스트&lt;/h2&gt;
&lt;p&gt;이제 이 코드에 Pre Loading을 적용시켜 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// React App
import { useState, useEffect } from &quot;react&quot;
import &quot;./App.css&quot;

function App() {
  const totalImages = 300
  const arrImg = Array.from(
    { length: totalImages },
    (_, index) =&gt; `https://picsum.photos/id/${index}/500/400`
  )

  const [num, setNum] = useState(0)
  const [isStarted, setIsStarted] = useState(false)
  const [preloadedImages, setPreloadedImages] = useState([])
  const [isPreloaded, setIsPreloaded] = useState(false)

  useEffect(() =&gt; {
    function preloadImages(arr) {
      const loadedImages = []
      let loadedCount = 0
      arr.forEach((url, index) =&gt; {
        const image = new Image()
        image.src = url
        image.onload = () =&gt; {
          loadedImages[index] = image
          loadedCount++
          if (loadedCount === arr.length) {
            setPreloadedImages(loadedImages)
            setIsPreloaded(true)
          }
        }
        // 로딩되지 않는 picsum 이미지 처리
        image.onerror = () =&gt; {
          const fallbackImage = new Image()
          fallbackImage.src = &quot;https://picsum.photos/id/1/500/400&quot;
          loadedImages[index] = fallbackImage
          loadedCount++
          if (loadedCount === arr.length) {
            setPreloadedImages(loadedImages)
            setIsPreloaded(true)
          }
        }
      })
    }

    preloadImages(arrImg)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  useEffect(() =&gt; {
    let interval
    if (isStarted) {
      interval = setInterval(() =&gt; {
        setNum((prevNum) =&gt; {
          if (prevNum &gt;= totalImages) {
            clearInterval(interval)
            return prevNum
          }
          return prevNum + 1
        })
      }, 10)
    }
    return () =&gt; clearInterval(interval)
  }, [isStarted, totalImages])

  const handleImageError = (e) =&gt; {
    e.target.src = &quot;https://picsum.photos/id/1/500/400&quot;
  }

  return (
    &amp;#x3C;div className=&quot;App&quot;&gt;
      &amp;#x3C;div className=&quot;num-grid&quot;&gt;
        &amp;#x3C;h1&gt;PreLoad {isPreloaded ? &quot;ON&quot; : &quot;OFF&quot;}&amp;#x3C;/h1&gt;
        &amp;#x3C;h1 className=&quot;num&quot;&gt;{num}&amp;#x3C;/h1&gt;
      &amp;#x3C;/div&gt;
      &amp;#x3C;button
        className=&quot;button&quot;
        onClick={() =&gt; setIsStarted(true)}
        disabled={!isPreloaded}
      &gt;
        Start
      &amp;#x3C;/button&gt;
      &amp;#x3C;div className=&quot;image-grid&quot;&gt;
        {preloadedImages.slice(0, num).map((image, index) =&gt; (
          &amp;#x3C;div key={index} className=&quot;image-container&quot;&gt;
            &amp;#x3C;div className=&quot;image-number&quot;&gt;{index + 1}&amp;#x3C;/div&gt;
            &amp;#x3C;img
              className=&quot;image&quot;
              alt={index}
              src={image.src}
              onError={handleImageError}
            /&gt;
          &amp;#x3C;/div&gt;
        ))}
      &amp;#x3C;/div&gt;
    &amp;#x3C;/div&gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;preloadcache&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240608/preloadcache.gif&apos;&gt;
&lt;p&gt;컴포넌트가 마운트될 때 모든 이미지를 미리 로딩하여 preloadedImages 상태에 저장한다. isPreloaded 상태를 통해 모든 이미지가 로드되었는지 확인하고, 사용자가 버튼을 클릭하면 이미지를 순차적으로 표시한다.&lt;/p&gt;
&lt;img alt=&apos;preloadon&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240608/preloadon.gif&apos;&gt;
&lt;p&gt;이미지 렌더링이 끊기지 않고 부드럽게 잘 나온다.&lt;/p&gt;
&lt;p&gt;결과적으로 Pre Loading을 적용했을 때 확실히 이미지 로드 시 끊김 현상이 없음을 알 수 있다. 위와 같은 방법은 초기 로딩 과정이 어느 정도 필요하다. 따라서 이러한 방식을 어떻게 알맞게 사용하느냐에 따라 사용자 경험을 크게 향상시킬 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://picsum.photos/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Lorem Picsum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@younyikim/JS-Image-Preload-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%AF%B8%EB%A6%AC-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Image Preload (이미지 미리 불러오기)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pshdev1030.github.io/2022/02/10/React-Image-preload/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;React Image preload!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@sunn/React-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%AF%B8%EB%A6%AC-%EB%A1%9C%EB%93%9C%ED%95%98%EA%B8%B0-Image-Preload-useLayoutEffect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;이미지 미리 로드하기 (Image Preload, useLayoutEffect)&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[정보처리기사 후기]]></title><description><![CDATA[정보처리기사 필기, 실기 시험을 모두 응시한 후 가볍게 남겨놓는 포스트 정보처리기사 정보처리기사는 과기부 주관의 한국산업인력공단에서 시행하는 국가자격증 시험이다. 전반적인 IT…]]></description><link>https://yhuj79.github.io/Certification/240504/</link><guid isPermaLink="false">https://yhuj79.github.io/Certification/240504/</guid><pubDate>Sat, 04 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;정보처리기사 필기, 실기 시험을 모두 응시한 후 가볍게 남겨놓는 포스트&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;정보처리기사&lt;/h2&gt;
&lt;img alt=&apos;c1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240504/c1.png&apos;&gt;
&lt;p&gt;정보처리기사는 과기부 주관의 한국산업인력공단에서 시행하는 국가자격증 시험이다.&lt;/p&gt;
&lt;p&gt;전반적인 IT 프로젝트 업무에 대한 내용이 시험 범위로, 프로젝트의 계획 수립 단계부터 분석, 설계, 구현, 테스트 등 넓은 분야를 얕게 다루게 된다. 이는 공부 범위가 다소 지엽적인 부분으로 이어지기 때문에 이 시험의 단점으로 꼽히기도 한다.&lt;/p&gt;
&lt;p&gt;정보처리기사는 2020년에 개정되면서 이전보다 난이도가 크게 상승했다.&lt;/p&gt;
&lt;img alt=&apos;c2&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240504/c2.png&apos;&gt;
&lt;p&gt;통계를 살펴보면 2020년도 시행된 시험부터 합격률이 급격하게 낮아지는 것을 볼 수 있다. 개정 전은 비교적 적은 시간을 들여도 충분히 취득할 수 있는 자격증이였다면, 현재는 방심하지 말고 꽤나 많은 시간을 들여 준비를 해야 할 필요가 있다.&lt;/p&gt;
&lt;h2&gt;자격증의 필요성&lt;/h2&gt;
&lt;p&gt;신입 취업 준비생의 입장에서 이 자격증에서 느껴지는 필요성에 대해 정리해 보았다.&lt;/p&gt;
&lt;img alt=&apos;c3&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240504/c3.png&apos;&gt;
&lt;p&gt;정보처리기사를 취득하면서 얻을 수 있는 이점 중 하나로 대표적으로 생각되는 것은 컴퓨터공학 배경 지식을 가볍게 습득해 볼 수 있다는 장점이 있다. 일단 이 시험은 범위가 굉장히 넓다. 넓은 범위를 얕게 배우다 보니 본래 관심이 없었던 분야에 대해서도 공부할 수 있었고, 이는 면접 인터뷰 등에도 도움이 될 것이라고 생각된다.&lt;/p&gt;
&lt;p&gt;그리고 국가에서 주관하는 기사 자격증이다 보니 취득한 점에 있어서 공기관 지원 시 가산점 등의 혜택을 받을 수 있다고 한다. 예를 들어 한국전력의 경우 계열별 자격가점으로 최대 2개의 자격증까지 가산점 인정받을 수 있다. (2024년 기준)&lt;/p&gt;
&lt;p&gt;그 이외에는 IT 분야의 경우 통상적으로 자격증의 비중이 적다 보니 큰 메리트가 없다 할 수 있지만, 경력이 없는 취업 준비생에게 정보처리기사로 이력서에 한 줄이라도 적을 수 있다면 충분히 취득할 만한 가치가 있다고 본다.&lt;/p&gt;
&lt;h2&gt;공부법&lt;/h2&gt;
&lt;p&gt;정보처리기사는 1차로 필기 시험, 2차로 실기 시험이 있다. 필기 시험을 합격하면 실기 응시 자격이 주어지고, 실기까지 합격 시 자격증이 취득된다.&lt;/p&gt;
&lt;img alt=&apos;c4&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240504/c4.png&apos;&gt;
&lt;p&gt;필기 시험 공부는 먼저 기본서를 구매해서 개념을 훑어보고, 문제풀이 위주로 진행했다. CBT로 시험이 진행되기 때문에 예상 및 기출문제를 많이 풀어보는 것이 무엇보다도 최우선이다.&lt;/p&gt;
&lt;p&gt;전자문제집 CBT 사이트를 통해 PC 환경에서 편하게 기출문제를 풀어볼 수 있다. 과거 회차 기출문제들을 풀 수 있고 이를 혼합하여 랜덤 모의고사도 가능하다. 틀린 문제들을 따로 모아서 복기할 수도 있기 때문에 여러모로 좋은 사이트이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.comcbt.com&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;전자문제집 CBT&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그리고 실기 또한 문제 풀이도 중요하지만, 필기보다 더 확실한 개념 학습이 중요하다.&lt;/p&gt;
&lt;img alt=&apos;c5&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240504/c5.png&apos;&gt;
&lt;p&gt;필기 시험의 경우 사지선다 시험이다. 하지만 실기의 경우 위처럼 20문제 단답식으로 진행이 되기 때문에 출제 예상 개념들에 대해 확실한 이해가 필요하다. 그러나 시험 범위가 너무 지엽적인 탓에 한계가 있기에, 출제 빈도가 높은 유형 위주로 반복해서 읽어보는 것을 주로 행했던 것 같다.&lt;/p&gt;
&lt;p&gt;실기 시험에서 한 가지 중요한 것은 코딩이다. 코딩 문제의 출제 빈도가 가장 많다. 게다가 개정 이후 시험이 진행될 때마다 코딩 문제가 늘어나는 추세이다. 전공자의 경우 C언어, Java, Python에 대해 자신이 알고 있었던 지식을 잘 입혀서 출제 문제를 여러번 풀어보면 될 것이고, 비전공자의 경우에는 물론 다른 개념 학습도 중요하겠지만, 프로그래밍 언어를 익히는 것에 가장 우선을 두고 코딩 문제를 많이 풀어봐야 할 것이다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gilbut.co.kr/book/view?bookcode=BN003879&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;2024 시나공 정보처리기사 필기 기본서&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gilbut.co.kr/book/view?bookcode=BN003987&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;2024 시나공 정보처리기사 실기 기본서&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.comcbt.com&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;전자문제집 CBT&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[버블, 선택, 삽입 정렬 알고리즘 C, Javascript로 구현하기]]></title><description><![CDATA[…]]></description><link>https://yhuj79.github.io/Algorithm/240322/</link><guid isPermaLink="false">https://yhuj79.github.io/Algorithm/240322/</guid><pubDate>Fri, 22 Mar 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;컴퓨터 과학에서 정렬 알고리즘은 데이터를 효율적으로 정돈하는 핵심적인 작업이다. 이러한 알고리즘은 데이터의 크기와 유형에 관계없이 사용될 수 있으며, 다양한 응용 분야에서 중요한 역할을 맡는다. 버블 정렬, 선택 정렬, 삽입 정렬에 대해 알아보고, 각각 C언어와 Javascript로 나타내어 보았다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;버블 정렬(Bubble Sort)&lt;/h2&gt;
&lt;p&gt;버블 정렬은 주어진 배열, 리스트에서 인접한 두 개의 값을 비교하여 그 크기에 따라 위치를 서로 교환하는 정렬 방식이다. 앞의 값이 뒤의 값보다 클 경우, 서로의 위치를 바꾸는 교환이 발생한다. 배열의 끝까지 비교가 완료되면 다시 처음으로 돌아와 이를 반복한다. 따라서 이 알고리즘은 배열을 한 번 통째로 살펴보면서 가장 큰 원소를 배열의 끝으로 이동시키는 과정을 반복하여 정렬을 수행한다.&lt;/p&gt;
&lt;img alt=&apos;bubble1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240322/bubble1.gif&apos;&gt;
&lt;p&gt;진행 흐름을 나타내 본다면 위 그림과 같을 것이다.&lt;/p&gt;
&lt;p&gt;위의 &lt;code&gt;6, 5, 3, 1, 8, 7, 2, 4&lt;/code&gt; 배열을 버블 정렬하는 코드를 C언어를 통해 작성해 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// C 버블 정렬 코드

#include &amp;#x3C;stdio.h&gt;

void bubbleSort(int arr[], int n)
{
    int i, j;
    for (i = 0; i &amp;#x3C; n - 1; i++)
    {
        // 한 번의 루프에서 가장 큰 수를 맨 끝으로 보내기 위한 루프
        for (j = 0; j &amp;#x3C; n - i - 1; j++)
        {
            // 인접한 원소 비교 후 필요에 따라 교환
            if (arr[j] &gt; arr[j + 1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i &amp;#x3C; size; i++)
        printf(&quot;%d &quot;, arr[i]);
    printf(&quot;\n&quot;);
}

int main()
{
    int arr[] = {6, 5, 3, 1, 8, 7, 2, 4};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf(&quot;Original array: \n&quot;);
    printArray(arr, n);
    bubbleSort(arr, n);
    printf(&quot;Sorted array: \n&quot;);
    printArray(arr, n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;지정된 배열을 버블 정렬 알고리즘을 사용하여 정렬한다. &lt;code&gt;bubbleSort()&lt;/code&gt; 함수는 배열을 받아서 버블 정렬을 수행하고, &lt;code&gt;printArray()&lt;/code&gt; 함수는 배열의 요소를 출력한다. &lt;code&gt;main()&lt;/code&gt; 함수에서는 주어진 배열을 초기화하고 정렬 후 결과를 출력한다.&lt;/p&gt;
&lt;p&gt;Javascript로 작성하는 버블 정렬 코드는 정해진 배열을 주지 않고, 정렬할 데이터의 개수를 입력하고 정렬에 걸리는 시간을 측정하여 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Javascript 버블 정렬 코드

function bubbleSort(arr) {
  var len = arr.length
  var swapped
  do {
    swapped = false
    for (var i = 0; i &amp;#x3C; len - 1; i++) {
      if (arr[i] &gt; arr[i + 1]) {
        var temp = arr[i]
        arr[i] = arr[i + 1]
        arr[i + 1] = temp
        swapped = true
      }
    }
  } while (swapped)
}

// 함수 실행 시간 측정 함수
function measureTimeTaken(callback) {
  var startTime = performance.now()
  callback()
  var endTime = performance.now()
  return (endTime - startTime) / 1000 // 밀리초를 초로 변환
}

// 사용자 입력 및 실행
var readline = require(&quot;readline&quot;)
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

rl.question(&quot;Input : &quot;, function (n) {
  n = parseInt(n)
  var min = 1 // 랜덤 수의 최솟값
  var max = 1000 // 랜덤 수의 최댓값

  // 랜덤 수 생성
  var randomArray = []
  for (var i = 0; i &amp;#x3C; n; i++) {
    randomArray.push(Math.floor(Math.random() * (max - min + 1)) + min)
  }

  // 버블 정렬 실행 및 실행 시간 측정
  var timeTaken = measureTimeTaken(function () {
    bubbleSort(randomArray)
  })

  // 결과 출력
  console.log(&quot;Result : &quot;, timeTaken.toFixed(2), &quot;seconds&quot;)

  rl.close()
})
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;bubble2&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240322/bubble2.png&apos;&gt;
&lt;p&gt;10000, 20000, 40000, 80000으로 입력 개수를 2배씩 증가시켜 보았다. 버블 정렬의 시간 복잡도는 &lt;code&gt;O(N²)&lt;/code&gt;으로, 데이터의 양이 증가함에 따라 실행 시간이 제곱으로 증가한다. 하지만 정확한 제곱을 뜻하는 것은 아니고, 데이터의 크기가 2배로 증가하면 걸리는 시간은 일반적으로 4배가 아닌 4배보다 더 많이 증가한다고 보면 된다. 위의 실행 결과처럼.&lt;/p&gt;
&lt;h2&gt;선택 정렬(Selection Sort)&lt;/h2&gt;
&lt;p&gt;선택 정렬은 n 개의 값 중에서 최소값을 찾아 첫 번째 위치에 놓고, 나머지 n-1 개 중에서 다시 최소값을 찾아 두 번째 위치에 놓는 방식을 반복하여 정렬하는 방식이다.&lt;/p&gt;
&lt;img alt=&apos;selection1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240322/selection1.gif&apos;&gt;
&lt;p&gt;선택 정렬의 동작은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;주어진 배열에서 최솟값(또는 최댓값) 찾기&lt;/li&gt;
&lt;li&gt;최솟값(또는 최댓값)을 배열의 맨 앞 원소와 교환&lt;/li&gt;
&lt;li&gt;위 과정을 반복하여 배열의 정렬이 완료될 때까지 진행&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// C 선택 정렬 코드

#include &amp;#x3C;stdio.h&gt;

void selectionSort(int arr[], int n)
{
    int i, j, min_idx;
    // 배열의 모든 요소에 대해 반복
    for (i = 0; i &amp;#x3C; n - 1; i++)
    {
        // 현재 위치부터 끝까지 가장 작은 요소의 인덱스를 찾음
        min_idx = i;
        for (j = i + 1; j &amp;#x3C; n; j++)
        {
            if (arr[j] &amp;#x3C; arr[min_idx])
                min_idx = j;
        }
        // 현재 위치와 가장 작은 요소의 위치를 교환
        int temp = arr[min_idx];
        arr[min_idx] = arr[i];
        arr[i] = temp;
    }
}

void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i &amp;#x3C; size; i++)
        printf(&quot;%d &quot;, arr[i]);
    printf(&quot;\n&quot;);
}

int main()
{
    int arr[] = {6, 5, 3, 1, 8, 7, 2, 4};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf(&quot;Original array: \n&quot;);
    printArray(arr, n);
    selectionSort(arr, n);
    printf(&quot;Sorted array: \n&quot;);
    printArray(arr, n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Javascript 선택 정렬 코드

function selectionSort(arr) {
  var len = arr.length
  for (var i = 0; i &amp;#x3C; len - 1; i++) {
    var minIndex = i
    // 현재 위치부터 끝까지 가장 작은 요소의 인덱스를 찾음
    for (var j = i + 1; j &amp;#x3C; len; j++) {
      if (arr[j] &amp;#x3C; arr[minIndex]) {
        minIndex = j
      }
    }
    // 현재 위치와 가장 작은 요소의 위치를 교환
    if (minIndex !== i) {
      var temp = arr[i]
      arr[i] = arr[minIndex]
      arr[minIndex] = temp
    }
  }
}

function measureTimeTaken(callback) {
  var startTime = performance.now()
  callback()
  var endTime = performance.now()
  return (endTime - startTime) / 1000
}

var readline = require(&quot;readline&quot;)
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

rl.question(&quot;Input : &quot;, function (n) {
  n = parseInt(n)
  var min = 1
  var max = 1000

  var randomArray = []
  for (var i = 0; i &amp;#x3C; n; i++) {
    randomArray.push(Math.floor(Math.random() * (max - min + 1)) + min)
  }

  // 선택 정렬 실행 및 실행 시간 측정
  var timeTaken = measureTimeTaken(function () {
    selectionSort(randomArray)
  })

  console.log(&quot;Result : &quot;, timeTaken.toFixed(2), &quot;seconds&quot;)

  rl.close()
})
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;selection2&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240322/selection2.png&apos;&gt;
&lt;p&gt;선택 정렬 또한 마찬가지로 버블 정렬과 동일한 &lt;code&gt;O(N²)&lt;/code&gt;의 시간복잡도를 갖는다. 하지만 버블 정렬보다 약 두 배 가량 빠른 것을 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;삽입 정렬(Insertion Sort)&lt;/h2&gt;
&lt;p&gt;삽입 정렬은 가장 간단한 정렬 방식으로, 이미 순서화된 파일에 새로운 하나의 값를 순서에 맞게 삽입시켜 정렬하는 방식이다. 선택 정렬과 함께 인간에게 뭔가를 정렬하라고 하면 무의식적으로 사용하는 대표적인 알고리즘이다.&lt;/p&gt;
&lt;img alt=&apos;insertion1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240322/insertion1.gif&apos;&gt;
&lt;p&gt;삽입 정렬은 배열이 작을 경우 상당히 효율적으로, 일반적으로 빠르다고 알려진 알고리즘이라 할지라도 배열이 작다면 대부분 삽입 정렬이 성능에서 우위를 점한다. 따라서 고성능 알고리즘들 중에서는 배열의 사이즈가 클때는 &lt;code&gt;O(nlogn)&lt;/code&gt; 알고리즘을 쓰다가 정렬해야 할 부분이 작을 때는 삽입 정렬로 전환하는 경우도 있다.&lt;/p&gt;
&lt;p&gt;마찬가지로 C와 Javascript로 구현해 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// C 삽입 정렬 코드

#include &amp;#x3C;stdio.h&gt;

void insertionSort(int arr[], int n) {
    int i, key, j;
    // 배열의 각 요소에 대해 반복
    for (i = 1; i &amp;#x3C; n; i++) {
        key = arr[i];
        j = i - 1;

        // key보다 큰 요소들을 오른쪽으로 이동
        while (j &gt;= 0 &amp;#x26;&amp;#x26; arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

void printArray(int arr[], int size) {
    int i;
    for (i = 0; i &amp;#x3C; size; i++)
        printf(&quot;%d &quot;, arr[i]);
    printf(&quot;\n&quot;);
}

int main() {
    int arr[] = {6, 5, 3, 1, 8, 7, 2, 4};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf(&quot;Original array: \n&quot;);
    printArray(arr, n);
    insertionSort(arr, n);
    printf(&quot;Sorted array: \n&quot;);
    printArray(arr, n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Javascript 삽입 정렬 코드

function insertionSort(arr) {
  var len = arr.length
  for (var i = 1; i &amp;#x3C; len; i++) {
    var key = arr[i]
    var j = i - 1
    // key보다 큰 요소들을 오른쪽으로 이동
    while (j &gt;= 0 &amp;#x26;&amp;#x26; arr[j] &gt; key) {
      arr[j + 1] = arr[j]
      j = j - 1
    }
    arr[j + 1] = key
  }
}

function measureTimeTaken(callback) {
  var startTime = performance.now()
  callback()
  var endTime = performance.now()
  return (endTime - startTime) / 1000
}

var readline = require(&quot;readline&quot;)
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

rl.question(&quot;Input : &quot;, function (n) {
  n = parseInt(n)
  var min = 1
  var max = 1000

  var randomArray = []
  for (var i = 0; i &amp;#x3C; n; i++) {
    randomArray.push(Math.floor(Math.random() * (max - min + 1)) + min)
  }

  // 삽입 정렬 실행 및 실행 시간 측정
  var timeTaken = measureTimeTaken(function () {
    insertionSort(randomArray)
  })

  console.log(&quot;Result : &quot;, timeTaken.toFixed(2), &quot;seconds&quot;)

  rl.close()
})
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;insertion2&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240322/insertion2.png&apos;&gt;
&lt;p&gt;삽입 정렬 또한 &lt;code&gt;O(N²)&lt;/code&gt;의 시간복잡도를 갖는다. 역시 &lt;code&gt;O(N²)&lt;/code&gt;들 중 빠른 편에 속하는 삽입 정렬 답게 포스트에서 다룬 알고리즘들 중 가장 빠른 결과값이 나왔다. 최선의 경우 &lt;code&gt;O(N)&lt;/code&gt;이라는 엄청나게 빠른 효율성을 가지고 있기 때문이다. 하지만 입력 데이터가 역순으로 정렬되어 있다면 결국 최악의 성능이 나온다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.booksr.co.kr/product/%EC%95%8C%EA%B8%B0-%EC%89%AC%EC%9A%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%9C%EC%A0%95%ED%8C%90/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;알기 쉬운 알고리즘 (개정판) | 생능출판사&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gilbut.co.kr/book/view?bookcode=BN003987&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;2024 시나공 정보처리기사 실기 기본서 : 길벗, 이지톡&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://commons.wikimedia.org/wiki/Main_Page&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Wikimedia Commons&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://woongsin94.tistory.com/211&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;정렬 알고리즘&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://levelup.gitconnected.com/sorting-algorithms-selection-sort-bubble-sort-merge-sort-and-quicksort-75479f8f80b1&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Sorting Algorithms | by Sebastian De Lima&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[소프트웨어 설계 주요 내용]]></title><description><![CDATA[정보처리기사 필기 1과목 소프트웨어 설계에 나오는 주요 내용들로, 이 포스트는 해당 파트의 기출 내용 전부를 다루고 있지 않다. 소프트웨어 공학의 개념 소프트웨어 공학(Software Engineering…]]></description><link>https://yhuj79.github.io/Computer Science/240207/</link><guid isPermaLink="false">https://yhuj79.github.io/Computer Science/240207/</guid><pubDate>Wed, 07 Feb 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;정보처리기사 필기 1과목 소프트웨어 설계에 나오는 주요 내용들로, 이 포스트는 해당 파트의 기출 내용 전부를 다루고 있지 않다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;소프트웨어 공학의 개념&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;소프트웨어 공학(Software Engineering)&lt;/strong&gt;은 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문이며 여러 가지 방법론과 도구, 관리 기법들을 통하여 소프트웨어의 품질과 생산성 향상을 목적으로 한다.
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;소프트웨어 공학의 기본 원칙&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;현대적인 프로그래밍 기술을 계속적으로 적용해야 한다.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 한다.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;하향식/상향식 소프트웨어 개발&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;하향식 소프트웨어 개발(Top-Down Software Development)&lt;/strong&gt;은 큰 시스템이나 프로그램을 작성할 때 사용되는 소프트웨어 개발 방법론 중 하나로, 이 방법은 전체 시스템을 세분화하고 각 세부 부분을 순차적으로 설계하고 개발하는 접근법을 갖추고 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;요구사항 분석 (Requirements Analysis): 전체 시스템의 요구사항을 정의하고 이를 세부적으로 나누어 핵심 기능을 식별&lt;/li&gt;
&lt;li&gt;시스템 설계 (System Design): 전체 시스템을 설계하고 각 모듈 간의 인터페이스와 상호 작용을 결정&lt;/li&gt;
&lt;li&gt;모듈 설계 (Module Design): 각 모듈에 대한 상세한 설계를 수행&lt;/li&gt;
&lt;li&gt;코딩 (Coding): 설계한 모듈을 실제 프로그래밍 언어로 구현&lt;/li&gt;
&lt;li&gt;테스트 (Testing): 개발된 각 모듈이나 구성 요소를 개별적으로 테스트하고, 전체 시스템이 예상대로 동작하는지 확인&lt;/li&gt;
&lt;li&gt;통합 (Integration): 각 모듈을 통합하여 전체 시스템을 완성&lt;/li&gt;
&lt;li&gt;유지보수 (Maintenance): 시스템의 안정성 및 성능을 유지하고 필요에 따라 수정하거나 업데이트&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;하향식 소프트웨어 개발은 대규모 프로젝트에서 특히 효과적일 수 있으며, 큰 그림을 먼저 그린 후 세부 사항에 대한 작업을 진행함으로써 전체적인 구조를 미리 계획할 수 있다. 그러나 이 방법론은 프로젝트의 초기에 정확한 요구사항을 수집하고 결정하는 것이 중요하다는 전제를 가지고 있다.
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;상향식 소프트웨어 개발(Bottom-Up Software Development)&lt;/strong&gt;은 소프트웨어를 작성할 때 시스템의 세부 구성 요소부터 시작하여 전체 시스템을 완성해 나가는 방법론이다. 이 방법은 작은 모듈부터 출발하여 이를 조합해 나가는 방식으로 개발이 진행된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;최하위 모듈 설계 (Low-Level Design): 개발자는 시스템의 가장 기본이 되는 모듈들의 설계를 수행&lt;/li&gt;
&lt;li&gt;코딩 (Coding): 최하위 모듈부터 시작하여 모듈을 프로그래밍 언어로 구현&lt;/li&gt;
&lt;li&gt;테스트 (Testing): 각 모듈을 개별적으로 테스트하고 모듈 간 상호 작용이 예상대로 이루어지는지 확인&lt;/li&gt;
&lt;li&gt;통합 (Integration): 개발된 각 모듈을 조합하여 시스템을 완성&lt;/li&gt;
&lt;li&gt;시스템 테스트 (System Testing): 전체 시스템이 예상대로 동작하는지 확인하기 위해 시스템 전체에 대한 테스트를 수행&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;상향식 소프트웨어 개발은 주로 작은 규모의 프로젝트나 중간 규모의 프로토타입 개발에 유용할 수 있다. 이 방법론은 초기에는 구체적인 요구사항을 정확히 수집하기 어려운 상황에서도 점진적으로 개발하면서 요구사항을 조정할 수 있는 유연성을 제공한다.
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Test-Driven Development (테스트 주도 개발)&lt;/h2&gt;
&lt;p&gt;개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지를 정확히 파악한다.
테스트가 지속적으로 진행될 수 있도록자동화된 테스팅 도구(구조, 프레임워크)를 사용한다.
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;DBMS(DataBase Management System)&lt;/h2&gt;
&lt;p&gt;사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고, 데이터베이스를 관리해 주는 소프트웨어이다. DBMS는 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템으로, 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리해 준다.
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;웹 애플리케이션 서버(WAS)&lt;/h2&gt;
&lt;p&gt;정적인 콘텐츠 처리를 하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어이다. 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리를 제공한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ex )&lt;/strong&gt; Tomcat, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;User Interface(사용자 인터페이스)의 구분&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CLI(Command Line Interface)&lt;/strong&gt; : 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GUI(Graphical User Interface)&lt;/strong&gt; : 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NUI(Natural User Interface)&lt;/strong&gt; : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VUI(Voice User Interface)&lt;/strong&gt; : 사람의 음성으로 기기를 조작하는 인터페이스
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OUI(Organic User Interface)&lt;/strong&gt; : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스로, 소프트웨어가 아닌 하드웨어 분야에서 사물 인터넷(Internet of Things), 가상현실(Virtual Reality), 증강현실(Augmented Reality), 혼합현실(Mixed Reality) 등과 함께 대두되고 있다.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;User Interface(사용자 인터페이스) 기본 원칙&lt;/h2&gt;
&lt;p&gt;누구나 쉽게 이해하고 사용할 수 있어야 한다.
사용자의 목적을 정확하고 완벽하게 달성해야 한다.
누구나 쉽게 배우고 익힐 수 있어야 한다.
사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;소프트웨어 아키텍쳐 설계의 기본 원리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;모듈화(Modularity)&lt;/strong&gt; : 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;추상화(Abstraction)&lt;/strong&gt; : 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단계적 분해(Stepwise Refinement)&lt;/strong&gt; : Niklaus Wirth에 의해 제안된 하향식 설계 전략으로, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;정보 은닉(Information Hiding)&lt;/strong&gt; : 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;아키텍쳐 패턴&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;파이프 필터 패턴(Pipe - Filter Pattern)&lt;/strong&gt; : 데이터 스트림 절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴이다. 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이하며, 재배치하여 다양한 파이프라인을 구축하는 것이 가능하다. 파이프 필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 주로 사용된다. 대표적으로 UNIX의 쉘(Shell)이 있다.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;모델 뷰 컨트롤러 패턴(Model - View - Controler Pattern)&lt;/strong&gt; : 서브시스템을 3개의 부분으로 구조화하는 패턴이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모델(Model) : 서브시스템의 핵심 기능과 데이터를 보관&lt;/li&gt;
&lt;li&gt;뷰(View) : 사용자에게 정보를 표시&lt;/li&gt;
&lt;li&gt;컨트롤러(Controler) : 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;클라이언트 서버 패턴(Client-Server Pattern)&lt;/strong&gt; : 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다. 클라이언트 서버 패턴에서 사용자는 클라이언트와만 의사소통을 한다. 즉 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스를 제공한다. 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 한다. 클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적이다.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;마스터 슬레이브 패턴(Master-Slave Patern)&lt;/strong&gt; : 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업을 분할한 후, 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴. 장애 허용 시스템과 병렬 컴퓨팅 시스템에서 주로 활용된다.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;브로커 패턴(Broker Patern)&lt;/strong&gt; : 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결한다. 분산 환경 시스템에서 주로 활용된다.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;피어 투 피어 패턴(Peer-To-Peer Patern)&lt;/strong&gt; : 피어(Peer)를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 버스 패턴(Event-Bus Patern)&lt;/strong&gt; : 소스가 특정 채널에 이벤트 메시지를 발행(Publish)하면, 해당 채널을 구독(Subscribe)한 리스너들이 메시지를 받아 이벤트를 처리하는 방식.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;블랙보드 패턴(Blackboard Patern)&lt;/strong&gt; : 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태로, 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있다. 음성 인식, 차량 식별, 신호 해석 등에 주로 활용된다.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인터프리터 패턴(Interpreter Patern)&lt;/strong&gt; : 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된다.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;객체지향 설계 원칙&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;단일 책임 원칙(SRP, Single Responsibility Principle)&lt;/strong&gt; : 객체는 단 하나의 책임만 가져야 한다는 원칙
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;개방-폐쇄 원칙(OCP, Open-Closed Principle)&lt;/strong&gt; : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;리스코프 치환 원칙(LSP, Liskov Substitution Principle)&lt;/strong&gt; : 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인터페이스 분리 원칙(ISP, Interface Segregation Principle)&lt;/strong&gt; : 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;의존 역전 원칙(DIP, Dependency Inversion Principle)&lt;/strong&gt; : 각 객체들 간의 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;디자인 패턴&lt;/h2&gt;
&lt;p&gt;디자인 패턴은 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다. 디자인 패턴은 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있다. ‘바퀴를 다시 발명하지 마라(Don&apos;t reinvent the wheel)’라는 말과 같이, 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다. GoF의 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성된다.&lt;/p&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;생성 패턴(Creational Pattern)&lt;/strong&gt; : 객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해 준다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ex )&lt;/strong&gt; 추상 팩토리(Abstract Factory), 빌더(Builder), 팩토리 메서드(Factory Method), 프로토타입(Prototype), 싱글톤(Singleton)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;구조 패턴(Structural Pattern)&lt;/strong&gt; : 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴으로, 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ex )&lt;/strong&gt; 어댑터(Adapter), 브리지(Bridge), 컴포지트(Composite)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;행위 패턴(Behavioral Pattern)&lt;/strong&gt; : 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로, 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와준다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ex )&lt;/strong&gt; 책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(Interpreter)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gilbut.co.kr/book/view?bookcode=BN003879&amp;#x26;keyword=%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC&amp;#x26;collection=GB_BOOK&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;책정보, 2024 시나공 정보처리기사 필기 기본서 : 길벗, 이지톡&lt;/a&gt;
&lt;br&gt;&lt;br&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[최적의 여행 경로를 찾기 위한 최근접 이웃 알고리즘 솔루션]]></title><description><![CDATA[여행하는 외판원 문제(TSP : Traveling Salesman Problem)는 모든 도시들을 단 한 번만 방문하고 원래 출발한 도시로 돌아오는 최단 경로를 알아내는 문제이다. 이번 포스트는 다음과 유사한 문제를 최근접 이웃 알고리즘(Nearest…]]></description><link>https://yhuj79.github.io/Algorithm/240117/</link><guid isPermaLink="false">https://yhuj79.github.io/Algorithm/240117/</guid><pubDate>Wed, 17 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;여행하는 외판원 문제(TSP : Traveling Salesman Problem)는 모든 도시들을 단 한 번만 방문하고 원래 출발한 도시로 돌아오는 최단 경로를 알아내는 문제이다. 이번 포스트는 다음과 유사한 문제를 최근접 이웃 알고리즘(Nearest Neighbor Algorithm)을 통해 구현했던 프로젝트에 대해 다루었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;여행하는 외판원 문제&lt;/h2&gt;
&lt;p&gt;어느 외판원이 자신의 사무실에서 출발하여 여러 곳의 방문지를 들려 판매 상담을 진행하려 한다. 모든 업무가 끝나면 사무실로 복귀한다. 일을 빠르게 마치려면 들려야 하는 방문지들을 최대한 효율적으로 빠르게 순회해야 할 것이다. 이것이 바로 &lt;strong&gt;외판원 문제(TSP : Traveling Salesman Problem)&lt;/strong&gt;이다. 이 문제는 최단 경로를 구해야 하는 경우 NP-난해에 속하며, 흔히 계산 복잡도 이론에서 해를 구하기 어려운 문제의 대표적인 예로 많이 다룬다.&lt;/p&gt;
&lt;h2&gt;최근접 이웃 알고리즘&lt;/h2&gt;
&lt;p&gt;외판원 순회의 경우 문제들 중에서도 어려운 편으로, 일반적인 외판원 문제에 대한 다항 시간 근사 알고리즘은 P=NP가 아닌 한 존재하지 않는다는 것이 밝혀져 있다. 표본의 수가 증가함에 따라 경우의 수가 기하급수적으로 늘어나 다항식 시간 내에 풀 수 있는 알고리즘이 없으므로 근사 해를 구하는 것이 일반적이다. 최적에 가까운 해를 구하는 데 사용할 방법 중 하나로 근사 알고리즘을 사용하는 것이 있다. 이러한 알고리즘은 최적에 가깝지만 반드시 최적은 아닌 솔루션을 제공한다. 잘 알려진 근사 알고리즘 중 하나는 &lt;strong&gt;최근접 이웃 알고리즘(Nearest Neighbor Algorithm)&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;이 방법은 탐욕 알고리즘(Greedy algorithm)에 기초한다. 최적해를 구하는 데 사용하는 근사적인 방법으로, 경우의 수를 결정하는 순간마다 최적의 방법을 선택해 나가며 크기가 큰 문제에서 작은 문제로 줄여나가는 하향식 방법으로 진행한다.&lt;/p&gt;
&lt;h2&gt;관광 경로 만들기&lt;/h2&gt;
&lt;img alt=&apos;ui01&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/240117/ui01.png&apos;&gt;
&lt;p&gt;최근접 이웃 알고리즘을 적용해 볼 문제는 다음과 같다. 출발지와 도착지가 되어질 &apos;숙소&apos;가 주어지고, 방문하려 하는 여러 개의 &apos;관광지&apos;가 주어진다. 이를 여행할 최적의 경로로 만들면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// dict 배열 예시
const dict = [
  {
    id: 1, // 숙소
    lat: 48.86836127133744,
    lon: 2.3268056623807514,
  },
  {
    id: 2, // 관광지 1
    lat: 48.85836985229897,
    lon: 2.2944622771397345,
  },
  {
    id: 3, // 관광지 2
    lat: 48.860632246610514,
    lon: 2.3374079634624687,
  },
  ...
];
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const startPoint = dict[0]
const remainingPoints = dict.slice(1)

nearestNeighbor(startPoint, remainingPoints)

function nearestNeighbor(start, points) {
  // 결과 배열 초기화 및 남은 지점 배열 생성
  const result = [start]
  const remainingPoints = [...points]

  while (remainingPoints.length &gt; 0) {
    let nearestIndex = 0
    let nearestDistance = haversineDistance(
      start.lat,
      start.lon,
      remainingPoints[0].lat,
      remainingPoints[0].lon
    )

    // 최근접 지점 찾기
    for (let i = 1; i &amp;#x3C; remainingPoints.length; i++) {
      const distance = haversineDistance(
        start.lat,
        start.lon,
        remainingPoints[i].lat,
        remainingPoints[i].lon
      )
      if (distance &amp;#x3C; nearestDistance) {
        nearestIndex = i
        nearestDistance = distance
      }
    }

    // 최근접 이웃을 다음 출발점으로 설정하고 결과에 추가
    start = remainingPoints[nearestIndex]
    result.push(start)
    remainingPoints.splice(nearestIndex, 1)
  }
  return result
}

// 모든 지점 설정 완료까지 반복
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;start, points 파라미터는 숙소, 관광지의 id 값과 위도, 경도 값을 받는다. startPoint로 배열의 첫 번째 요소를 지정, remainingPoints에 거리를 비교할 나머지 요소들을 지정하고, 최근접 지점을 찾아내는 nearestNeighbor 함수가 startPoint에서 갈 곳을 선택한다. 이를 반복해 나가며 경로를 구성하는 원리이다.&lt;/p&gt;
&lt;h2&gt;Haversine Formula&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Haversine Formula : 경도와 위도가 주어진 두 지점 사이의 대원 거리를 계산
function haversineDistance(lat1, lon1, lat2, lon2) {
  // 지구 반경 상수 (단위: km)
  const earthRadius = 6371

  // 각도를 라디안으로 변환
  const dLat = toRadians(lat2 - lat1)
  const dLon = toRadians(lon2 - lon1)

  // Haversine 공식 계산
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRadians(lat1)) *
      Math.cos(toRadians(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2)

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

  // 대원 거리 계산 및 소수점 둘째 자리까지 반환
  const distance = (earthRadius * c).toFixed(2)

  return distance
}

// 각도를 라디안으로 변환하는 함수
function toRadians(degrees) {
  return (degrees * Math.PI) / 180
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;하버사인 공식(Haversine Formula)&lt;/strong&gt;은 두 지점 사이의 구면적 거리(원형 지구 상에서의 거리)를 구하는 데 사용되는 공식이며 지구의 구면성을 고려하여 위도와 경도를 기준으로 두 지점 사이의 최단 거리를 구할 때 주로 사용된다. 이를 통해 두 지점 간의 거리를 계산하여 최근접 지점을 비교하는 데 사용하였다.&lt;/p&gt;
&lt;p&gt;이 공식은 일반적인 사용에서는 큰 무리는 없을 정도이지만, 실제 지구는 적도 쪽이 좀 더 길쭉한 타원형이기 때문에 완벽히 정확한 값이라고 할 수는 없다. 또한 이러한 방법은 두 좌표의 직선 거리를 구하게 되기 때문에 실제 도로 주행을 했을 때의 길이와 차이가 발생한다. 가급적이면 주행할 거리 간의 비교를 통한 최근접 이웃 연산이 더욱 정확할 것이다. 납득할 수 있는 효율적인 경로를 만들어 볼 수는 있었지만, 보다 더 최적에 가까운 값을 찾기 위해서는 다른 방법을 찾아봐야 할 것이다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%99%B8%ED%8C%90%EC%9B%90_%EB%AC%B8%EC%A0%9C&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;외판원 문제 - 위키백과&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/NP-%EB%82%9C%ED%95%B4&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;NP-난해 - 위키백과&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.devgenius.io/traveling-salesman-problem-nearest-neighbor-algorithm-solution-e78399d0ab0c&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Traveling Salesman Problem: Nearest Neighbor Algorithm Solution&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gwnuysw.github.io/jekyll/update/2018/04/06/algorithm.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;알고리즘 여행하는 외판원 문제 | 意志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kayuse88.github.io/haversine/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;최단거리 구하기, 하버사인 공식(Haversine Formula) | 기술 저장소&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Native 내 위치 정보 얻기 (Geolocation Service)]]></title><description><![CDATA[요즘 앱을 사용하다 보면 위치 권한을 물어보는 경우가 상당히 많다. 사용자 위치 변화에 따라 특정 정보를 제공하거나 위치 정보 자체를 사용하는 무선 콘텐츠 서비스들이 굉장히 다양하다. React Native…]]></description><link>https://yhuj79.github.io/React Native/231018/</link><guid isPermaLink="false">https://yhuj79.github.io/React Native/231018/</guid><pubDate>Wed, 18 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;요즘 앱을 사용하다 보면 위치 권한을 물어보는 경우가 상당히 많다. 사용자 위치 변화에 따라 특정 정보를 제공하거나 위치 정보 자체를 사용하는 무선 콘텐츠 서비스들이 굉장히 다양하다. React Native에서도 사용자의 위치 좌표를 출력받을 수 있는 라이브러리를 간단히 사용해 볼 수 있었는데, 바로 &lt;strong&gt;Geolocation Service&lt;/strong&gt;이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;프로젝트 환경 설정&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;React Native CLI&lt;/code&gt;를 사용, 버전은 &lt;code&gt;0.68.2&lt;/code&gt;로 설정했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 앱 설치
$ react-native init --version 0.68.2 프로젝트명
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;안드로이드 에뮬레이터를 통해 진행했다. 디바이스는 기존에 갤럭시 S21로 세팅되어 있으며, 다음 명령어로 프로젝트를 실행했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ react-native run-android
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;geo1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/231018/geo1.png&apos;&gt;
&lt;p&gt;에뮬레이터가 실행되면 위처럼 설정되어 있던 기본 화면이 나온다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Sample React Native App
 * https://github.com/facebook/react-native
 *
 * @format
 * @flow strict-local
 */

import React from &quot;react&quot;
import type { Node } from &quot;react&quot;
import {
  SafeAreaView,
  ScrollView,
  StatusBar,
  StyleSheet,
  Text,
  useColorScheme,
  View,
} from &quot;react-native&quot;

import {
  Colors,
  DebugInstructions,
  Header,
  LearnMoreLinks,
  ReloadInstructions,
} from &quot;react-native/Libraries/NewAppScreen&quot;

const Section = ({ children, title }): Node =&gt; {
  const isDarkMode = useColorScheme() === &quot;dark&quot;
  return (
    &amp;#x3C;View style={styles.sectionContainer}&gt;
      &amp;#x3C;Text
        style={[
          styles.sectionTitle,
          {
            color: isDarkMode ? Colors.white : Colors.black,
          },
        ]}
      &gt;
        {title}
      &amp;#x3C;/Text&gt;
      &amp;#x3C;Text
        style={[
          styles.sectionDescription,
          {
            color: isDarkMode ? Colors.light : Colors.dark,
          },
        ]}
      &gt;
        {children}
      &amp;#x3C;/Text&gt;
    &amp;#x3C;/View&gt;
  )
}

const App: () =&gt; Node = () =&gt; {
  const isDarkMode = useColorScheme() === &quot;dark&quot;

  const backgroundStyle = {
    backgroundColor: isDarkMode ? Colors.darker : Colors.lighter,
  }

  return (
    &amp;#x3C;SafeAreaView style={backgroundStyle}&gt;
      &amp;#x3C;StatusBar barStyle={isDarkMode ? &quot;light-content&quot; : &quot;dark-content&quot;} /&gt;
      &amp;#x3C;ScrollView
        contentInsetAdjustmentBehavior=&quot;automatic&quot;
        style={backgroundStyle}
      &gt;
        &amp;#x3C;Header /&gt;
        &amp;#x3C;View
          style={{
            backgroundColor: isDarkMode ? Colors.black : Colors.white,
          }}
        &gt;
          &amp;#x3C;Section title=&quot;Step One&quot;&gt;
            Edit &amp;#x3C;Text style={styles.highlight}&gt;App.js&amp;#x3C;/Text&gt; to change this
            screen and then come back to see your edits.
          &amp;#x3C;/Section&gt;
          &amp;#x3C;Section title=&quot;See Your Changes&quot;&gt;
            &amp;#x3C;ReloadInstructions /&gt;
          &amp;#x3C;/Section&gt;
          &amp;#x3C;Section title=&quot;Debug&quot;&gt;
            &amp;#x3C;DebugInstructions /&gt;
          &amp;#x3C;/Section&gt;
          &amp;#x3C;Section title=&quot;Learn More&quot;&gt;
            Read the docs to discover what to do next:
          &amp;#x3C;/Section&gt;
          &amp;#x3C;LearnMoreLinks /&gt;
        &amp;#x3C;/View&gt;
      &amp;#x3C;/ScrollView&gt;
    &amp;#x3C;/SafeAreaView&gt;
  )
}

const styles = StyleSheet.create({
  sectionContainer: {
    marginTop: 32,
    paddingHorizontal: 24,
  },
  sectionTitle: {
    fontSize: 24,
    fontWeight: &quot;600&quot;,
  },
  sectionDescription: {
    marginTop: 8,
    fontSize: 18,
    fontWeight: &quot;400&quot;,
  },
  highlight: {
    fontWeight: &quot;700&quot;,
  },
})

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;기본적으로 생성된 App.js 파일이다. 코드를 다음과 같이 정리해 주었다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React from &quot;react&quot;
import { View, Text, StyleSheet } from &quot;react-native&quot;

const App = () =&gt; {
  return (
    &amp;#x3C;View&gt;
      &amp;#x3C;Text style={styles.title}&gt;Geolocation Tutorial&amp;#x3C;/Text&gt;
    &amp;#x3C;/View&gt;
  )
}

const styles = StyleSheet.create({
  title: {
    textAlign: &quot;center&quot;,
    fontSize: 25,
    margin: 15,
    color: &quot;black&quot;,
    fontWeight: &quot;600&quot;,
  },
})

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&apos;geo2&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/231018/geo2.png&apos; width=&apos;300&apos;&gt;
&lt;h2&gt;Geolocation Service&lt;/h2&gt;
&lt;p&gt;모바일 디바이스의 현재 위치 좌표 값을 얻기 위해서는 &lt;code&gt;Geolocation Service&lt;/code&gt;라는 라이브러리를 사용한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add react-native-geolocation-service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 기능은 위치 정보를 얻는 민감한 기능에 해당하므로 사용자의 동의를 받는 절차를 생성해야 한다. 안드로이드에서 제공하는 권한 부여 방식은 &lt;code&gt;android/app/src/main/AndroidManifest.xml&lt;/code&gt; 에서 다음 코드를 추가하면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;#x3C;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
&amp;#x3C;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 Geolocation Service를 통해 얻은 좌표를 앱에 출력해보자. 먼저 권한 요청을 처리해주는 코드를 작성했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;useEffect(() =&gt; {
  if (Platform.OS === &quot;android&quot;) {
    PermissionsAndroid.request(
      PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION
    )
  }
}, [])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;통상적으로 iOS와 안드로이드를 조건문을 통해 권한 처리를 하게 되는데, 현재 프로젝트는 안드로이드 권한 요청 처리만 해 두기로 하였다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const [currentLocation, setCurrentLocation] = useState(null)

useEffect(() =&gt; {
  // 위치 업데이트 설정
  const watchId = Geolocation.watchPosition(
    (position) =&gt; {
      const { latitude, longitude } = position.coords
      // currentLocation에 위도, 경도 저장
      setCurrentLocation({ latitude, longitude })
    },
    (error) =&gt; {
      console.log(error)
    },
    {
      enableHighAccuracy: true, // 배터리를 더 소모하여 보다 정확한 위치 추적
      timeout: 20000,
      maximumAge: 0, // 한 번 찾은 위치 정보를 해당 초만큼 캐싱
      distanceFilter: 1,
    }
  )

  // 컴포넌트 언마운트 시 위치 업데이트 중지
  return () =&gt; {
    Geolocation.clearWatch(watchId)
  }
}, [])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위치 좌표를 얻는 코드이다. &lt;code&gt;위도(latitude)&lt;/code&gt;와 &lt;code&gt;경도(longitude)&lt;/code&gt; 값을 받아 &lt;code&gt;currentLocation&lt;/code&gt; 변수에 저장하였다. 이를 통해 좌표를 확인해 볼 수 있다.&lt;/p&gt;
&lt;p&gt;전체 코드와 출력 결과를 확인해 보면...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { useEffect, useState } from &quot;react&quot;
import { View, Text, StyleSheet, PermissionsAndroid } from &quot;react-native&quot;
import Geolocation from &quot;react-native-geolocation-service&quot;

const App = () =&gt; {
  const [currentLocation, setCurrentLocation] = useState(null)

  useEffect(() =&gt; {
    if (Platform.OS === &quot;android&quot;) {
      PermissionsAndroid.request(
        PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION
      )
    }
  }, [])

  useEffect(() =&gt; {
    const watchId = Geolocation.watchPosition(
      (position) =&gt; {
        const { latitude, longitude } = position.coords
        setCurrentLocation({ latitude, longitude })
      },
      (error) =&gt; {
        console.log(error)
      },
      {
        enableHighAccuracy: true,
        timeout: 20000,
        maximumAge: 0,
        distanceFilter: 1,
      }
    )

    return () =&gt; {
      Geolocation.clearWatch(watchId)
    }
  }, [])

  return (
    &amp;#x3C;View&gt;
      &amp;#x3C;Text style={styles.title}&gt;Geolocation Tutorial&amp;#x3C;/Text&gt;
      {currentLocation ? (
        &amp;#x3C;Text style={styles.title}&gt;
          {currentLocation.latitude} / {currentLocation.longitude}
        &amp;#x3C;/Text&gt;
      ) : (
        &amp;#x3C;Text style={styles.title}&gt;location undefined&amp;#x3C;/Text&gt;
      )}
    &amp;#x3C;/View&gt;
  )
}

const styles = StyleSheet.create({
  title: {
    textAlign: &quot;center&quot;,
    fontSize: 25,
    margin: 15,
    color: &quot;black&quot;,
    fontWeight: &quot;600&quot;,
  },
})

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img alt=&apos;geo3&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/231018/geo3.png&apos;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img alt=&apos;geo4&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/231018/geo4.png&apos;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;이렇게 위치 정보의 접근하는 메시지가 뜨고, 동의하면 좌표 값이 정상적으로 출력된다.&lt;/p&gt;
&lt;p&gt;그런데 실제 모바일 디바이스에서 실행한 것도 아니고 에뮬레이터에 표시된 &lt;code&gt;37.4219983, -122.084&lt;/code&gt; 라는 좌표는 뭘까? 이 좌표를 한번 구글 맵에 검색해 보았다.&lt;/p&gt;
&lt;img alt=&apos;geo5&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/231018/geo5.png&apos;&gt;
&lt;p&gt;이렇듯 PC 개발 환경에서 위치 정보를 받아 오면 default로 구글 본사의 위치가 표시되는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;APK를 생성하여 모바일 디바이스에서 앱을 실행해 보면 현재 자신이 위치에 있는 좌표 값이 나오는 것을 확인해 볼 수 있을 것이다. APK 생성 방법은 아래 포스트를 참고하였다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ssilook.tistory.com/entry/React-Native-RN-Android-Studio%EB%A1%9C-APK-%EC%B6%94%EC%B6%9C%ED%95%98%EA%B8%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;RN - APK 추출하기 1편(Android Studio로 APK 추출하기)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/react-native-geolocation-service&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;react-native-geolocation-service - npm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@flowersayo/React-NativeExpo%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-GPS-%EC%9C%84%EC%B9%98%EC%B6%94%EC%A0%81-%EB%9F%AC%EB%8B%9D-%ED%8A%B8%EB%9E%98%ED%82%B9-%EC%95%B1-%EB%A7%8C%EB%93%A4%EA%B8%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;React Native(Expo)를 이용한 GPS 위치추적 - 러닝 트래킹 앱 만들기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.scaler.com/topics/react-native-geolocation-service/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;React Native Geolocation Service&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://agilog.tistory.com/2&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;리액트 네이티브 현재 위치 정보 가져오기, Getting current location with a react native geolocation service&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@eunddodi/ReactNative%EB%A1%9C-%EB%9F%AC%EB%8B%9D-%EC%96%B4%ED%94%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0-Geolocation%EC%9C%BC%EB%A1%9C-%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%9F%AC%EB%8B%9D-%ED%8A%B8%EB%9E%98%ED%82%B9%ED%95%98%EA%B8%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;ReactNative로 러닝 어플 만들기 - Geolocation으로 사용자 러닝 트래킹하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ssilook.tistory.com/entry/React-Native-RN-Android-Studio%EB%A1%9C-APK-%EC%B6%94%EC%B6%9C%ED%95%98%EA%B8%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;RN - APK 추출하기 1편(Android Studio로 APK 추출하기)&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Java Basic]]></title><description><![CDATA[자바(Java)는 썬 마이크로시스템즈의 제임스 고슬링(James Gosling)과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다. 1991년 그린 프로젝트(Green Project)라는 이름으로 시작해 199…]]></description><link>https://yhuj79.github.io/Java/230925/</link><guid isPermaLink="false">https://yhuj79.github.io/Java/230925/</guid><pubDate>Mon, 25 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;자바(Java)는 썬 마이크로시스템즈의 제임스 고슬링(James Gosling)과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다. 1991년 그린 프로젝트(Green Project)라는 이름으로 시작해 1995년에 발표했다. 처음에는 가전제품 내에 탑재해 동작하는 프로그램을 위해 개발되었지만 현재 웹 애플리케이션 분야에 가장 많이 사용하는 언어 중 하나이고, 안드로이드를 비롯한 모바일 기기용 소프트웨어 개발에도 널리 사용되고 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;개요&lt;/h2&gt;
&lt;h4&gt;Java 의 역사&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1991년 선마이크로시스템스(오라클에 인수됨)의 제임스 고슬링이 C 언어를 모델로 연구 시작&lt;/li&gt;
&lt;li&gt;1995년 JDK(Java Development Kit) 1.0 발표&lt;/li&gt;
&lt;li&gt;1997년 JDK 1.1이 발표되면서 완전한 프로그래밍 언어의 모습을 갖춤&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Java의 특징&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;구문이 간결함&lt;/li&gt;
&lt;li&gt;명료한 객체지향 언어&lt;/li&gt;
&lt;li&gt;이식성이 높고, 기계에 중립적&lt;/li&gt;
&lt;li&gt;분산처리지원&lt;/li&gt;
&lt;li&gt;멀티스레드(Multi-thread) 언어&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;기본 문법&lt;/h2&gt;
&lt;h4&gt;변수와 데이터 형식&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class example {
    public static void main(String args[]) {
        int var1 = 10;
        float var2 = 10.1f;
        double var3 = 10.2;
        char var4 = &apos;안&apos;;
        String var5 = &quot;안드로이드&quot;;
        System.out.println(var1);
        System.out.println(var2);
        System.out.println(var3);
        System.out.println(var4);
        System.out.println(var5);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt; : 2byte를 사용하며 한글 또는 영문 1개만 입력&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt; : 여러 글자의 문자열을 입력&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;byte&lt;/strong&gt; : 1byte를 사용하며 -128~+127 까지 입력&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;short&lt;/strong&gt; : 2byte를 사용하며 -32768~+32767까지 입력&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; : 4bvte를 사용하며 약 21억~+21억까지 입력&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;long&lt;/strong&gt; : 8byte를 사용하며 상당히 큰 정수까지 입력 가능&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;float&lt;/strong&gt; : 4bvte를 사용하며 실수를 입력&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;double&lt;/strong&gt; : 8byte를 사용하며 실수를 입력. float보다 정밀도가 높음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean&lt;/strong&gt; : true 또는 false를 입력&lt;/p&gt;
&lt;h4&gt;조건문: if, switch()~case&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class example {
    public static void main(String[] args) {

        int count = 85;

        if (count &gt;= 90) {
            System.out.println(&quot;if statement: pass (A)&quot;);
        } else if (count &gt;= 60) {
            System.out.println(&quot;if statement: pass&quot;);
        } else {
            System.out.println(&quot;if statement: fail&quot;);
        }

        int points = (count / 10) * 10;

        switch (points) {
            case 100, 90 -&gt; System.out.println(&quot;switch statement: pass (A)&quot;);
            case 80, 70, 60 -&gt; System.out.println(&quot;switch statement: pass&quot;);
            default -&gt; System.out.println(&quot;switch statement: pass&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;메소드와 전역변수, 지역변수&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;전역변수(global variable) : 모든 메소드에서 사용 가능함&lt;/li&gt;
&lt;li&gt;지역변수(local variable) : 메소드 내부에서만 사용 가능함&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class example {
    static int var = 100;
    public static void main(String[] args) {
        int var = 0;
        System.out.println(var);

        int sum = addFunction(10, 20);
        System.out.println(sum);
    }

    static int addFunction(int num1, int num2) {
        int hap;
        hap = num1 + num2 + var;
        return hap;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;예외 처리: try~catch&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;프로그램 실행 중에 발생하는 오류를 Java는 try~catch문을 통해 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class example {
    static int var = 100;

    public static void main(String[] args) {
        int num1 = 100, num2 = 0;

        try {
            System.out.println(num1 / num2);
        } catch (java.lang.ArithmeticException e) {
            System.out.println(&quot;Divide by Zero&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;클래스와 인스턴스&lt;/h2&gt;
&lt;h4&gt;클래스 정의와 인스턴스 생성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;객체지향 프로그래밍(Object-Oriented Programming, OOP)&lt;/li&gt;
&lt;li&gt;Java, C++, C# 등에서 사 용되는 프로그래밍 기술&lt;/li&gt;
&lt;li&gt;클래스(class) = 변수(필드) + 메소드&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Car {
    String color;
    int speed = 0;

    int getSpeed() {
        return speed;
    }

    void upSpeed(int value) {
        if (speed + value &gt;= 200)
            speed = 200;
        else
            speed = speed + value;
    }

    void downSpeed(int value) {
        if (speed - value &amp;#x3C;= 0)
            speed = 0;
        else
            speed = speed - value;
    }

    String getColor() {
        return color;
    }
}

public class example {
    public static void main(String[] args) {

        Car myCar1 = new Car();
        myCar1.color = &quot;red&quot;;
        myCar1.speed = 0;

        Car myCar2 = new Car();
        myCar2.color = &quot;blue&quot;;
        myCar2.speed = 0;

        Car myCar3 = new Car();
        myCar3.color = &quot;green&quot;;
        myCar3.speed = 0;

        myCar1.upSpeed(50);
        System.out.println(&quot;The color of myCar1 is &quot; + myCar1.getColor() + &quot;, velocity is &quot; + myCar1.getSpeed() + &quot; km.&quot;);

        myCar2.downSpeed(20);
        System.out.println(&quot;The color of myCar2 is &quot; + myCar2.getColor() + &quot;, velocity is &quot; + myCar2.getSpeed() + &quot; km.&quot;);

        myCar3.upSpeed(250);
        System.out.println(&quot;The color of myCar3 is &quot; + myCar3.getColor() + &quot;, velocity is &quot; + myCar3.getSpeed() + &quot; km.&quot;);s

        myCar3.downSpeed(20);
        System.out.println(&quot;The color of myCar3 is &quot; + myCar3.getColor() + &quot;, velocity is &quot; + myCar3.getSpeed() + &quot; km.&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;생성자로 인스턴스 만들기&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Car {
    String color;
    int speed
    Car(String color, int speed) {
        this.color = color;
        this.speed = speed;
    }

    ...

public class example {
    public static void main(String[] args) {
        Car myCar1 = new Car(&quot;red&quot;, 0);
        Car myCar2 = new Car(&quot;blue&quot;, 0);
        Car myCar3 = new Car(&quot;green&quot;, 0);

    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;메소드 오버로딩&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;클래스 내에서 메소드의 이름이 같아도 파라미터의 개수나 데이터형만 다르면 여러 개 선언 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Car {
    String color;
    int speed;

    Car(String color, int speed) {
        this.color = color;
        this.speed = speed;
    }

    Car(int speed) {
        this.speed = speed;
    }

    Car() {
    }

    void upSpeed(double value) {
        if (speed &gt;= 200)
            speed = 200;
        else
            speed = speed + (int) value;
    }

    int getSpeed() {
        return speed;
    }

    void upSpeed(int value) {
        if (speed &gt;= 200)
            speed = 200;
        else
            speed = speed + value;
    }

    void downSpeed(int value) {
        if (speed &amp;#x3C;= 0)
            speed = 0;
        else
            speed = speed - value;
    }

    String getColor() {
        return color;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;정적 필드, 정적 메소드, 상수 필드&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;정적 필드(static field) : 클래스 자체에서 사용되는 변수&lt;/li&gt;
&lt;li&gt;정적 메소드(static method) : 메소드 앞에 static 붙여 사용. 인스턴스 없이 ‘클래스명.메소드명()’으로 호출해서 사용&lt;/li&gt;
&lt;li&gt;상수 필드 : 정적 필드에 초기값을 입력하고 final을 앞에 붙임&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Car {
    String color;
    int speed;
    static int carCount = 0;
    final static int MAXSPEED = 200;
    final static int MINSPEED = 0;

    static int currentCarCount() {
        return carCount;
    }

    Car(String color, int speed) {
        this.color = color;
        this.speed = speed; carCount++;
    }
    Car(int speed) {
        this.speed = speed;
    }
    Car() {
    }

    void upSpeed(double value) {
        if (speed &gt;= 200)
            speed = 200;
        else
            speed = speed + (int) value;
    }
    int getSpeed() {
        return speed;
    }
    void upSpeed(int value) {
        if (speed &gt;= 200)
            speed = 200;
        else
            speed = speed + value;
    }
    void downSpeed(int value) {
        if (speed &amp;#x3C;= 0)
            speed = 0;
        else
            speed = speed - value;
    }
    String getColor() {
        return color;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정적 구성 요소 추가&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class example {
    public static void main(String[] args) {
        Car myCar1 = new Car(&quot;red&quot;, 0);
        Car myCar2 = new Car(&quot;blue&quot;, 0);
        Car myCar3 = new Car(&quot;green&quot;, 0);

        System.out.println(&quot;The number of car produced (static field) ==&gt; &quot; + Car.carCount);
        System.out.println(&quot;The number of car produced (static method) ==&gt; &quot; + Car.currentCarCount());
        System.out.println(&quot;The upper limit of velocity ==&gt; &quot; + Car.MAXSPEED);
        System.out.println(&quot;The value of PI ==&gt; &quot; + Math.PI);
        System.out.println(&quot;3 to the 5th power ==&gt; &quot; + Math.pow(3, 5));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_(programming_language)&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Java (programming language)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B7099909363&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;IT CookBook, Android Studio를 활용한 안드로이드 프로그래밍(8판)&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[운영체제 프로세스와 쓰레드]]></title><description><![CDATA[What is an operating system? 운영체제(Operating System…]]></description><link>https://yhuj79.github.io/Computer Science/230628/</link><guid isPermaLink="false">https://yhuj79.github.io/Computer Science/230628/</guid><pubDate>Wed, 28 Jun 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;What is an operating system?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;운영체제(Operating System)는 사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어이다. 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층 즉, 중개자 역할을 해준다.&lt;/p&gt;
&lt;p&gt;이 글은 운영체제 프로세스, 쓰레드와 관련된 개념, 용어를 기록해 두기 위해 작성하였다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;프로그램 &amp;#x26; 프로세스&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;프로그램(Program)&lt;/strong&gt; : 컴퓨터를 실행시키기 위한 일련의 순차적으로 작성된 명령어의 모음. 정적인 개념으로, 실행 파일을 의미&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로세스(Process)&lt;/strong&gt; : 실행되고 있는 프로그램의 작업 단위, 프로그램 실행의 주체, 인스턴스. 프로그램의 명령어 및 데이터가 메모리에 적재되면 그것이 프로세스이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로시저(Procedure)&lt;/strong&gt; : 어떤 행동을 수행하기 위한 일련의 작업 순서를 의미. 루틴, 서브루틴, 함수와 같은 뜻으로 사용되며 하나의 프로시저는 특정 작업을 수행하기 위한 프로그램의 일부이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;시스템 호출(System Calls)&lt;/strong&gt; : 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스. 보통 C나 C++과 같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;스풀(Spooling)&lt;/strong&gt; : 주변장치의 느린 속도로 인하여 발생하는 대기시간을 줄이기 위해 디스크 공간의 일정 부분을 활용해서 데이터를 저장하는 기술&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;버퍼링(Buffering)&lt;/strong&gt; : 버퍼(Buffer) 메모리 영역에 사용 예정 데이터를 임시로 저장하여 처리속도 차이를 완화하기 위한 기술&lt;/p&gt;
&lt;h2&gt;프로그램의 실행 구조&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;다음에 실행할 명령어를 주기억 장치로 부터 읽어들인다. (Fetch)&lt;/li&gt;
&lt;li&gt;명령어를 디코드(해석) 한다. (Decode)&lt;/li&gt;
&lt;li&gt;피연산자 Operand를 주기억 장치로 부터 읽어온다. (Operand)&lt;/li&gt;
&lt;li&gt;명령어를 실행한다. (Execute)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;프로세스 주소 공간&lt;/h2&gt;
&lt;img alt=&apos;addressspace&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230628/addressspace.png&apos; width=&apos;300&apos;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.

Stack 영역의 값은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.

메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.

재귀 함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 stack overflow 에러가 발생한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Heap&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;런타임에 크기가 결정되는 영역이다.

사용자에 의해 공간이 동적으로 할당 및 해제된다.

주로 참조형 데이터 (ex. 클래스) 등의 데이터가 할당된다.

메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Static Data Segment&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;전역 변수나 Static 변수 등 프로그램이 사용할 수 있는 데이터를 저장하는 영역이다.&lt;/p&gt;
&lt;p&gt;어떤 프로그램에 전역/static 변수를 참조하는 코드가 존재한다면, 이 프로그램은 컴파일 된 후에 data 영역을 참조하게 된다.&lt;/p&gt;
&lt;p&gt;프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.&lt;/p&gt;
&lt;p&gt;단, 초기화 되지 않은 변수가 존재한다면, 이는 (그림에는 표현되지는 않았지만 BSS 영역에 저장된다.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Code Segment&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간으로, 프로그램이 수정되면 안 되므로 ReadOnly 상태로 저장 되어있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;프로세스 상태&lt;/h2&gt;
&lt;img alt=&apos;state&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230628/state.png&apos;&gt;
&lt;p&gt;&lt;strong&gt;New&lt;/strong&gt; : 프로세스가 막 생성된 상태&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ready&lt;/strong&gt; : 프로세스가 CPU에 실행되기 위해 대기하는 상태&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Running&lt;/strong&gt; : 프로세스에 포함된 명령어가 실행되고 있는 상태&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Waiting&lt;/strong&gt; : 프로세스가 특정 자원이나 이벤트를 기다리는 상태&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Terminated&lt;/strong&gt; : 프로세스가 실행을 완료한 상태&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PCB(Process Control Block)&lt;/strong&gt; : 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는 구조체. 상태 관리와 Context Switching을 위해서 필요&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;문맥 전환(Context Switch)&lt;/strong&gt; : CPU의 사용 권한을 한 프로세스에서 다른 프로세스에게 넘기는 과정&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dispatch&lt;/strong&gt; : 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Timeout(Interrupt)&lt;/strong&gt; : 주어진 타임 슬라이스 동안 수행 완료되지 않은 프로세스가 준비 상태로 돌아가는 것&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Event Wait(running -&gt; waiting)&lt;/strong&gt; : I/O 입출력 발생 (CPU 사용 중 I/O 행위가 필요하며 대기 상태로 이동)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wake-Up(waiting -&gt;ready)&lt;/strong&gt; : I/O 요청이 완료되면 다시 ready 상태로 전이&lt;/p&gt;
&lt;h2&gt;쓰레드&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;쓰레드(Thread)&lt;/strong&gt; : 프로세스 내에서 실행되는 흐름의 단위 혹은 CPU 스케줄링의 기본 단위. 프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하지만 쓰레드는 다른 쓰레드와 공간과 자원을 공유하면서 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;사용자 스레드(User Thread)&lt;/strong&gt; : 커널의 지원/인식 없이 사용자 공간에서 실행되며 Pthread, Java 등의 라이브러리를 통해 제공된다. 커널의 관여없이 스레드 생성, 스케줄링, 관리를 수행한다. 스레드의 멈춤은 프로세스 자체의 blocking을 유발한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;커널 스레드(Kernel Thread)&lt;/strong&gt; : 커널이 스레드를 인식하고 프로세스와 유사하게 스케줄링한다. Windows, Linux, macOS 등 대부분의 운영체제가 지원하고 있다. 각 커널 스레드는 CPU 스케줄링을 통해 병렬적으로 실행된다.&lt;/p&gt;
&lt;h2&gt;동시성(Concurrency)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;동기화(Synchronization)&lt;/strong&gt; : 시스템을 동시에 작동시키기 위해 작업들 사이의 수행 시기를 조절하여 사건이 동시에 일어나거나, 일정한간격을 두고 일어날 수 있도록 한다. 스레드의 경우 멀티 스레드 환경에서 스레드들의 수행시점을 조절한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;경쟁 상태(race condition)&lt;/strong&gt; : 공유 자원에 대해 여러 개의 프로세스(또는 스레드)가 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;임계 구역(Critical Section)&lt;/strong&gt; : 프로세스 간의 공유 자원을 접근하는 데 있어서 문제가 발생하지 않도록 한 번에 하나의 프로세스만 이용하며 다른 프로세스들의 접근을 제한하는 영역&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;상호배제(Mutual Exclusion)&lt;/strong&gt; : 임계 구역을 어느 시점에서 단지 한 개의 프로세스만이 사용할 수 있도록 하며, 다른 프로세스가 현재 사용 중인 임계 구역에 대하여 접근하려고 할 때 이를 금지하는 행위&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;한정된 대기(Bounded Waiting)&lt;/strong&gt; : 다른 프로세스의 기아(Starvation)를 막기 위해 한번 임계 구역에 들어간 프로세스는 다음번 임계 구역 접근에 제한이 생겨야 한다. 프로세스의 임계 영역 진입은 유한한 시간 내에 허용되어야 함.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spinlock&lt;/strong&gt; : 특정한 자원을 획득(Lock) 또는 해제(Unlock)를 통해 공유 자원에 대한 접근 권한을 관리하는 방법&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mutex(MUTual EXclusion)&lt;/strong&gt; : 획득(Lock) 또는 해제(Unlock) 상태가 있으며 스핀락과 같이 접근 권한을 획득할 때까지 Busy Waiting 상태에 머무르지 않고 Sleep 상태로 들어가며 Wakeup 되면 권한을 획득하는 방법. Locking 메커니즘으로 오직 하나의 스레드만이 동일 시점에 뮤텍스를 얻어 임계 구역(Critical Section)에 접근할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Semaphore&lt;/strong&gt; : 하나 이상의 스레드가 공유자원에 접근, 표현형은 정수로 표현하며 Lock, Unlock가 아닌 값을 올리고 내리는 방식으로 사용한다. 특정 자원에 접근할 때 semWait이 먼저 호출되어 임계 구역에 들어갈 수 있는지 확인 후 조건에 만족한다면 semWait을 빠져나와 임계 구역에 들어가게 되고 이후 semSignal이 호출되어 임계 구역을 빠져나오게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Counting Semaphore&lt;/strong&gt; : 구조체로 사용되며, 0 ~N 사이의 세마포어 변수로 사용된다. 임계구역에 한 번에 여러 프로세스/스레드가 접근할 수 있게 하여 상호배제(Mutual Exclusion) 가 보장되지 않지만, 한정대기(Bounded Waiting)는 보장된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Binary Semaphore&lt;/strong&gt; : Int 변수로 사용되며, 0 과 1 두 가지 값만 가능하다. 0, 1을 사용해서 임계구역에 프로세스/쓰레드가 하나씩만 접근할 수 있게 해준다. 상호배제(Mutual Exclusion)가 보장되지만 프로세스/스레드가 임계구역에 머물 수 있는 시간은 정해져 있지 않기 때문에, 한정 대기(Bounded Waiting)는 보장되지 않는다. 따라서 기아 현상을 초래할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;교착상태(Deadlock)&lt;/strong&gt; : 동시에 실행되어 각각 wait상태로 다른 쪽에서 signal을 해주기 전까지 기다리게 되는 상태&lt;/p&gt;
&lt;h2&gt;스케줄링&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;스케줄링(Scheduling)&lt;/strong&gt; : 프로세스가 생성되어 실행될때 필요한 시스템의 여러자원을 해당 프로세스에게 할당하는 작업으로, 적절히 분배하면 CPU의 활용을 극대화하고, 프로세스 처리율(시간 당 작업량)을 늘릴 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First-come first-served(FCFS)&lt;/strong&gt; : 먼저 실행한 애플리케이션을 먼저 배정. 스케줄링이 직관적이고, 지속적으로 유용한 프로세스를 수행하여 처리율이 높다. 소요시간이 짧거나 중요한 작업이더라도 늦게 기다렸다가 실행되어야 하는 불상사가 생긴다. 다른 계획 없이 대기 큐에 차례대로 받으므로 평균반환시간이 굉장히 길다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shortest job first(SJF)&lt;/strong&gt; : 가장 빨리 끝날 수 있는 애플리케이션부터 배정. 항상 짧은 작업을 먼저 처리하여 평균 대기시간이 가장 짧다. 수행시간이 긴 작업은 짧은 작업에 밀려 기아가 발생, 실행 시간을 예측할 수 없어 실용적이지 못함. 짧은 작업이 먼저 실행되므로 공정하지 못한 정책으로 볼 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Round Robin scheduling(RR)&lt;/strong&gt; : 처음 요청에 먼저 배정, 만약 일정 시간 내에 종료하지 않으면 운영체제가 강제로 실행을 중단시키고 Ready Queue로 돌려보낸다. 시간 할당량이 너무 크면 FCFS 스케줄링과 다를 바가 없고, 너무 작으면 문맥 교환에 잦아져 작업 수행 방해, 오버헤드가 크게 증가하기 때문에 Time Quantum을 어떻게 정해야 할지가 난감한 방법이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Priority Scheduling&lt;/strong&gt; : 우선 순위가 가장 높은 프로세스를 우선적으로 배정하는 방법. 우선 순위가 낮은 프로세스의 기아 상태를 해결하려면 초기에는 우선 순위가 낮더라도 시간이 갈수록 우선순위 레벨을 올려주는 방식을 적용하면 된다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://cocoon1787.tistory.com/685&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;운영체제란? (운영체제의 역할, 목적, 종류, 기능)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jokerkwu.tistory.com/119&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;OS 용어 정리 &amp;#x26; 프로세스&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@klm03025/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;프로세스 주소 공간&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/System_call&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;System call - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gamedevlog.tistory.com/79&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;동기화(Synchronization)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cocoon1787.tistory.com/541&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;OS 스핀락(Spinlock), 뮤텍스(Mutex), 세마포어(Semaphore)의 특징과 차이점&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@junbangg/Mutex-vs-Lock-Counting-Semaphore-vs-Binary-Semaphore-Semaphore-vs-Mutex&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Mutex vs Lock / Counting Semaphore vs Binary Semaphore / Semaphore vs Mutex&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[입문자를 위한 React 기초]]></title><description><![CDATA[레포트 제출 용도로 작성했던 React Tutorial입니다. 이 글은 웹개발 및 React 입문자를 대상으로 작성되었습니다. 설치 및 실행, 기본 구조, 컴포넌트 및 Props 등에 대해 기초적인 부분만 다룹니다. Phase 1. React…]]></description><link>https://yhuj79.github.io/React/230429/</link><guid isPermaLink="false">https://yhuj79.github.io/React/230429/</guid><pubDate>Sat, 29 Apr 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;레포트 제출 용도로 작성했던 React Tutorial입니다. 이 글은 웹개발 및 React 입문자를 대상으로 작성되었습니다. 설치 및 실행, 기본 구조, 컴포넌트 및 Props 등에 대해 기초적인 부분만 다룹니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Phase 1. React란?&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt;는 Facebook에서 개발한 &lt;strong&gt;Javascript 기반 오픈 소스 라이브러리&lt;/strong&gt;입니다. 최근 들어 웹개발 시장에서 Javascript가 지배적인 가운데, React는 Angular, Vue 등과 함께 제일 인기있는 프레임워크로 꼽힙니다. &lt;strong&gt;싱글 페이지 어플리케이션&lt;/strong&gt;이라 불리는 React는 한 개의 Html을 사용하는데, 다른 페이지를 띄우고 싶을 경우 그 부분에 한해서만 내용을 교체하여 사용자에게 보여줍니다. 이러한 원리에 대해 먼저 간단하게 설명하겠습니다.&lt;/p&gt;
&lt;h3&gt;Virtual DOM&lt;/h3&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/dom.png&quot; alt=&quot;dom&quot; width=&quot;400&quot;&gt;
&lt;p&gt;&lt;strong&gt;DOM&lt;/strong&gt;은 Html 문서 구조를 트리 형태의 객체로 표현한 것으로, 웹 브라우저는 DOM을 활용하여 객체에 Css나 Javascript를 적용하게 됩니다. DOM은 동적으로 여러 페이지를 오가게 될 경우 단점이 드러납니다. 페이지가 변화할 때마다 DOM 연산을 계속 반복해야 하는 것입니다. 이는 큰 에너지가 들어가는 작업은 아니지만 페이지 렌더링이 누적되면 될 수록 무시할 수 없는 수치입니다. 이러한 DOM 생성을 최소한으로 만들기 위해 &lt;strong&gt;Virtual DOM&lt;/strong&gt;이 등장했습니다.&lt;/p&gt;
&lt;p&gt;이름에서 알 수 있듯이 &lt;strong&gt;Virtual DOM은 DOM의 추상화 버전&lt;/strong&gt;입니다. React는 &lt;strong&gt;가상 DOM을 생성하여 기존 DOM에서 앞으로 렌더링 해야할 부분의 DOM만 변경&lt;/strong&gt;하는 과정을 거칩니다. 이러한 작업을 수행함으로써 불필요한 연산이 대폭 감소됨은 물론, 사용자에게 기존의 DOM 연산 방식보다 훨씬 쾌적한 경험을 제공할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;Component&lt;/h3&gt;
&lt;p&gt;컴포넌트의 상태값이 변경됨에 따라 새로운 가상 DOM 객체를 만들고, 이전 DOM 객체와 비교하여 UI를 업데이트합니다. React의 꽃이라 할 수 있는 &lt;strong&gt;컴포넌트(Component)&lt;/strong&gt;는 &lt;strong&gt;데이터(props)를 입력받아 상태값에 따라 DOM을 출력&lt;/strong&gt;합니다. 좀 더 간단하게 이야기하면 React는 여러 컴포넌트 덩어리로 이루어져 있고, 이 컴포넌트들이 특정 상태에 따라 반응하며 페이지 내용의 교체가 일어납니다. 페이지 변경 과정에서 변동 사항이 없는 컴포넌트는 그대로 유지됩니다.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/htmlstructure.png&quot; alt=&quot;htmlstructure&quot; width=&quot;300&quot;&gt;
&lt;p&gt;위 사진은 Html 시멘틱 태그 구조입니다. 여기서는 1~6번이 각각 컴포넌트라 생각해 봅시다. 보통 React 프로젝트를 위의 구조처럼 설계하면 Header.js, Nav.js, Section.js ... 와 같은 개별 컴포넌트 파일로 작성합니다. 컴포넌트는 기본적으로 다음과 같은 형태를 띠게 됩니다.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/component.png&quot; alt=&quot;component&quot; width=&quot;400&quot;&gt;
&lt;p&gt;만약 사용자가 Section 1번 페이지를 보던 중 Section 2번으로 넘어가고 싶을 경우, Header, Footer 등의 요소는 변경될 필요가 없습니다. 기존의 DOM에서는 Section 2번 페이지로 넘어가기 위해 모든 DOM을 렌더링해야 했지만, React에서는 그렇지 않아도 됩니다. Section.js만 교체가 일어나고 Header.js, Footer.js 등의 컴포넌트는 유지되는 것입니다.&lt;/p&gt;
&lt;h1&gt;Phase 2. React 설치&lt;/h1&gt;
&lt;p&gt;React를 설치하기 위해서는 &lt;strong&gt;Node.js&lt;/strong&gt;가 설치되어 있어야 합니다. Node.js는 &lt;strong&gt;V8 엔진으로 빌드된 Javascript 런타임으로, 확장성 있는 어플리케이션 개발을 위해 고안된 플랫폼&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en&quot; target=&quot;_blank&quot;&gt;Node.js 설치가 필요하면 여기를 눌러 설치해주세요.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;설치가 완료되었으면 CLI에서 &lt;code&gt;node -v&lt;/code&gt;, &lt;code&gt;npm -v&lt;/code&gt; 명령어를 통해 설치가 잘 되었는지 확인합니다.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/nodev.png&quot; alt=&quot;nodev&quot; width=&quot;400&quot;&gt;
&lt;p&gt;이제 두 가지 방법이 있습니다. &lt;strong&gt;Create React App을 설치하고 그 명령어를 통해 React를 생성&lt;/strong&gt;하거나, &lt;strong&gt;NPX(Node Package eXcute)를 통해 최신 버전의 React를 바로 설치&lt;/strong&gt;할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;🔹 npm install -g create-react-app / create-react-app 프로젝트명&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;NPM(Node Package Manager)를 통해 Create React App을 설치
설치 후 create-react-app 프로젝트명을 통해 React App 생성
React 생성 시 추가 다운로드가 필요 없으나, 최신 버전이 나올 경우 재설치가 필요
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;🔹 npx create-react-app 프로젝트명&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;NPX(Node Package eXcute)를 통해 React App 생성
항상 최신 버전의 React를 생성 할 수 있지만, 매번 다운로드 시간이 필요
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;npx create-react-app 프로젝트명&lt;/code&gt;으로 한번 설치해보도록 하겠습니다.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactinstall1.png&quot; alt=&quot;reactinstall1&quot; width=&quot;600&quot;&gt;
&lt;p&gt;설치 디렉터리에서 &lt;code&gt;npm start&lt;/code&gt;를 통해 앱을 실행할 수 있습니다. (yarn을 사용해도 상관없습니다.)&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactinstall2.png&quot; alt=&quot;reactinstall2&quot; width=&quot;600&quot;&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td width=&quot;47%&quot;&gt;
        &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactinstall3.png&quot; alt=&quot;reactinstall3&quot;/&gt;
    &lt;/td&gt;
    &lt;td width=&quot;40%&quot;&gt;
        &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactinstall4.png&quot; alt=&quot;reactinstall4&quot;/&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;h1&gt;Phase 3. React의 구조&lt;/h1&gt;
&lt;p&gt;앞서 npm start를 통해 React 앱이 &lt;code&gt;http://localhost:3000&lt;/code&gt;에서 실행되었습니다.&lt;/p&gt;
&lt;p&gt;어떻게 웹 페이지가 실행되었는지 React의 구조에 대해 살펴보겠습니다.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactstructure.png&quot; alt=&quot;reactstructure&quot; width=&quot;200&quot;&gt;
&lt;h3&gt;1) node_modules&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;설치된 모듈들이 위치하는 디렉터리&lt;/strong&gt;입니다. React는 인기가 굉장히 많기 때문에 수많은 외부 라이브러리가 존재합니다. input, 캘린더, 날씨 위젯 등부터 퍼블리싱을 위한 UI 템플릿, 상태 관리 라이브러리 등 무수히 많습니다. 이러한 라이브러리를 설치하면 node_modules에 내장되게 됩니다.&lt;/p&gt;
&lt;p&gt;라이브러리와 관련해서 &lt;strong&gt;package.json&lt;/strong&gt; 또한 약간의 이해가 필요합니다. 프로젝트 폴더 루트(/)에 위치해 있습니다.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactpackagejson.png&quot; alt=&quot;reactpackagejson&quot; width=&quot;300&quot;&gt;
&lt;p&gt;라이브러리 모듈이 node_modules에 설치되면 package.json의 &lt;strong&gt;dependencies&lt;/strong&gt;에 명시가 됩니다. &lt;strong&gt;외부 라이브러리의 의존성(dependency) 관리를 위한 명세&lt;/strong&gt;를 한 것입니다. 이는 오픈 소스 패키지 생태계를 위해 수많은 라이브러리의 버전과 종류를 정리하기 위한 목적입니다. 또한 불상사로 인해 프로젝트 파일이 손상되었을 경우 package.json에 명시된 패키지를 install하여 라이브러리를 복구할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;2) public&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;favicon.ico&lt;/strong&gt; : 웹 브라우저의 주소창에 표시되는 페이지를 대표하는 아이콘입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;manifest.json&lt;/strong&gt; : 앱에 대한 정보가 포함된 json 파일입니다. 배경 및 테마 색상, 프로젝트명, favicon 정보 등을 담고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt; : 가상 DOM을 위한 html 파일입니다. 아래에서 설명할 index.js에 대응됩니다. 따라서, 웹의 메인 페이지가 public 디렉터리에 포함되어 있는 구조입니다.&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td width=&quot;70%&quot;&gt;
        &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactroot.png&quot; alt=&quot;reactroot&quot;&gt;
    &lt;/td&gt;
    &lt;td width=&quot;28.2%&quot;&gt;
        &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactindexhtml.png&quot; alt=&quot;reactindexhtml&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;위 사진을 보면 개발자 도구에서 확인한 root div와 index.html 파일이 어딘가 닮아있음을 알 수 있습니다.&lt;/p&gt;
&lt;h3&gt;3) src&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;index.js&lt;/strong&gt; : 메인 파일이라고 할 수 있습니다. Html Templete, Javascript Component를 렌더링합니다. App.js를 포함합니다.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactindexjs.png&quot; alt=&quot;reactindexjs&quot; width=&quot;500&quot;&gt;
&lt;p&gt;&lt;strong&gt;index.css&lt;/strong&gt; : 전체 앱의 전역 스타일을 지정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;App.js&lt;/strong&gt; : 컴포넌트를 정의한 jsx 형태의 파일입니다. 실제로 화면 상에 출력할 내용을 이 파일에서 편집합니다. 다음 챕터에서 본격적으로 다루도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;App.css&lt;/strong&gt; : App.js의 Css 파일입니다.&lt;/p&gt;
&lt;h1&gt;Phase 4. 컴포넌트와 Props&lt;/h1&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactappjs.png&quot; alt=&quot;reactappjs&quot; width=&quot;500&quot;&gt;
&lt;p&gt;App.js는 &lt;strong&gt;JSX&lt;/strong&gt; 형식으로 이루어져 있습니다. React에서 UI를 구성할 때 사용하는 구문인 JSX는 기본적으로 return 문안에 html의 형태를 갖추고 있으며, Javascript의 모든 기능을 사용할 수 있습니다. 엄청 다양하지만, 기본적인 기능 몇개만 다뤄보겠습니다.&lt;/p&gt;
&lt;h3&gt;1. 컴포넌트 활용&lt;/h3&gt;
&lt;p&gt;먼저 변수 &lt;code&gt;num&lt;/code&gt;을 지정하고 화면에 출력시켜 보겠습니다.&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactvar1.png&quot; alt=&quot;reactvar1&quot; width=&quot;500&quot;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactvar2.png&quot; alt=&quot;reactvar2&quot; width=&quot;500&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;let num = 30;&lt;/code&gt;으로 선언 및 정의한 변수를 p태그 안에 중괄호를 사용하여 바로 출력할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이번에는 컴포넌트 파일을 생성해서 App.js에 컴포넌트를 추가해 보겠습니다.&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom1.png&quot; alt=&quot;reactcom1&quot; width=&quot;500&quot;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom2.png&quot; alt=&quot;reactcom2&quot; width=&quot;500&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;src 디렉터리에 &lt;code&gt;DogImage.js&lt;/code&gt;라는 파일을 생성했습니다. (~~~.jsx 확장자도 가능합니다.) &lt;strong&gt;RSF 스니펫&lt;/strong&gt;을 활용하면 간편하게 jsx 형식을 갖출 수 있습니다.&lt;/p&gt;
&lt;p&gt;강아지 이모티콘을 출력하는 컴포넌트를 작성해 보겠습니다.&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom3.png&quot; alt=&quot;reactcom3&quot; width=&quot;500&quot;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom4.png&quot; alt=&quot;reactcom4&quot; width=&quot;500&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;img_style&lt;/code&gt; 함수를 정의하고 img 태그에 적용시켜 주었습니다. React에서 이미지 src를 적용할 경우 상단에 이미지를 import한 후 적용하거나, 위처럼 require을 사용해야 합니다.&lt;/p&gt;
&lt;p&gt;App.js에서 DogImage.js를 import한 후, a 태그 부분을 지운 뒤 컴포넌트를 넣었습니다.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom5.png&quot; alt=&quot;reactcom5&quot; width=&quot;500&quot;&gt;
&lt;p&gt;결과는 이렇게 잘 나옵니다! 이번엔 이미지를 5번 반복시켜 보겠습니다.&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom7.png&quot; alt=&quot;reactcom7&quot; width=&quot;430&quot;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom6.png&quot; alt=&quot;reactcom6&quot; width=&quot;500&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;map 함수를 활용하면 다음과 같이 반복할 수 있습니다. 예제로는 이미지를 다뤘지만, 주로 함수 내에서 사용하는 배열이나 json 객체와 관련하여 다룰 때 효과적입니다. React를 탐구하면 할수록 자주 사용하게 되는 방식입니다.&lt;/p&gt;
&lt;p&gt;컴포넌트 또한 반복 가능합니다.&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom8.png&quot; alt=&quot;reactcom8&quot; width=&quot;500&quot;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom9.png&quot; alt=&quot;reactcom9&quot; width=&quot;369&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;h3&gt;2. Props&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Props&lt;/strong&gt;는 Properties의 줄임말로, 컴포넌트에 전달하는 데이터를 말합니다. &lt;code&gt;Number.js&lt;/code&gt;라는 새 컴포넌트를 만들고 props 값을 넘겨 그 값을 출력하도록 설계해 보겠습니다.&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom10.png&quot; alt=&quot;reactcom10&quot; width=&quot;440&quot;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom11.png&quot; alt=&quot;reactcom11&quot; width=&quot;342&quot;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactcom12.png&quot; alt=&quot;reactcom12&quot; width=&quot;126&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;Number.js에서 num을 받아 h1 태그 안에 출력하고, App.js에서는 컴포넌트에 &lt;code&gt;num={넘길 값}&lt;/code&gt;의 형태로 값을 전달했습니다.&lt;/p&gt;
&lt;p&gt;위와 같은 예제는 간단한 경우이지만, 복잡한 구조 속에서 이러한 컴포넌트와 Props를 잘 활용하면 불필요한 코드의 반복을 줄일 수 있고, 효율적인 프로그래밍을 실현할 수 있습니다.&lt;/p&gt;
&lt;h1&gt;Phase 5. 상태 관리&lt;/h1&gt;
&lt;p&gt;지금까지 예제에서는 정적인 부분만 다뤘습니다. 하지만 웹페이지는 시시각각 변화하며, 다양한 동적 데이터를 다루어야 하는 경우가 많습니다.&lt;/p&gt;
&lt;p&gt;사용자 요청에 따라 값이 바뀌어야 할 경우, 값의 상태를 관리하는 방법이 대해 알아보겠습니다.&lt;/p&gt;
&lt;h3&gt;UseState&lt;/h3&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactusestate.png&quot; alt=&quot;reactusestate&quot; width=&quot;500&quot;&gt;
&lt;p&gt;&lt;strong&gt;UseState&lt;/strong&gt;는 React에서 지원하는 상태 관리 도구입니다. useState import 후 위와 같은 구문으로 사용 가능합니다. 초깃값은 0으로 설정해 두었고, &lt;code&gt;setNum&lt;/code&gt;을 사용하여 &lt;code&gt;num&lt;/code&gt; 값을 수정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;num 값을 조절할 수 있는 마이너스, 플러스 함수를 생성하고, 버튼으로 실행시켜 값을 변경해보도록 하겠습니다.&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactstate1.png&quot; alt=&quot;reactstate1&quot; width=&quot;500&quot;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactstate2.png&quot; alt=&quot;reactstate2&quot; width=&quot;500&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;App.js 코드를 위처럼 변경했습니다. 추가적으로, React에서 인라인 스타일을 지정하려면 &lt;code&gt;style={{ display: &quot;flex&quot; }}&lt;/code&gt;처럼 중괄호를 이중으로 해야합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setPlus 함수&lt;/strong&gt; : num의 값을 1 증가&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setMinus 함수&lt;/strong&gt; : num의 값을 1 감소&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactstate3.gif&quot; alt=&quot;reactstate3&quot; width=&quot;500&quot;&gt;
&lt;p&gt;선택하는 이벤트에 따라 알맞게 작동합니다.&lt;/p&gt;
&lt;h3&gt;UseEffect&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;UseEffect&lt;/strong&gt;는 컴포넌트가 렌더링 될 때 특정 작업을 실행할 수 있는 hook입니다. 위에서 다룬 num 값의 변화를 UseEffect로 감지하여 console.log로 출력해 보겠습니다.&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactuseeffect1.png&quot; alt=&quot;reactuseeffect1&quot; width=&quot;400&quot;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230429/reactuseeffect2.gif&quot; alt=&quot;reactuseeffect2&quot; width=&quot;668&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;useEffect 함수의 마지막 파라미터에 num을 넣음으로써 num 값이 변할 때마다 useEffect에 등록한 함수가 호출됩니다. 따라서 클릭 이벤트가 발생할 때 num 값을 출력하는 console.log가 실행되는 것을 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;이렇게 React의 기본적인 정보에 대해 살펴보았습니다. 이것보다 더 놀랍고 유용한 기능들이 많으니 웹 프로그래밍에 관심 있으신 분들은 여러가지 다른 자료를 찾아가며 React를 배워 보시길 추천드립니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[관계 데이터 모델의 개념]]></title><description><![CDATA[개념적 구조를 논리적 구조로 표현하는 논리적 데이터 모델을 관계형 데이터 모델이라고 한다. :one: 기본 용어 릴레이션(Relation) 하나의 개체에 관한 데이터를 2차원 테이블의 구조로 저장한 것 파일 관리 시스템 관점에서 파일(File…]]></description><link>https://yhuj79.github.io/Database/230411/</link><guid isPermaLink="false">https://yhuj79.github.io/Database/230411/</guid><pubDate>Tue, 11 Apr 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;개념적 구조를 논리적 구조로 표현하는 논리적 데이터 모델을 &lt;strong&gt;관계형 데이터 모델&lt;/strong&gt;이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;:one: 기본 용어&lt;/h2&gt;
&lt;h3&gt;릴레이션(Relation)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하나의 개체에 관한 데이터를 2차원 테이블의 구조로 저장한 것&lt;/li&gt;
&lt;li&gt;파일 관리 시스템 관점에서 파일(File)에 대응&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;속성(Attribute)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;릴레이션의 열, Attribute&lt;/li&gt;
&lt;li&gt;파일 관리 시스템 관점에서 필드(Field)에 대응&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;투플(Tuple)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;릴레이션의 행&lt;/li&gt;
&lt;li&gt;파일 관리 시스템 관점에서 레코드(Record)에 대응&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;도메인(Domain)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하나의 속성이 가질 수 있는 모든 값의 집합&lt;/li&gt;
&lt;li&gt;속성 값을 입력 및 수정할 때 적합성 판단의 기준이 됨&lt;/li&gt;
&lt;li&gt;일반적으로 속성의 특성을 고려한 데이터 타입으로 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;널(Null)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;속성 값을 아직 모르거나 해당되는 값이 없음을 표현&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;차수(Degree)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하나의 릴레이션에서 속성의 전체 개수&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;카디널리티(Cardinality)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하나의 릴레이션에서 투플의 전체 개수&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230411/5-1.png&quot; alt=&quot;5-1&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;고객 릴레이션의 차수와 카디널리티 값은?

Degree : 6, Cardinality : 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;:two: 릴레이션의 구성&lt;/h2&gt;
&lt;h3&gt;릴레이션 스키마(Relation schema)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;릴레이션의 논리적 구조&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;릴레이션의 이름과 릴레이션에 포함된 모든 속성의 이름으로 정의&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex) 고객(고객아이디, 고객이름, 나이, 등급, 직업, 적립금)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;릴레이션 내포(Relation Intension)라고도 함&lt;/li&gt;
&lt;li&gt;자주 변하지 않는 정적인 특징&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;릴레이션 인스턴스(Relation Instance)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어느 한 시점에 릴레이션에 존재하는 투플들의 집합&lt;/li&gt;
&lt;li&gt;릴레이션 외연(Relation Extension)이라고도 함&lt;/li&gt;
&lt;li&gt;투플의 삽입, 삭제, 수정이 자주 발생하는 동적인 특징&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230411/5-2.png&quot; alt=&quot;5-2&quot;&gt;&lt;/p&gt;
&lt;h2&gt;:three: 데이터베이스의 구성&lt;/h2&gt;
&lt;h3&gt;데이터베이스 스키마(Database Schema)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스의 전체 구조&lt;/li&gt;
&lt;li&gt;데이터베이스를 구성하는 릴레이션 스키마의 모음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;데이터베이스 인스턴스(Database Instance)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스를 구성하는 릴레이션 인스턴스의 모음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230411/5-3.png&quot; alt=&quot;5-3&quot;&gt;&lt;/p&gt;
&lt;h2&gt;:four: 릴레이션의 특성&lt;/h2&gt;
&lt;h3&gt;투플의 유일성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;하나의 릴레이션에는 동일한 투플이 존재할 수 없다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;» 투플을 유일하게 구별하기 위해 선정하는 속성(또는 속성들의 모임)의 값으로 판단&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;투플의 무순서&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하나의 릴레이션에서 투플 사이의 순서는 무의미하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;속성의 무순서&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하나의 릴레이션에서 속성 사이의 순서는 무의미하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;속성의 원자성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;속성 값으로 원자 값만 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;:five: 릴레이션 키&lt;/h2&gt;
&lt;h3&gt;키(key)&lt;/h3&gt;
&lt;p&gt;릴레이션에서 투플들을 유일하게 구별하는 속성 또는 속성들의 집합&lt;/p&gt;
&lt;h4&gt;유일성(uniqueness)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;- 하나의 릴레이션에서 모든 투플은 서로 다른 키 값을 가져야 함
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;최소성(minimality)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;- 꼭 필요한 최소한의 속성들로만 키를 구성함
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;키의 종류&lt;/h3&gt;
&lt;h4&gt;슈퍼키(super key)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;유일성을 만족하는 속성 또는 속성들의 집합&lt;/li&gt;
&lt;li&gt;ex) 고객 릴레이션의 슈퍼키 : 고객아이디, (고객아이디, 고객이름),(고객이름, 주소) 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;후보키(candidate key)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;유일성과 최소성을 만족하는 속성 또는 속성들의 집합&lt;/li&gt;
&lt;li&gt;ex) 고객 릴레이션의 후보키 : 고객아이디, (고객이름, 주소) 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;기본키(primary key)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;후보키 중에서 기본적으로 사용하기 위해 선택한 키&lt;/li&gt;
&lt;li&gt;ex) 고객 릴레이션의 기본키 : 고객아이디&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;대체키(alternate key)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;기본키로 선택되지 못한 후보키&lt;/li&gt;
&lt;li&gt;ex) 고객 릴레이션의 대체키 : (고객이름, 주소)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;외래키(foreign key)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;릴레이션들 사이의 관계를 표현&lt;/p&gt;
&lt;p&gt;– 참조하는 릴레이션 : 외래키를 가진 릴레이션&lt;/p&gt;
&lt;p&gt;– 참조되는 릴레이션 : 외래키가 참조하는 기본키를 가진 릴레이션&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;img alt=&quot;5-8&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230411/5-8.png&quot;/&gt;
&lt;br&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot; width=&quot;63.1%&quot;&gt;&lt;img alt=&quot;5-9&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230411/5-9.png&quot;/&gt;&lt;/td&gt;
    &lt;td valign=&quot;top&quot; width=&quot;38%&quot;&gt;&lt;img alt=&quot;5-11&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230411/5-11.png&quot;/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;하나의 릴레이션에는 외래키가 여러 개 존재할 수도 있고, 외래키를 기본키로 사용할 수도 있다.
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&quot;5-12&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230411/5-12.png&quot;/&gt;
&lt;pre&gt;&lt;code&gt;같은 릴레이션의 기본키를 참조하는 외래키도 정의할 수 있다.
그리고 외래키 속성은 널 값을 가질 수도 있다.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B6309667232&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;IT CookBook, 데이터베이스 for Beginner&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[클라우드 서비스 IaaS, PaaS, SaaS]]></title><description><![CDATA[클라우드 서비스는 자신이 보유한 PC가 아닌, 제공업체가 호스팅하여 인터넷을 통해 사용자에게 인프라, 플랫폼 또는 소프트웨어를 제공한다. 클라우드 서비스 종류는 Infrastructure, Platform, Software의 형태로 나뉘어진다. On…]]></description><link>https://yhuj79.github.io/Computer Science/230312/</link><guid isPermaLink="false">https://yhuj79.github.io/Computer Science/230312/</guid><pubDate>Sun, 12 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;클라우드 서비스는 자신이 보유한 PC가 아닌, 제공업체가 호스팅하여 인터넷을 통해 사용자에게 인프라, 플랫폼 또는 소프트웨어를 제공한다. 클라우드 서비스 종류는 Infrastructure, Platform, Software의 형태로 나뉘어진다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;On-premise 방식과 Cloud Computing&lt;/h2&gt;
&lt;p&gt;인터넷에 서비스 환경을 구축하기 위해서는 서버, 네트워크 설치, 방화벽, 전력 등 직접적으로 신경써야 할 것이 많다. 이러한 방식을 &lt;strong&gt;온-프레미스(On-premise)&lt;/strong&gt; 라고 한다. 기업이 자체적으로 IT 인프라를 소유, 관리 및 운영하는 경우는 On-premise 방식이라고 볼 수 있는데, 춘천에 있는 &lt;strong&gt;네이버 IDC(Internet Data Center)&lt;/strong&gt; 를 예로 들 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230312/NaverIDC.png&quot; alt=&quot;NaverIDC&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;네이버 데이터센터 각&lt;/strong&gt; 은 춘천의 산간 지역에 있어 냉각수를 전기가 아닌 외부의 찬 공기를 이용해 만드는 방식을 채택했다. 이러한 방식을 프리쿨링(Pre-cooling)이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이처럼 On-premise 방식은 인프라 구축에 부담이 있고, 시간이 흘러 IT 시스템이 고도화됨에 따라 비효율적인 업무 프로세스로 이어질 수 있다.&lt;/p&gt;
&lt;p&gt;이에 따라 새롭게 각광받은 서비스가 &lt;strong&gt;오프-프레미스(Off-premise)&lt;/strong&gt; 방식의 &lt;strong&gt;클라우드 컴퓨팅(Cloud Computing)&lt;/strong&gt; 이다. 클라우드(Cloud)는 인터넷을 통해 접근할 수 있는 서버, 그 안에서 구동되는 소프트웨어, 데이터베이스 등을 의미한다. 사용자가 클라우드 서비스를 이용하기 위해서는 단지 컴퓨터와 운영체제, 사용 가능한 인터넷만 있으면 된다.&lt;/p&gt;
&lt;p&gt;그리고 클라우드 서비스는 크게 3 가지 모델로 구분할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IaaS, PaaS, SaaS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;IaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Infrastructure as a Service&lt;/strong&gt;의 줄임말이며, 기본적인 인프라를 제공하는 형태이다. 사용자가 관리할 수 있는 범위가 제일 넓어서 다양한 목적에 맞게 자유로운 인프라 활용이 가능하나, 이에 대한 정보와 경험이 부족할 경우 활용에 어려움을 겪을 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;대표적인 IaaS 서비스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Amazon Web Service(AWS) EC2&lt;/li&gt;
&lt;li&gt;Google Compute Engine(GCE)&lt;/li&gt;
&lt;li&gt;Gabia Cloud&lt;/li&gt;
&lt;li&gt;OpenStack&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;PaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Platform as a Service&lt;/strong&gt;의 줄임말이며, 플랫폼을 제공하는 형태로, 어플리케이션 실행 환경이나 데이터베이스, CI/CD 등이 미리 마련되어 있으므로, 인프라 구축 시간을 절약할 수 있다. 그리고 서버, 네트워크, 보안 등을 클라우드 사업자에게 위임하므로 구축 및 운영이 쉽다. PaaS는 운영체제, 미들웨어, 런타임 등을 미리 구축한 상태로 제공하기 때문에 IaaS보다 관리상의 자유도가 낮고, 사전에 구축된 환경 위에서 개발하기 때문에 이용 중인 PaaS 플랫폼에 종속될 여지가 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;대표적인 PaaS 서비스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Heroku&lt;/li&gt;
&lt;li&gt;OpenShift&lt;/li&gt;
&lt;li&gt;Google App Engine&lt;/li&gt;
&lt;li&gt;IBM Bluemix&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;SaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Software as a Service&lt;/strong&gt;의 줄임말이며, 클라우드 서비스로 제공되는 소프트웨어 자체이다. 현재 우리의 일상에서 다양한 SaaS 서비스들이 사용되고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;대표적인 SaaS 서비스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Gmail, Docs, Cloud&lt;/li&gt;
&lt;li&gt;Naver MYBOX&lt;/li&gt;
&lt;li&gt;MS Office 365&lt;/li&gt;
&lt;li&gt;DropBox&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;비교표&lt;/h2&gt;
&lt;p&gt;On-premise부터 SaaS까지 표로 정리하면 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230312/ServiceGraph.png&quot; alt=&quot;ServiceGraph&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 style=&quot;color:#5EC4E4&quot;&gt;사용자가 직접 구축, 제어해야 할 요소&lt;/h3&gt;
&lt;h3 style=&quot;color:#EB5D2A&quot;&gt;사용자 컨트롤이 필요하지 않은 요소&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gilbut.co.kr/book/view?bookcode=BN003386&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;면접을 위한 CS 전공지식 노트&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wnsgml972.github.io/network/2018/08/14/network_cloud-computing/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;클라우드 컴퓨팅, IaaS, PaaS, SaaS이란?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.purestorage.com/kr/knowledge/on-premises-vs-off-premises.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;온-프레미스 vs. 오프-프레미스 | 퓨어스토리지&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mmsesang.tistory.com/entry/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%AA%A8%EB%8D%B8-Cloud-Service-Model&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;클라우드 서비스 모델 (Cloud Service Model)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.redhat.com/ko/topics/cloud-computing/what-are-cloud-services&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;클라우드 서비스란? | RedHat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eformsign.com/kr/blog/cloud-and-onpremise/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;전자계약 도입, 클라우드 or 온프레미스 - 이폼사인&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://library.gabia.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;가비아 라이브러리: IT 콘텐츠 허브&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;SaaS vs PaaS vs IaaS: What’s The Difference &amp;#x26; How To Choose – BMC Software&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[시간 복잡도, Big-O(빅오) 표기법]]></title><description><![CDATA[…]]></description><link>https://yhuj79.github.io/Algorithm/230224/</link><guid isPermaLink="false">https://yhuj79.github.io/Algorithm/230224/</guid><pubDate>Fri, 24 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;온라인 저지, 알고리즘 대회 등에서 문제를 출제할 때 출제자의 의도에 맞는 효율적인 구조로 유도하기 위해 적절한 시간 제한을 두기 때문에, 알고리즘 설계 시 시간 복잡도를 고려하여 작성해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;알고리즘의 분석 기준&lt;/h2&gt;
&lt;p&gt;알고리즘의 성능을 분석하는 판단 기준에는 정확성, 명확성, 수행량, 메모리 사용량, 최적성 등이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;정확성 : 자료 입력 시 유한한 시간 내에 올바른 결과를 출력

명확성 : 알고리즘의 표현이 이해하기 쉽고 명확하게 작성

수행량 : 일반적인 연산을 제외하고 알고리즘의 특성을 나타내는 중요 연산을 분석

메모리 사용량 : 명령어, 변수, 입출력 자료와 정보를 저장하기 위한 메모리 사용 정도 판단

최적성 : 사용 환경에 따른 수행량과 메모리 사용량 변화에 대한 최적화를 판단
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이러한 기준을 바탕으로 알고리즘을 분석하는 방법에는 실행에 필요한 공간적 측면에서 분석하는 공간 복잡도, 소요 시간 측면의 시간 복잡도가 있다. 이 포스팅에서는 시간 복잡도를 나타내는 Big-O(빅오) 표기법과 간단한 예제들을 다룬다.&lt;/p&gt;
&lt;h2&gt;Big-O(빅오) 표기법&lt;/h2&gt;
&lt;p&gt;시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법을 &lt;strong&gt;Big-O(빅오) 표기법&lt;/strong&gt;이라고 한다. Big-O에서는 최악의 상황을 가정하여 연산 횟수를 짐작한다.&lt;/p&gt;
&lt;h3&gt;:one: O(1) : Constant Time&lt;/h3&gt;
&lt;p&gt;입력 데이터의 크기에 상관없이 일정한 시간이 걸린다면 &lt;strong&gt;O(1)의 시간 복잡도를 가진 알고리즘(Constant Time)&lt;/strong&gt;이라고 한다. 어떤 배열이 있다고 할 경우, 배열의 길이와 상관없이 해당 index에 접근해 즉시 값을 얻을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// C
int arr[3] = {0,1,2};

void printArr(int arr[]) {
    printf(&quot;%d\n&quot;, arr[0]);
    printf(&quot;%d\n&quot;, arr[1]);
    printf(&quot;%d\n&quot;, arr[2]);
}

int main(void) {
    printArr(arr);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Javascript
function printArr(arr, index) {
  return arr[index]
}

const arr = [0, 1, 2]

console.log(printArr(arr, 0))
console.log(printArr(arr, 1))
console.log(printArr(arr, 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;:two: O(log n) : Logarithmic Time&lt;/h3&gt;
&lt;p&gt;O(log n)은 &lt;strong&gt;로그 복잡도(Logarithmic Time)&lt;/strong&gt;라고 부르며, Big-O표기법중 O(1) 다음으로 가장 빠르다.&lt;br&gt;
다음 코드는 &lt;code&gt;i = i * 2&lt;/code&gt; 에 의해 1, 2, 4, 8, 16 ...인 2의 거듭제곱으로 증가한다. 이는 log2 N번 연산하므로, 시간 복잡도는 O(log n)이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// C
void printNum(int n){
    int i = 1;
    while(i &amp;#x3C; n){
        printf(&quot;%d\n&quot;, i);
        i = i * 2;
    }
}

int main(void) {
    printNum(20);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Javascript
function printNum(n) {
  let i = 1
  while (i &amp;#x3C; n) {
    console.log(i)
    i = i * 2
  }
}

printNum(20)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;이진 탐색(Binary Search)&lt;/strong&gt;의 경우 또한 O(log n)의 시간 복잡도를 가진다. 찾고자 하는 값을 정렬된 배열의 중간 값과 비교하여 절반을 탐색 대상에서 제외시키기 때문이다.&lt;/p&gt;
&lt;img alt=&quot;bs&quot; width=&quot;100%&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230224/bs.gif&quot;&gt;
&lt;h3&gt;:three: O(n) : Linear Time&lt;/h3&gt;
&lt;p&gt;입력 데이터의 크기에 비례해서 처리시간이 늘어나는 경우 &lt;strong&gt;O(n)&lt;/strong&gt;이다. 입력된 값이 1일 때의 시간이 1초 걸린다면, 입력된 값이 100일 때 100초일 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// C
void printNum(int n){
    for (int i=0; i &amp;#x3C; n; i++) {
        printf(&quot;%d\n&quot;, i);
    }
}

int main(void) {
    printNum(10);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Javascript
const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

function printArr() {
  for (let i = 0; i &amp;#x3C; arr.length; i++) {
    console.log(`arr[${i}] = ${arr[i]}`)
  }
}

printArr(10)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;:four: O(n log n) : Linearithmic Time&lt;/h3&gt;
&lt;p&gt;위에서 다룬 O(log n)의 시간복잡도를 가진 while문에 for문이 중첩된 구조이다. for문의 반복횟수는 n에 비례하는 반면, while문의 반복횟수는 log n에 비례한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// C
void printNum(int n){
    for(int i=1; i&amp;#x3C;n; i++){
        int j=1;
        while(j&amp;#x3C;n){
            printf(&quot;%d %d\n&quot;,i,j);
            j = j * 2;
        }
    }
}

int main(void) {
    printNum(10);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Javascript
function printNum(n) {
  for (let i = 0; i &amp;#x3C; n; i++) {
    let j = 1
    while (j &amp;#x3C; n) {
      console.log(`${i} x ${j} = ${i * j}`)
      j = j * 2
    }
  }
}

printNum(5)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;:five: O(n^2) : Quadratic Time&lt;/h3&gt;
&lt;p&gt;이중 for문을 돌면서 수행하는 알고리즘은 &lt;strong&gt;O(n^2)&lt;/strong&gt;의 시간 복잡도를 갖는다. 입력 데이터가 증가함에 따라 시간이 n의 제곱수의 비율로 증가한다. 2 이상의 제곱이 주어져도 영향력이 미비하기 때문에 통상적으로 O(n^2)으로 표시한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// C
void printNum(int n){
    for(int i=1; i&amp;#x3C;=n; i++){
        for(int j=1; j&amp;#x3C;=n*2; j++) {
            printf(&quot;%d %d\n&quot;, i, j);
        }
    }
}

int main(void) {
    printNum(3);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Javascript
function multiplication(n, m) {
  for (let i = 1; i &amp;#x3C;= n; i++) {
    for (let j = 1; j &amp;#x3C;= m; j++) {
      console.log(`${i} x ${j} = ${i * j}`)
    }
    console.log()
  }
}

multiplication(9, 9)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;:six: O(2n) : Exponential Time&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;O(2n)&lt;/strong&gt;은 Big-O(빅오) 표기법 중에서 O(n!)을 제외한다면 가장 느리며, 입력 데이터가 어느 정도 커지면 소요 시간은 무한대에 가까워질 수 있다. 대표적으로 재귀적 수행을 하는 &lt;strong&gt;피보나치 수열&lt;/strong&gt;이 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/10870&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;10870번: 피보나치 수 5 | Baekjoon Online Judge&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function fibonacci(input) {
  if (input == 0) return 0
  else if (input == 1) return 1
  else return fibonacci(input - 1) + fibonacci(input - 2)
}
console.log(fibonacci(input))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;:seven: O(n!) : Factorial Time&lt;/h3&gt;
&lt;p&gt;Big O 최악의 런타임이다. 입력 데이터의 원소들로 만들 수 있는 모든 순열을 생성한다.&lt;br&gt;
다음 코드는 Factorial Time에 대한 정의이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void nFacRuntimeFunc(int n) {
  for(int i=0; i&amp;#x3C;n; i++) {
    nFacRuntimeFunc(n-1);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;시간 복잡도 그래프&lt;/h2&gt;
&lt;p&gt;속도는 &lt;code&gt;O(1)&lt;/code&gt; &lt;code&gt;O(log N)&lt;/code&gt; &lt;code&gt;O(N)&lt;/code&gt; &lt;code&gt;O(N log N)&lt;/code&gt; &lt;code&gt;O(N^2)&lt;/code&gt; &lt;code&gt;O(2^N)&lt;/code&gt; &lt;code&gt;O(N!)&lt;/code&gt; 순서대로 빠르다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230224/bigochart.png&quot; alt=&quot;bigochart&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Baekjoon Online Judge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://levelup.gitconnected.com/time-complexity-and-bigo-notation-linear-time-constant-time-and-quadratic-time-686c279ecd88&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Time Complexity and BigO Notation... | by Sebastian De Lima&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bigocheatsheet.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Big-O Algorithm Complexity Cheat Sheet (Know Thy Complexities!) @ericdrowell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://overcome-the-limits.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-with-JavaScript&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[자료구조] 시간복잡도 with JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insight-bgh.tistory.com/505&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[Algorithm] 시간 복잡도(Time Complexity) - 2WEEKS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jongbeom-dev.tistory.com/159&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;알고리즘 복잡도와 빅 오 표기법 :: 비전공 개발자&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yoongrammer.tistory.com/75&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;이진 탐색 (Binary search) 개념 및 구현&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@kimdukbae/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-Binary-Search&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[알고리즘] 이분 탐색 / 이진 탐색 (Binary Search)&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React-Quill Editor 이미지 처리하기 (Firebase Storage)]]></title><description><![CDATA[React-Quill은 간편하게 사용할 수 있는 Rich Text Editor이다. 하이퍼링크, 글꼴, 색상, 스타일, 이미지 등의 양식을 쉽게 구성할 수 있다. React-Quill 구성하기 React App에 react-quill…]]></description><link>https://yhuj79.github.io/React/230214/</link><guid isPermaLink="false">https://yhuj79.github.io/React/230214/</guid><pubDate>Tue, 14 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;React-Quill은 간편하게 사용할 수 있는 Rich Text Editor이다.&lt;/p&gt;
&lt;p&gt;하이퍼링크, 글꼴, 색상, 스타일, 이미지 등의 양식을 쉽게 구성할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;React-Quill 구성하기&lt;/h2&gt;
&lt;p&gt;React App에 &lt;code&gt;react-quill&lt;/code&gt;을 설치한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add react-quill
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;App.js&lt;/code&gt;에 다음과 같이 Quill 에디터를 구성하였다.&lt;br&gt;
상단 버튼을 클릭하면 콘솔에서 에디터의 value를 확인할 수 있게 만들었다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// src/App.js
import { useMemo, useRef, useState } from &quot;react&quot;
import &quot;react-quill/dist/quill.snow.css&quot;
import ReactQuill from &quot;react-quill&quot;

function App() {
  const quillRef = useRef()
  const [content, setContent] = useState(&quot;&quot;)

  // quill에서 사용할 모듈
  // useMemo를 사용하여 modules가 렌더링 시 에디터가 사라지는 버그를 방지
  const modules = useMemo(() =&gt; {
    return {
      toolbar: {
        container: [
          [{ header: [1, 2, 3, false] }],
          [&quot;bold&quot;, &quot;italic&quot;, &quot;underline&quot;, &quot;strike&quot;],
          [&quot;blockquote&quot;],
          [{ list: &quot;ordered&quot; }, { list: &quot;bullet&quot; }],
          [{ color: [] }, { background: [] }],
          [{ align: [] }, &quot;link&quot;, &quot;image&quot;],
        ],
      },
    }
  }, [])

  return (
    &amp;#x3C;div style={{ margin: &quot;50px&quot; }}&gt;
      &amp;#x3C;button onClick={() =&gt; console.log(content)}&gt;Value&amp;#x3C;/button&gt;
      &amp;#x3C;ReactQuill
        style={{ width: &quot;600px&quot;, height: &quot;600px&quot; }}
        placeholder=&quot;Quill Content&quot;
        theme=&quot;snow&quot;
        ref={quillRef}
        value={content}
        onChange={setContent}
        modules={modules}
      /&gt;
    &amp;#x3C;/div&gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230214/quill_1.gif&quot; alt=&quot;quill_1&quot;&gt;&lt;/p&gt;
&lt;p&gt;Html 형태의 문자열이 content 값에 들어왔다.&lt;br&gt;
이 포스팅에서 CRUD까지 다루진 않지만 만약 DB에 저장된 content 값을 출력하고자 한다면 다음과 같이 &lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt;, &lt;code&gt;DOMPurify&lt;/code&gt;를 사용하면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add isomorphic-dompurify
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// src/ReadQuill.js
import DOMPurify from &quot;isomorphic-dompurify&quot;
import &quot;react-quill/dist/quill.core.css&quot;

function ReadQuill() {
  const content = &quot;&amp;#x3C;h1&gt;안녕하세요!&amp;#x3C;/h1&gt;&amp;#x3C;h2&gt;안녕하세요!&amp;#x3C;/h2&gt;&amp;#x3C;h3&gt;안녕하세요!&amp;#x3C;/h3&gt;&quot;
  return (
    &amp;#x3C;div
      className=&quot;view ql-editor&quot; // react-quill css
      dangerouslySetInnerHTML={{
        __html: DOMPurify.sanitize(content),
      }}
    /&gt;
  )
}

export default ReadQuill
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 dangerouslySetInnerHTML을 사용하여 직접적으로 HTML을 설정하는 것은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8A%B8_%EA%B0%84_%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8C%85&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Cross Site Scripting(XSS)&lt;/a&gt;에 취약하다고 한다. 그래서 XSS 공격을 방지하는 dompurify와 같은 sanitization library와 함께 사용해 주었다.&lt;/p&gt;
&lt;h2&gt;에디터에 이미지를 올리면?&lt;/h2&gt;
&lt;p&gt;일반적인 텍스트가 입력되면 content값은 그렇게 크지 않지만, 이미지가 들어오게 될 경우 문제가 생긴다. 이미지를 에디터에 올려보고 value를 체크해보자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230214/quill_2.gif&quot; alt=&quot;quill_2&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;img src=&quot;data:image/png;base64, 엄청나게 긴 base64 value...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;React-Quill은 이미지를 올리게 되면 8비트 이진 데이터를 문자 코드에 영향을 받지 않는 공통 ASCII 문자열로 바꾼다. (&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%8A%A464&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;base64&lt;/a&gt;) 따라서 위와 같은 base64 인코딩이 된 형태로 이미지가 저장된다. 이렇게 value에 담긴 값을 DB에 저장하려 하면 전송에 실패하게 된다.&lt;/p&gt;
&lt;h2&gt;Firebase Storage로 이미지 처리하기&lt;/h2&gt;
&lt;p&gt;이미지 업로드 시 base64 문자열이 들어가는 방식 대신 이미지가 &lt;code&gt;Firebase Storage&lt;/code&gt;에 저장이 되고, 저장된 이미지 URL을 에디터에 삽입하는 방식으로 구현하려고 한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://console.firebase.google.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Firebase Console&lt;/a&gt;에서 새 프로젝트를 생성한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Firebase 프로젝트 생성&lt;/code&gt; &gt; &lt;code&gt;웹 앱 추가&lt;/code&gt; &gt; &lt;code&gt;Storage&lt;/code&gt; &gt; &lt;code&gt;시작하기 (지역 : asia-east1)&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;&lt;img alt=&quot;fb1&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230214/fb1.png&quot;/&gt;&lt;/td&gt;
    &lt;td valign=&quot;top&quot;&gt;&lt;img alt=&quot;fb2&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230214/fb2.png&quot;/&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;&lt;img alt=&quot;fb3&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230214/fb3.png&quot;/&gt;&lt;/td&gt;
    &lt;td valign=&quot;top&quot;&gt;&lt;img alt=&quot;fb4&quot; src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230214/fb4.png&quot;/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;프로젝트에 &lt;code&gt;firebase&lt;/code&gt;를 설치하고 SDK를 작성한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add firebase
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// src/Firebase.js
// Import the functions you need from the SDKs you need
import { initializeApp, getApp, getApps } from &quot;firebase/app&quot;
import { getStorage } from &quot;firebase/storage&quot;
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app&apos;s Firebase configuration
const firebaseConfig = {
  apiKey: &quot;xxxxxxxxxxxxxxxxxx&quot;,
  authDomain: &quot;xxxxxxxxxxxxxxxxxx&quot;,
  projectId: &quot;xxxxxxxxxxxxxxxxxx&quot;,
  storageBucket: &quot;xxxxxxxxxxxxxxxxxx&quot;,
  messagingSenderId: &quot;xxxxxxxxxxxxxxxxxx&quot;,
  appId: &quot;xxxxxxxxxxxxxxxxxx&quot;,
}

// Initialize Firebase
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp()
export const storage = getStorage()
export default app
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Storage의 업로드 및 읽기 권한 설정을 위해 &lt;code&gt;firebase-tools&lt;/code&gt;를 설치하고 로그인 및 초기 설정을 진행한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add firebase-tools
$ firebase login
$ firebase init
    -&gt; Storage: Configure a security rules fileㅤfor Cloud Storage
    -&gt; Use an existing project
    -&gt; 프로젝트 선택
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로젝트에 생성된 &lt;code&gt;storage.rules&lt;/code&gt; 파일을 다음과 같이 수정한다.&lt;br&gt;
수정 후 &lt;code&gt;firebase deploy --only storage&lt;/code&gt; 로 적용하면 권한이 부여된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# /storage.rules
rules_version = &apos;2&apos;;
service firebase.storage {
  match /b/{bucket}/o {
    match /{allPaths=**} {
      allow read, write: if true;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;modules에 설정할 이미지 핸들러를 작성하였다.&lt;br&gt;
이미지 선택이 완료되면 Firebase Storage에 파일명 &lt;code&gt;image/Date.now()&lt;/code&gt;로 저장이 되고, &lt;code&gt;getDownloadURL&lt;/code&gt; 메서드로 받은 이미지 URL을 에디터에 삽입하는 흐름이다.&lt;/p&gt;
&lt;p&gt;(&lt;code&gt;Date.now()&lt;/code&gt; 메서드는 UTC 기준으로 1970년 1월 1일 0시 0분 0초부터 현재까지 경과된 밀리 초를 반환한다.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// src/App.js
...
...
import {storage} from &quot;./Firebase&quot;;
import { uploadBytes, getDownloadURL, ref } from &quot;firebase/storage&quot;;
...
...
  // 이미지 핸들러
  const imageHandler = () =&gt; {
    const input = document.createElement(&quot;input&quot;);
    input.setAttribute(&quot;type&quot;, &quot;file&quot;);
    input.setAttribute(&quot;accept&quot;, &quot;image/*&quot;);
    input.click();

    input.addEventListener(&quot;change&quot;, async () =&gt; {
      const editor = quillRef.current.getEditor();
      const file = input.files[0];
      const range = editor.getSelection(true);

      try {
        // 파일명을 &quot;image/Date.now()&quot;로 저장
        const storageRef = ref(
          storage,
          `image/${Date.now()}`
        );
        // Firebase Method : uploadBytes, getDownloadURL
        await uploadBytes(storageRef, file).then((snapshot) =&gt; {
          getDownloadURL(snapshot.ref).then((url) =&gt; {
            // 이미지 URL 에디터에 삽입
            editor.insertEmbed(range.index, &quot;image&quot;, url);
            // URL 삽입 후 커서를 이미지 뒷 칸으로 이동
            editor.setSelection(range.index + 1);
          });
        });
      } catch (error) {
        console.log(error);
      }
    });
  };
...
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Storage에 성공적으로 업로드 되었고, 이미지 URL 또한 에디터에 잘 반영이 되었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230214/quill_3.gif&quot; alt=&quot;quill_3&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230214/quill_4.png&quot; alt=&quot;quill_4&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8A%B8_%EA%B0%84_%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8C%85&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;사이트 간 스크립팅 - 위키백과, 우리 모두의 백과사전&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mingeesuh.tistory.com/entry/Quill-React-%EC%97%90%EB%94%94%ED%84%B0-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%97%85%EB%A1%9C%EB%93%9C-%EB%B0%8F-%EC%82%AC%EC%9D%B4%EC%A6%88-%EC%A1%B0%EC%A0%88&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Quill React 에디터 사용해보기 (이미지 업로드 및 사이즈 조절)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mingeesuh.tistory.com/entry/Firebase-%EC%9B%B9-%ED%8C%8C%EC%9D%B4%EC%96%B4%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%97%85%EB%A1%9C%EB%93%9C-%EB%B0%8F-%EB%A7%81%ED%81%AC-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[Firebase 웹] 파이어베이스 스토리지 이미지 업로드 및 링크 가져오기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://12ahn22.tistory.com/entry/Quill-%EC%97%90%EB%94%94%ED%84%B0-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Quill 에디터 - 이미지 처리하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Date.now() - JavaScript | MDN&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[구조 분해 할당]]></title><description><![CDATA[자바스크립트에서 구조 분해 할당은 객체 또는 배열의 속성을 분해하고 개별 변수를 쉽고 편리하게 할당하여 사용할 수 있게 해준다. 구조 분해 할당이란? Javascript…]]></description><link>https://yhuj79.github.io/Javascript/230125/</link><guid isPermaLink="false">https://yhuj79.github.io/Javascript/230125/</guid><pubDate>Wed, 25 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;자바스크립트에서 구조 분해 할당은 객체 또는 배열의 속성을 분해하고 개별 변수를 쉽고 편리하게 할당하여 사용할 수 있게 해준다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;구조 분해 할당이란?&lt;/h2&gt;
&lt;p&gt;Javascript의 객체와 배열은 굉장히 자주 사용되는 구조이다. 이를 효과적으로 사용하기 위한 방법 중에 &lt;strong&gt;구조 분해 할당(Destructuring Assignment)&lt;/strong&gt;이 있는데, 객체 또는 배열에서 일부만 사용하고 싶을 경우 변수로 분해하여 값을 개별 변수에 담아 사용할 수 있게 도와준다.&lt;/p&gt;
&lt;h2&gt;배열 분해&lt;/h2&gt;
&lt;p&gt;먼저 배열을 분해하는 간단한 방법이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;tomato&quot;, &quot;pear&quot;, &quot;grapes&quot;]

// let one = arr[0]
// let two = arr[1]
// let three = arr[2]
// let four = arr[3]
// let five = arr[4]    // 배열의 값을 각각 저장

let [one, two, three, four, five] = arr // 위 코드와 동일하게 동작

console.log(one) // apple
console.log(two) // banana
console.log(three) // tomato
console.log(four) // pear
console.log(five) // grapes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;좌변은 값을 담을 변수, 우변에는 분해 할 값이 위치한다. 배열의 요소를 직접 변수에 할당하지 않고 원래의 arr을 복사 후 분해하여 one, two, three로 사용 할 수 있어 직접 변수에 할당하는 것보다 코드의 양을 대폭 줄일 수 있다.&lt;/p&gt;
&lt;h2&gt;객체 분해&lt;/h2&gt;
&lt;p&gt;객체 분해 또한 배열과 유사하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let user = {
  name: &quot;James&quot;,
  job: &quot;developer&quot;,
  age: 28,
}

let { name, job, age } = user

console.log(name) // James
console.log(job) // developer
console.log(age) // 28
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 좌변 프로퍼티 키를 다른 이름의 변수로 저장할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let user = {
  name: &quot;James&quot;,
  job: &quot;developer&quot;,
  age: 28,
}

// 각각 name을 a, job을 b, age를 c로 저장
let { name: a, job: b, age: c } = user

console.log(a) // James
console.log(b) // developer
console.log(c) // 28
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;다양한 분해 형태&lt;/h2&gt;
&lt;h3&gt;기본값 설정&lt;/h3&gt;
&lt;p&gt;좌변에 기본값을 미리 부여한 후, 할당된 값이 없을 시 기본값이 출력된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let one, two
;[one = &quot;apple&quot;, two = &quot;banana&quot;] = [&quot;tomato&quot;] // one에만 값이 할당됨
console.log(one) // tomato
console.log(two) // banana // 할당된 값이 없어 기본값이 출력됨
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;객체에서도 위와 같이 기본값을 설정할 수 있다.&lt;/p&gt;
&lt;h3&gt;배열 요소 버리기&lt;/h3&gt;
&lt;p&gt;쉼표를 사용하여 사용하지 않을 배열 요소를 건너뛸 수 있다. 오타를 주의해야 할 것 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;tomato&quot;, &quot;pear&quot;, &quot;grapes&quot;, &quot;mango&quot;]

let [one, two, , three, , four] = arr

console.log(`${one}, ${two}, ${three}, ${four}`)
// apple, banana, pear, mango
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;나머지 요소&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;...&lt;/code&gt; 패턴을 이용하여 나머지 배열, 객체 요소를 한데 모아서 저장할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;tomato&quot;, &quot;pear&quot;, &quot;grapes&quot;, &quot;mango&quot;]

let user = {
  name: &quot;James&quot;,
  job: &quot;developer&quot;,
  age: 28,
}

let [one, two, three, ...other] = arr // 나머지를 other에 저장
let { name: a, ...rest } = user

console.log(`${one}, ${two}, ${three}`)
// apple, banana, tomato

console.log(`나머지 : ${other}`)
// 나머지 : pear,grapes,mango

console.log(`job: ${rest.job}, age: ${rest.age}`)
// job: developer, age: 28
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;객체 프로퍼티&lt;/h3&gt;
&lt;p&gt;좌변의 변수로 객체 프로퍼티와 같은 형태도 사용 가능하다. 할당 가능한 값이면 뭐든지 사용할 수 있다고 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;tomato&quot;, &quot;pear&quot;, &quot;grapes&quot;, &quot;mango&quot;]

let fruit = {}

;[fruit.one, fruit.two, fruit.three] = arr

console.log(fruit)
// {one: &quot;apple&quot;, two: &quot;banana&quot;, three: &quot;tomato&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;변수 교환&lt;/h3&gt;
&lt;p&gt;변수를 교환할 때 구조 분해 할당을 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let apple = &quot;apple&quot;
let banana = &quot;banana&quot;

;[apple, banana] = [banana, apple] // 임시 배열을 이용하여 배열을 분해

console.log(`${apple}, ${banana}`) // banana, apple
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;JSON 구조 분해 할당&lt;/h2&gt;
&lt;p&gt;json 데이터에서 어떠한 값만 순회하여 출력하고 싶을 경우, &lt;code&gt;Object.entries&lt;/code&gt; 메서드와 구조 분해를 활용하여 나타낼 수 있다. &lt;a href=&quot;https://jsonplaceholder.typicode.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;jsonplaceholder&lt;/a&gt;에서는 테스트를 위한 무료 fake api를 지원한다.&lt;/p&gt;
&lt;p&gt;전체 URL은 &lt;code&gt;https://jsonplaceholder.typicode.com/ + 리소스명&lt;/code&gt;으로 접속이 되고, 각 응답의 내용은 리소스 별로 다르다. axios를 통해 jsonplaceholder의 리소스를 받아 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;axios({
  url: &quot;https://jsonplaceholder.typicode.com/users&quot;,
  method: &quot;get&quot;,
}).then(function (response) {
  console.log(JSON.stringify(response.data, null, 5))
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230125/jsonplaceholder.png&quot; alt=&quot;jsonplaceholder&quot;&gt;&lt;/p&gt;
&lt;p&gt;jsonplaceholder의 users에는 총 10명의 정보가 들어있다. id, 이름, 이메일, 주소 등등...&lt;/p&gt;
&lt;p&gt;모든 user의 이름을 나타내기 위해 다음과 같이 코드를 작성했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;axios({
  url: &quot;https://jsonplaceholder.typicode.com/users&quot;,
  method: &quot;get&quot;,
}).then(function (response) {
  for (let [key, value] of Object.entries(response.data)) {
    console.log(`id : ${key}\nname : ${value.name}`)
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230125/objectEntries.png&quot; alt=&quot;objectEntries&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.entries&lt;/code&gt; 메서드를 사용하면 객체 자체의 enumerable 속성 [key, value] 쌍의 배열을 반환, 객체의 키(key)와 값(value)을 순회할 수 있다. response.data에 있는 value의 name을 순회하며 모든 user의 이름을 얻을 수 있게 되었다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.javascript.info/destructuring-assignment&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;구조 분해 할당 | 모던 JavaScript 튜토리얼&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://beomy.tistory.com/18&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[자바스크립트] ES6(ECMA Script 6) - 구조분해 할당(Destructuring assignment)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jsonplaceholder.typicode.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;JSONPlaceholder - Free Fake REST API&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Heroku에 Express 서버 배포하기]]></title><description><![CDATA[지난 포스팅에서 작성했던 Express 서버를 Heroku에 배포해보려고 한다. > React에서 Open API XML 데이터 파싱하기 (with Express) Heroku Heroku는 여러 프로그래밍 언어를 지원하는 클라우드 PaaS…]]></description><link>https://yhuj79.github.io/React/230115/</link><guid isPermaLink="false">https://yhuj79.github.io/React/230115/</guid><pubDate>Sun, 15 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;지난 포스팅에서 작성했던 Express 서버를 Heroku에 배포해보려고 한다.&lt;br /&gt; &gt; &lt;a href=&quot;https://yhuj79.github.io/blog/230104&quot; target=&quot;_blank&quot;&gt;React에서 Open API XML 데이터 파싱하기 (with Express)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Heroku&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Heroku&lt;/strong&gt;는 여러 프로그래밍 언어를 지원하는 클라우드 &lt;a href=&quot;https://azure.microsoft.com/ko-kr/resources/cloud-computing-dictionary/what-is-paas&quot; target=&quot;_blank&quot;&gt;PaaS&lt;/a&gt;로, 백엔드 서버를 이 플랫폼에 배포할 수 있다. 얼마 전 무료 서비스가 중단되었지만, 학생 개발자 프로그램으로 플랫폼 크레딧을 지급받을 수 있었다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dashboard.heroku.com/apps&quot; target=&quot;_blank&quot;&gt;Heroku Dashboard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;우측 상단 NEW 버튼 &gt; Create new app &gt; 앱 이름 입력 &gt; Create App&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230115/230115-01.png&quot; alt=&quot;230115-01&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230115/230115-02.png&quot; alt=&quot;230115-02&quot;&gt;&lt;/p&gt;
&lt;p&gt;작성했던 server와의 연결에 앞서 server 디렉터리에 &lt;code&gt;Procfile&lt;/code&gt;을 생성하고 다음과 같이 작성한다. Procfile을 읽은 헤로쿠가 &lt;code&gt;yarn dev&lt;/code&gt;를 실행하고 yarn dev는 package.json에 작성해 두었던 &lt;code&gt;nodemon server.js&lt;/code&gt;를 실행하게 되는 구조다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// server/Procfile
web: yarn dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;터미널에서 Heroku를 설치한다. Mac을 사용중이기 때문에 &lt;code&gt;homebrew&lt;/code&gt;로 설치하였다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# Mac
$ brew install heroku/brew/heroku
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;윈도우의 경우 다음 URL에서 설치 파일을 다운로드 받을 수 있다.&lt;br /&gt;
&lt;a href=&quot;https://devcenter.heroku.com/articles/heroku-cli#verify-your-installation&quot; target=&quot;_blank&quot;&gt;The Heroku CLI&lt;/a&gt; &lt;code&gt;64-bit installer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;설치를 완료하면 &lt;code&gt;heroku version&lt;/code&gt; 명령어로 확인해본다.&lt;/p&gt;
&lt;p&gt;그리고 Heroku 로그인 후, server 디렉터리에서 Heroku Server에 연결한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ heroku login

# /server
$ git init
$ heroku git:remote -a open-api-tutorial
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Heroku에 기존의 환경 변수를 전송하려면 &lt;code&gt;heroku-dotenv&lt;/code&gt;를 설치해야 한다. 설치 후 push하면 &lt;code&gt;.env&lt;/code&gt;의 &lt;code&gt;REACT_APP_API_KEY&lt;/code&gt;가 온전하게 적용된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add heroku-dotenv
$ heroku-dotenv push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 작성한 server의 코드를 &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;하면 Heroku Deploy가 완료된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ git add .
$ git commit -am &quot;heroku open-api-tutorial&quot;
$ git push heroku master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;https://open-api-tutorial.herokuapp.com/api/data&lt;/code&gt;에서 데이터를 확인할 수 있다.&lt;br&gt;
이렇게 재가공된 API가 만들어졌다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230115/230115-03.png&quot; alt=&quot;230115-03&quot;&gt;&lt;/p&gt;
&lt;p&gt;이제 Heroku의 데이터를 받아서 콘솔에 출력한다.&lt;br&gt;
다시 GitHub Page에 배포하고 확인해보면 문제없이 잘 작동하는 것을 볼 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// src/App.js
...
...

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      try {
        const res = await axios.get(
          `https://open-api-tutorial.herokuapp.com/api/data`
        );
        console.log(res.data.response.body.items.item);
      } catch (e) {
        console.log(e);
      }
    };
    fetchData();
  }, []);

...
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230115/230115-04.png&quot; alt=&quot;230115-04&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@vvsogi/%EA%B3%B5%EA%B3%B5-%EB%8D%B0%EC%9D%B4%ED%84%B0-API-React%EC%97%90%EC%84%9C-XML%EC%97%90%EC%84%9C-JSON-%EB%B3%80%ED%99%98&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;공공 데이터 API React에서 XML에서 JSON 변환!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/harrythegreat/node-js%EC%97%90%EC%84%9C-request-js-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-28744c52f68d&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Node.js에서 Request.js 사용하기. 네트워크 더 간결하게 작성하자! | by Harry The Great | 해리의 유목코딩 | Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://krpeppermint100.medium.com/devops-react-express-%EC%95%B1-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-netlify-heroku-b238e057d920&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[TS]React,Express 풀스택 웹 앱 배포하기(Netlify, Heroku) | by PEPPERMINT100 | Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://azure.microsoft.com/ko-kr/resources/cloud-computing-dictionary/what-is-paas&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;PaaS란? Platform as a Service | Microsoft Azure&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React에서 Open API XML 데이터 파싱하기 (with Express)]]></title><description><![CDATA[React 환경에서 XML로 구성된 공공데이터포털 API를 Express 서버로 파싱하기 XML 형식의 Open API 예전 프로젝트에서 공공데이터포털에 있는 XML(Extensible Markup Language) 형식의 API…]]></description><link>https://yhuj79.github.io/React/230104/</link><guid isPermaLink="false">https://yhuj79.github.io/React/230104/</guid><pubDate>Wed, 04 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;React 환경에서 XML로 구성된 공공데이터포털 API를 Express 서버로 파싱하기&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;XML 형식의 Open API&lt;/h2&gt;
&lt;p&gt;예전 프로젝트에서 &lt;a href=&quot;https://www.data.go.kr&quot; target=&quot;_blank&quot;&gt;공공데이터포털&lt;/a&gt;에 있는 &lt;strong&gt;XML(Extensible Markup Language)&lt;/strong&gt; 형식의 API를 다룬 적이 있다. 데이터를 이용하여 원하는 형태로 구현하는 것 까지는 문제가 없었지만, &lt;strong&gt;GitHub Page&lt;/strong&gt;, &lt;strong&gt;Vercel&lt;/strong&gt; 등으로 프로젝트를 배포했을 경우 갖가지 문제에 부딪혔다. 특히 공공데이터포털에서 제공하는 API는 대다수가 XML 형식으로 되어 있다. 이 문제의 해결법은 아래에 설명해 놓은 방법만이 정답인 것은 아니겠지만 비교적 괜찮은 방법으로 성공한 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;에 새 저장소를 만들고, 생성한 저장소를 클론 후 &lt;code&gt;react-app&lt;/code&gt;을 만들었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230104/230104-01.png&quot; alt=&quot;230104-01&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ git clone https://github.com/(github-id)/open-api-tutorial.git
$ cd open-api-tutorial
$ yarn create react-app open-api-tutorial
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;생성한 react-app에서 &lt;code&gt;axios&lt;/code&gt;를 설치한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ cd open-api-tutorial
$ yarn add axios
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;공공데이터포털에서 제공하는 국내 코로나 바이러스 현황을 받아볼 수 있는 API를 사용하였다.&lt;br&gt;
&lt;a href=&quot;https://www.data.go.kr/bbs/ntc/selectNotice.do?originId=NOTICE_0000000002849&quot; target=&quot;_blank&quot;&gt;공공데이터활용지원센터_보건복지부 코로나19 감염 현황 (현재 폐기됨)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XML&lt;/strong&gt;은 &lt;strong&gt;Extensible Markup Language&lt;/strong&gt; 의 약자로, HTML과 비슷한 구조를 가진다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230104/230104-02.png&quot; alt=&quot;230104-02&quot;&gt;&lt;/p&gt;
&lt;p&gt;App.js에서 데이터를 콘솔에 출력하였다. 이 API는 &lt;strong&gt;startCreateDt&lt;/strong&gt;, &lt;strong&gt;endCreateDt&lt;/strong&gt; 파라미터로 데이터 범위를 지정할 수 있는데, &lt;code&gt;Moment.js&lt;/code&gt;, &lt;code&gt;Day.js&lt;/code&gt;와 같은 라이브러리를 사용하면 현재 날짜를 받아서 원하는 기간의 데이터를 받아볼 수 있다. 우선 테스트를 위해 날짜 라이브러리는 사용하지 않고 임의의 날짜를 입력해 주었다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// src/App.js
import logo from &quot;./logo.svg&quot;
import &quot;./App.css&quot;
import { useEffect } from &quot;react&quot;
import axios from &quot;axios&quot;

function App() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      try {
        const res = await axios.get(
          `http://openapi.data.go.kr/openapi/service/rest/Covid19/getCovid19InfStateJson?serviceKey=${process.env.REACT_APP_API_KEY}&amp;#x26;pageNo=1&amp;#x26;numOfRows=10&amp;#x26;startCreateDt=20221212&amp;#x26;endCreateDt=20230103`
        )
        console.log(res.data.response.body.items.item)
      } catch (e) {
        console.log(e)
      }
    }
    fetchData()
  }, [])

  return (
    &amp;#x3C;div className=&quot;App&quot;&gt;
      &amp;#x3C;header className=&quot;App-header&quot;&gt;
        &amp;#x3C;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;
        &amp;#x3C;p&gt;
          Edit &amp;#x3C;code&gt;src/App.js&amp;#x3C;/code&gt; and save to reload.
        &amp;#x3C;/p&gt;
        &amp;#x3C;a
          className=&quot;App-link&quot;
          href=&quot;https://reactjs.org&quot;
          target=&quot;_blank&quot;
          rel=&quot;noopener noreferrer&quot;
        &gt;
          Learn React
        &amp;#x3C;/a&gt;
      &amp;#x3C;/header&gt;
    &amp;#x3C;/div&gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;react-app에 &lt;code&gt;.env&lt;/code&gt;파일을 생성하고 다음과 같이 API KEY를 입력한다. GitHub에 &lt;code&gt;.env&lt;/code&gt;파일이 올라가지 않게 &lt;code&gt;.gitignore&lt;/code&gt;에 .env도 추가한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# .env
REACT_APP_API_KEY=APIKEY입력하는곳

# .gitignore
...
...
.env
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;yarn start&lt;/code&gt;로 실행시켜 확인하면 다음과 같이 지정한 범위의 코로나 데이터를 확인할 수 있다.&lt;br&gt;
(콘솔에 두 번 출력되는 이유는 React의 &lt;strong&gt;StrictMode&lt;/strong&gt; 때문이다.)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230104/230104-03.png&quot; alt=&quot;230104-03&quot;&gt;&lt;/p&gt;
&lt;p&gt;작성한 그대로 &lt;strong&gt;GitHub Page&lt;/strong&gt;에 배포하여 확인해 보자. &lt;code&gt;gh-pages&lt;/code&gt;를 설치한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add --dev gh-pages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt; 내용을 추가 후, &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;deploy&lt;/code&gt;를 하고 나면&lt;br&gt;
&lt;code&gt;https://(github-id).github.io/open-api-tutorial&lt;/code&gt;에서 페이지를 확인할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;// package.json scripts에 추가
&quot;predeploy&quot;: &quot;yarn build&quot;,
&quot;deploy&quot;: &quot;gh-pages -d build&quot;

// package.json에 따로 추가
&quot;homepage&quot;: &quot;https://(github-id).github.io/open-api-tutorial&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn build
$ yarn deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230104/230104-04.png&quot; alt=&quot;230104-04&quot;&gt;&lt;/p&gt;
&lt;p&gt;페이지는 잘 나타났으나 데이터에서 &lt;code&gt;Mixed Content Error&lt;/code&gt;가 발생한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230104/230104-05.png&quot; alt=&quot;230104-05&quot;&gt;&lt;/p&gt;
&lt;p&gt;암호화된 HTTPS 페이지에 암호화되지 않은 HTTP를 통해 요청할 때 발생하는 에러라고 한다.&lt;br&gt;
public/index.html에 HTTPS 변환 메타태그를 추가 후 다시 확인해 보면...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;meta
  http-equiv=&quot;Content-Security-Policy&quot;
  content=&quot;upgrade-insecure-requests&quot;
/&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230104/230104-06.png&quot; alt=&quot;230104-06&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ERR_CERT_COMMON_NAME_INVALID&lt;/code&gt; 에러가 등장했다. SSL 인증서 관련 문제라고 한다. 이 프로젝트에서는 HTTPS 변환된 API가 존재하지 않아 에러가 발생했다는 뜻으로 보여진다.&lt;/p&gt;
&lt;p&gt;따라서 다른 방법으로 구상한 게 웹 서버에 데이터를 파싱 후 웹 앱에 뿌리는 것이다.&lt;/p&gt;
&lt;h2&gt;Express Web Server&lt;/h2&gt;
&lt;p&gt;프로젝트 디렉터리에 server 디렉터리를 만들고 다음 라이브러리들을 설치했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add express  # Node.js 서버 프레임워크
$ yarn add request  # HTTP 네트워크 요청
$ yarn add xml-js   # XML JSON 변환
$ yarn add cors     # Node.js CORS middleware
$ yarn add dotenv   # Node.js에서 환경변수 사용
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;server.js와 환경 변수 파일을 작성한다. react-app처럼 &lt;code&gt;.gitignore&lt;/code&gt;을 만들고 &lt;code&gt;node_modules&lt;/code&gt; , &lt;code&gt;.env&lt;/code&gt;를 추가한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// server/server.js
require(&quot;dotenv&quot;).config()
const express = require(&quot;express&quot;)
const app = express()
const cors = require(&quot;cors&quot;)
const request = require(&quot;request&quot;)
const convert = require(&quot;xml-js&quot;)
const PORT = process.env.PORT || 5000

app.use(cors())

app.get(&quot;/api/data&quot;, (req, res) =&gt; {
  request(
    {
      url: `http://openapi.data.go.kr/openapi/service/rest/Covid19/getCovid19InfStateJson?serviceKey=${process.env.REACT_APP_API_KEY}&amp;#x26;pageNo=1&amp;#x26;numOfRows=10&amp;#x26;startCreateDt=20221212&amp;#x26;endCreateDt=20230103`,
      method: &quot;GET&quot;,
    },
    (error, response, body) =&gt; {
      const xmlToJson = convert.xml2json(body, { compact: true, space: 4 }) // xml to json
      res.send(xmlToJson)
    }
  )
})

app.listen(PORT, () =&gt; {
  console.log(`Listening on port ${PORT}`)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# .env
REACT_APP_API_KEY=APIKEY입력하는곳

# .gitignore
.env
/node_modules
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;터미널에서 server 디렉터리로 이동, &lt;code&gt;node server.js&lt;/code&gt;를 실행하면 5050포트로 Express 서버가 실행된다. &lt;code&gt;http://localhost:5050/api/data&lt;/code&gt;에서 API를 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/230104/230104-07.png&quot; alt=&quot;230104-07&quot;&gt;&lt;/p&gt;
&lt;p&gt;코드 수정마다 매번 서버 재부팅을 하는 것은 귀찮기 때문에 &lt;code&gt;nodemon&lt;/code&gt;을 설치하고, 명령어 간소화를 위해 &lt;code&gt;package.json&lt;/code&gt;에 &lt;code&gt;scripts&lt;/code&gt;를 추가한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add nodemon
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;// server/package.json
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;nodemon server.js&quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 &lt;code&gt;yarn dev&lt;/code&gt; 명령어로 서버를 실행시킬 수 있다.&lt;/p&gt;
&lt;p&gt;만든 서버를 Heroku에 deploy 하는 것까지 글을 작성했지만 너무 글이 길어진 탓에 생긴 blog build의 문제거나, 페이지 색인 생성의 문제인지 search console에 url이 등록되지 않는 이슈가 생겼다. Heroku 배포 관련 내용은 다음 포스트에 써야할 듯 하다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@vvsogi/%EA%B3%B5%EA%B3%B5-%EB%8D%B0%EC%9D%B4%ED%84%B0-API-React%EC%97%90%EC%84%9C-XML%EC%97%90%EC%84%9C-JSON-%EB%B3%80%ED%99%98&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;공공 데이터 API React에서 XML에서 JSON 변환!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/harrythegreat/node-js%EC%97%90%EC%84%9C-request-js-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-28744c52f68d&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Node.js에서 Request.js 사용하기. 네트워크 더 간결하게 작성하자! | by Harry The Great | 해리의 유목코딩 | Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://krpeppermint100.medium.com/devops-react-express-%EC%95%B1-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-netlify-heroku-b238e057d920&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[TS]React,Express 풀스택 웹 앱 배포하기(Netlify, Heroku) | by PEPPERMINT100 | Medium&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Next.js REST API 세팅하기 (with Prisma, PlanetScale)]]></title><description><![CDATA[Next.js, Prisma, PlanetScale을 통해 초기 개발 환경 구축, Axios로 간단한 get, post 테스트 Create Next App Next.js는 React 기반의, React를 품은 프레임워크이다. SSR (Server…]]></description><link>https://yhuj79.github.io/Next/221213/</link><guid isPermaLink="false">https://yhuj79.github.io/Next/221213/</guid><pubDate>Tue, 13 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Next.js, Prisma, PlanetScale을 통해 초기 개발 환경 구축, Axios로 간단한 get, post 테스트&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Create Next App&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Next.js&lt;/strong&gt;는 React 기반의, React를 품은 프레임워크이다. &lt;strong&gt;SSR (Server Side Rendering)&lt;/strong&gt; 을 지원하여 &lt;strong&gt;SEO (Search Engine Optimize)&lt;/strong&gt; 에 수월하다. 소스코드 안에 HTML이 남아있는 상태로 렌더링되기 때문에 네트워크 지연과 같은 상황에도 최소한 텅 빈 화면을 볼 일은 없을 것이다.&lt;/p&gt;
&lt;p&gt;Next App은 기존 React에서 사용했던 Boilerplate와 유사한 명령어로 설치할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn create next-app 프로젝트명
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Planetscale&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Planetscale&lt;/strong&gt;은 비테스(Vitess) 기반의 Mysql을 호환하는 DB로, 동시 연결도 거의 무제한에 가깝게 할 수 있다. 초기에 별도 결제 수단 등록 없이 무료로 사용 가능하며, 요금제 한도 초과 시 스케일러 요금제로 전환할 수 있다.&lt;/p&gt;
&lt;p&gt;회원 가입 후 DB 생성을 진행. (Git으로 Login 가능)&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;img alt=&apos;pscale1&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/221213/pscale1.png&apos;&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;img alt=&apos;pscale2&apos; src=&apos;https://raw.githubusercontent.com/yhuj79/blog-assets/main/221213/pscale2.png&apos;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;지역은 Tokyo로 설정했다. 설치는 window의 경우 scoop, mac의 경우 brew를 사용한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# window (scoop)
$ scoop bucket add pscale https://github.com/planetscale/scoop-bucket.git
$ scoop update pscale

# mac (brew)
$ brew install planetscale/tap/pscale
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치된 pscale로 로그인 인증을 마치면 이제 DB를 연결할 준비가 되었다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ pscale auth login
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Prisma&lt;/h2&gt;
&lt;p&gt;관계형 데이터베이스를 자동으로 Mapping해줄 ORM으로 &lt;strong&gt;Prisma&lt;/strong&gt;를 사용했다. 먼저 처음에 create next-app로 생성했던 프로젝트 내에 prisma를 설치한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ npm i @prisma/client
$ npm i -D prisma

$ npx prisma init # Setup Prisma for your app
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치한 PrismaClient를 사용하기 위한 몇 가지 과정이 필요한데, 먼저 스키마 파일을 정의해야 한다. 프로젝트의 &lt;code&gt;/prisma/schema.prisma&lt;/code&gt;를 다음처럼 수정한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;generator client {
  provider = &quot;prisma-client-js&quot;
  previewFeatures = [&quot;referentialIntegrity&quot;]
}

datasource db {
  provider = &quot;mysql&quot;
  url      = env(&quot;DATABASE_URL&quot;)
  referentialIntegrity = &quot;prisma&quot; // prisma 참조 무결성 기능 (키 사용 설정)
}

// Posting model 생성
model Posting{
  id Int @id @default(autoincrement()) // id (자동으로 증가하는 값으로 설정)
  title String // title
  content String // content
  createdAt DateTime @default(now()) // 현재 시간을 설정
  updatedAt DateTime @updatedAt // update된 시간을 설정
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;prisma schema를 push하는 작업을 진행하고, pscale command로 DB와 연결하면 다음과 같이 주소를 알려준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ npx prisma db push

$ pscale connect DB명
Tried address 127.0.0.1:3306, but it\&apos;s alreadyㅤinㅤuse. Picking up a random port ...
Secure connection to database DB명 and branch main is established!.

Local address to connect your application: 127.0.0.1:53936
(press ctrl-c to quit)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로젝트 내에 .env 파일을 만들고 위 주소를 입력하면 세팅은 거의 끝났다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;DATABASE_URL = &quot;mysql://127.0.0.1:53936/DB명&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Prisma Client&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Next.js&lt;/strong&gt;는 Express 같은 도구 없이 Bankend API를 쉽게 다룰 수 있는 기능을 제공한다. &lt;code&gt;pages/api&lt;/code&gt; 내에 파일로 작성하여 주소로 사용한다.&lt;/p&gt;
&lt;p&gt;먼저 DB를 읽어드리기 위한 &lt;code&gt;read.js&lt;/code&gt;를 생성했다. PrismaClient 모듈을 불러오고 &lt;code&gt;async, await&lt;/code&gt; 그리고 &lt;code&gt;findMany&lt;/code&gt; 메서드를 사용하여 데이터를 반환한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// pages/api/read.js
import { PrismaClient } from &quot;@prisma/client&quot;

const prisma = new PrismaClient()

export default async function ApiRead(req, res) {
  const posting = await prisma.posting.findMany()
  res.json(posting)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DB에 데이터를 create하기 위해 &lt;code&gt;post.js&lt;/code&gt;를 작성했다. 어떤 값을 담아 전달하는 그러한 과정 없이 간단하게 제목 &lt;code&gt;&quot;First Post&quot;&lt;/code&gt;, 내용 &lt;code&gt;&quot;Next JS 첫번째 포스트 입니다.&quot;&lt;/code&gt;로 전달하려고 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// pages/api/post.js
import { PrismaClient } from &quot;@prisma/client&quot;

const prisma = new PrismaClient()

export default async function ApiPost(req, res) {
  const posting = await prisma.posting.create({
    data: {
      title: &quot;First Post&quot;,
      content: &quot;Next JS 첫번째 포스트 입니다.&quot;,
    },
  })
  res.json({ ok: true })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;디렉터리 &lt;code&gt;index.js&lt;/code&gt;로 돌아와서, API를 테스트할 JSX를 작성했다. Add Post 버튼으로 &lt;code&gt;/api/post&lt;/code&gt;를 실행하면 받은 데이터를 &lt;code&gt;JSON.stringify()&lt;/code&gt;로 아래에 나타나게끔 했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add axios
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// /index.js
import Axios from &quot;axios&quot;
import { useState, useEffect } from &quot;react&quot;

export default function Home() {
  const [posting, setPosting] = useState({})

  useEffect(() =&gt; {
    Axios.get(&quot;/api/read&quot;).then((res) =&gt; {
      setPosting(res.data)
      console.log(res.data)
    })
  }, [posting])

  async function onClick() {
    await Axios.post(&quot;/api/post&quot;)
  }

  return (
    &amp;#x3C;div style={{ margin: &quot;30px&quot; }}&gt;
      &amp;#x3C;h1&gt;Posting&amp;#x3C;/h1&gt;
      &amp;#x3C;button onClick={onClick}&gt;Add Post&amp;#x3C;/button&gt;
      &amp;#x3C;p&gt;{JSON.stringify(posting)}&amp;#x3C;/p&gt;
    &amp;#x3C;/div&gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/221213/addpost.png&quot; alt=&quot;addpost&quot;&gt;&lt;/p&gt;
&lt;p&gt;Add Post를 눌러 보면 Planetscale에 잘 반영이 된다.&lt;/p&gt;
&lt;h2&gt;Prisma Studio&lt;/h2&gt;
&lt;p&gt;Prisma는 데이터베이스의 GUI Tool을 제공한다. &lt;code&gt;npx prisma studio&lt;/code&gt;를 사용하여 &lt;code&gt;localhost:5555&lt;/code&gt;에서 작성한 model을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/221213/prismastudio.png&quot; alt=&quot;prismastudio&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.prisma.io/docs/concepts/components/prisma-client&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Prisma Client | Next-generation ORM for Node.js &amp;#x26; TypeScript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLZKTXPmaJk8Lx3TqPlcEAzTL8zcpBz7NP&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Next js 강좌 | 코딩앙마&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kir93.tistory.com/m/entry/NextJS-API-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-feat-Prisma-Planetscale&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;NextJS API 활용하기 (feat. Prisma, Planetscale)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ts2ree.tistory.com/194?category=535825&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;데이터 유지를 prisma 를 통해 하자 (CRUD)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.itworld.co.kr/news/207029&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;플래닛스케일 리뷰 | 수평 확장 가능한 마이SQL 호환 서버리스 DB 플랫폼 - ITWorld Korea&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://defineall.tistory.com/872&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[Prisma] Prisma Client란? / 사용법&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Jest React 컴포넌트/스냅샷 테스트]]></title><description><![CDATA[RTL(React Testing Library)은 React 테스팅을 위해 React App에 내장되어 있는 시스템이다. RTL에는 Jest가 포함되어 있어 이를 통해 기능 테스트를 진행할 수 있다. Jest 컴포넌트 테스트 테스팅 라이브러리 Jest…]]></description><link>https://yhuj79.github.io/Jest/221129/</link><guid isPermaLink="false">https://yhuj79.github.io/Jest/221129/</guid><pubDate>Tue, 29 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;RTL(React Testing Library)은 React 테스팅을 위해 React App에 내장되어 있는 시스템이다. RTL에는 Jest가 포함되어 있어 이를 통해 기능 테스트를 진행할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Jest 컴포넌트 테스트&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:8000/blog/221022/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;테스팅 라이브러리 Jest 사용하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난 Jest 포스팅에 이어서 Jest를 사용하여 React 프로젝트를 테스트해 보기로 했다.&lt;/p&gt;
&lt;p&gt;먼저 &lt;code&gt;create react-app&lt;/code&gt;으로 테스트를 진행할 React 프로젝트를 생성했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;yarn create react-app jest-tutorial
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;React는 기본 테스트 도구로 Jest를 사용하기 때문에 별도 설치 없이 사용할 수 있고, src 디렉터리에 App.test.js가 존재하는 걸 확인할 수 있다. learn react 링크의 렌더링을 테스트하는 코드가 작성되어 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { render, screen } from &quot;@testing-library/react&quot;
import App from &quot;./App&quot;

test(&quot;renders learn react link&quot;, () =&gt; {
  render(&amp;#x3C;App /&gt;)
  const linkElement = screen.getByText(/learn react/i)
  expect(linkElement).toBeInTheDocument()
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;yarn test&lt;/code&gt;를 해보면 다음과 같이 결과가 출력된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn test
yarn run v1.22.18
$ react-scripts test
 PASS  src/App.test.js
  ✓ renders learn react link (16 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.785 s
Ran all test suites related to changed files.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다른 컴포넌트에서 테스트를 진행하기 위해 기존 테스트 코드를 삭제하고, Container 컴포넌트와 Container.test.js를 작성했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/221129/jestsrc.png&quot; alt=&quot;jestsrc&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// App.js

import Container from &quot;./Container&quot;

const id = null

function App() {
  return (
    &amp;#x3C;div&gt;
      &amp;#x3C;Container id={id} /&gt;
    &amp;#x3C;/div&gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Container.js

// 삼항 연산자로 id 값이 있는 경우 id를 출력, 그렇지 않으면 h1 태그 출력
function Container({ id }) {
  return id ? &amp;#x3C;h1&gt;{id}&amp;#x3C;/h1&gt; : &amp;#x3C;h1&gt;id가 발견되지 않습니다.&amp;#x3C;/h1&gt;
}

export default Container
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Container.test.js

import { render, screen } from &quot;@testing-library/react&quot;
import Container from &quot;./Container&quot;

const id = 123

// id 값이 있는지 검사하는 테스트
test(&quot;id 값 테스트&quot;, () =&gt; {
  const el = &amp;#x3C;Container id={id} /&gt;
  expect(el).toMatchSnapshot()
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 검사 성공
 PASS  src/Container.test.js
  ✓ id 값 테스트 (1 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   1 passed, 1 total
Time:        0.229 s, estimated 1 s
Ran all test suites.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;SnapShot&lt;/h2&gt;
&lt;p&gt;여러 가지 테스트를 추가할 수 있는데, id 값 확인과 함께 id가 123이 맞는지 확인하는 테스트도 해볼 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { render, screen } from &quot;@testing-library/react&quot;
import Container from &quot;./Container&quot;

const id = 123

test(&quot;id 값 테스트&quot;, () =&gt; {
  const el = &amp;#x3C;Container id={id} /&gt;
  expect(el).toMatchSnapshot()
})

test(&quot;id가 123인지 검사&quot;, () =&gt; {
  render(&amp;#x3C;Container id={id} /&gt;)
  const containerElement = screen.getByText(/123/i)
  expect(containerElement).toBeInTheDocument()
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# if id = 123
 PASS  src/Container.test.js
  ✓ id 값 테스트 (2 ms)
  ✓ id가 123인지 검사 (12 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   1 passed, 1 total
Time:        0.263 s, estimated 1 s
Ran all test suites related to changed files.

# if id = 200
FAIL  src/Container.test.js
  ✕ id 값 테스트 (3 ms)
  ✕ id가 123인지 검사 (13 ms)

  ● id 값 테스트

    expect(received).toMatchSnapshot()

    Snapshot name: `id 값 테스트 1`

    - Snapshot  - 1
    + Received  + 1

      &amp;#x3C;Container
    -   id={123}
    +   id={200}
      /&gt;

       6 | test(&quot;id 값 테스트&quot;, () =&gt; {
       7 |   const el = &amp;#x3C;Container id={id} /&gt;;
    &gt;  8 |   expect(el).toMatchSnapshot();
         |              ^
       9 | });
      10 |
      11 | test(&quot;id가 123인지 검사&quot;, () =&gt; {

      at Object.&amp;#x3C;anonymous&gt; (src/Container.test.js:8:14)

  ● id가 123인지 검사

    TestingLibraryElementError: Unable to find an element with the text: /123/i. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

    Ignored nodes: comments, script, style
    &amp;#x3C;body&gt;
      &amp;#x3C;div&gt;
        &amp;#x3C;h1&gt;
          200
        &amp;#x3C;/h1&gt;
      &amp;#x3C;/div&gt;
    &amp;#x3C;/body&gt;

      11 | test(&quot;id가 123인지 검사&quot;, () =&gt; {
      12 |   render(&amp;#x3C;Container id={id} /&gt;);
    &gt; 13 |   const containerElement = screen.getByText(/123/i);
         |                                   ^
      14 |   expect(containerElement).toBeInTheDocument();
      15 | });
      16 |

      at Object.getElementError (node_modules/@testing-library/dom/dist/config.js:40:19)
      at Object.&amp;#x3C;anonymous&gt; (src/Container.test.js:13:35)

 › 1 snapshot failed.
Snapshot Summary
 › 1 snapshot failed from 1 test suite. Inspect your code changes or press `u` to update them.

Test Suites: 1 failed, 1 total
Tests:       2 failed, 2 total
Snapshots:   1 failed, 1 total
Time:        0.47 s, estimated 1 s
Ran all test suites related to changed files.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;두 번째 테스트에서 id 값 테스트가 값 200이 입력되었음에도 실패하게 되는 이유는 첫 번째 테스트에서 Snapshot이 123으로 입력되었기 때문이다. src 디렉터리에 &lt;strong&gt;snapshots&lt;/strong&gt;가 생성되어 있는 것을 볼 수 있는데, 이 곳에 스냅샷이 업데이트 되어 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-snap&quot;&gt;// Container.test.js.snap

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`id 값 테스트 1`] = `
&amp;#x3C;Container
  id={123}
/&gt;
`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;id 값이 123으로 기록되었기 때문에 이외에 다른 id 값이 입력되면 실패했음을 알린 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; › 1 snapshot failed from 1 test suite. Inspect your code changes or press `u` to update them.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;따라서 새로 입력한 값을 스냅샷에 업데이트 하고 싶으면 u 키를 눌러 반영하거나, 계속 테스트를 진행하게끔 선택할 수 있다.&lt;/p&gt;
&lt;p&gt;사용자의 판단에 따라 스냅샷을 업데이트하며 테스트를 진행하면 될 것 같다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://jestjs.io/docs/tutorial-async&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;An Async Example · Jest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@mokyoungg/Jest-Jest%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-React-Code-Test-%EA%B8%B0%EC%B4%88&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[Jest] Jest 기초&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLZKTXPmaJk8L1xCg_1cRjL5huINlP2JKt&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Jest 강좌 | 코딩앙마&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2021-10-22-react-testing-library/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;초심자를 위한 React Testing Library&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@velopert/react-testing-library#queries&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;react-testing-library 를 사용한 리액트 컴포넌트 테스트&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[로컬 서버 외부에서 접속하기]]></title><description><![CDATA[루프백 주소(Loopback Address)로 설정된 개발 서버를 다른 디바이스에서 테스트하고 싶을 경우 IPv4 주소:포트번호를 입력하여 접속하는 방법에 대하여 Loopback Address 개발을 하다 보면 자주 만나게 되는 127.0.0.…]]></description><link>https://yhuj79.github.io/React/221101/</link><guid isPermaLink="false">https://yhuj79.github.io/React/221101/</guid><pubDate>Tue, 01 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;루프백 주소(Loopback Address)로 설정된 개발 서버를 다른 디바이스에서 테스트하고 싶을 경우 IPv4 주소:포트번호를 입력하여 접속하는 방법에 대하여&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Loopback Address&lt;/h2&gt;
&lt;p&gt;개발을 하다 보면 자주 만나게 되는 &lt;code&gt;127.0.0.1&lt;/code&gt;은 특수 목적을 지닌 IPv4 주소로,
&lt;strong&gt;루프백 주소(Loopback Address)&lt;/strong&gt;라고 한다. 자기 자신을 가리키기 위한 목적으로 쓰기 위해 예약된 IP 주소이기 때문에 패킷을 외부로 전송하지 않고, 자신이 송신한 패킷을 그대로 자신이 수신한다. 따라서 루프백 주소를 통해 다른 장치와 통신은 불가능하다. 또한 &lt;code&gt;localhost&lt;/code&gt;는 &lt;code&gt;127.0.0.1&lt;/code&gt;로 Redirect 설정이 되어 있기 때문에 &lt;code&gt;127.0.0.1:3000&lt;/code&gt;과 같다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;create-react-app&lt;/code&gt;으로 생성한 앱은 &lt;code&gt;npm start&lt;/code&gt;, &lt;code&gt;npx start&lt;/code&gt;, &lt;code&gt;yarn start&lt;/code&gt; 등의 명령어를 통해 &lt;code&gt;localhost:3000&lt;/code&gt;에 프로젝트를 실행시킨다. 이 로컬 서버에서 실시간으로 코드 수정 사항을 확인할 수 있다. 다양한 디바이스 환경의 테스트 또한 Safari의 &lt;strong&gt;응답형 디자인 모드&lt;/strong&gt;나 Chrome 개발자 도구 &lt;strong&gt;Toggle device Toolar&lt;/strong&gt;로 가능하긴 하지만, 종종 다른 디바이스에서 직접 테스트를 해봐야 할 경우가 생긴다.&lt;/p&gt;
&lt;h2&gt;IPv4 주소 통해 접속하기&lt;/h2&gt;
&lt;p&gt;우선 이 방법은 개발 PC와 디바이스가 같은 네트워크 환경인 경우 사용이 가능하다. 먼저 터미널에서 &lt;code&gt;ipconfig&lt;/code&gt;(mac은 &lt;code&gt;ipconfig getifaddr en0&lt;/code&gt;)를 입력하여 IPv4 주소를 확인한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ ipconfig getifaddr en0

xxx.xxx.xx.xx   # IPv4 주소
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모바일 환경에서 접속을 시도한다면, 와이파이 연결을 확인한 후 &lt;code&gt;ip주소:포트번호&lt;/code&gt;를 입력하여 접속한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xxx.xxx.xx.xx:3000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;명령어 변형&lt;/h2&gt;
&lt;p&gt;기존의 &lt;code&gt;yarn start&lt;/code&gt;로 실행하는 것 이외에 &lt;code&gt;HOST=xxx.xxx.xx.xx yarn start&lt;/code&gt;로 실행하면 localhost로 열리는 대신 바로 IPv4주소가 포함되어 앱이 실행된다. 애플 작업 환경일 경우 mac과 iPhone 연속성에 의해 주소를 바로 모바일에 붙여넣을 수 있어 이 방법이 더 편하다.&lt;/p&gt;
&lt;p&gt;아래처럼 package.json의 scripts를 수정하고 &lt;code&gt;yarn ipv4&lt;/code&gt;로 실행할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;ipv4&quot;: &quot;HOST=xxx.xxx.xx.xx react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Gatsby Develop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Gatsby&lt;/code&gt;는 React 기반으로 만들어진 정적 사이트 생성 프레임워크로, React 이해도가 있다면 포트폴리오, 개인 블로그 등을 보다 편하게 개발할 수 있다. &lt;code&gt;gatsby develop&lt;/code&gt; 명령어를 통해 개발 서버를 실행할 수 있는데, -H 옵션을 사용하여 실행하면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ gatsby develop -H xxx.xxx.xx.xx

You can now view gatsby-projectㅤin
the browser.
⠀
  http://xxx.xxx.xx.xx:8000/
⠀
View GraphiQL, an in-browser IDE, to
explore your site\&apos;s data and schema
⠀
  http://xxx.xxx.xx.xx:8000/___graphql
⠀
Note that the development build is not
optimized.
To create a production build, use gatsby
build
⠀
success Building development bundle -
2.730s
success Writing page-data.json files to
public directory - 0.035s - 3/3 84.59/s
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://woo-dev.tistory.com/190&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;IP 주소 127.0.0.1 의 의미 - 루프백(loopback) or 로컬호스트(localhost) 주소&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Loopback&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Loopback - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@lky9303/127.0.0.1-%EA%B3%BC-localhost%EC%9D%98-%EC%B0%A8%EC%9D%B4&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;127.0.0.1 과 localhost의 차이&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[테스팅 라이브러리 Jest 사용하기]]></title><description><![CDATA[많이 사용되고 있는 테스트 도구인 Jest는 Zero Configuration 철학을 가지고 있어 별도의 설정 없이 빠르게 테스트 케이스를 작성할 수 있다. Jest란 무엇인가? Jest는 React를 만든 Facebook…]]></description><link>https://yhuj79.github.io/Jest/221022/</link><guid isPermaLink="false">https://yhuj79.github.io/Jest/221022/</guid><pubDate>Sat, 22 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;많이 사용되고 있는 테스트 도구인 Jest는 Zero Configuration 철학을 가지고 있어 별도의 설정 없이 빠르게 테스트 케이스를 작성할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Jest란 무엇인가?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Jest&lt;/strong&gt;는 React를 만든 Facebook에서 개발한 테스팅 프레임워크(Testing Framework)이다. Babel, TypeScript, Node, React, Angular, Vue 등을 사용하는 프로젝트에서 작동하며, 프로젝트 내의 별도 설정이 필요 없이 바로 시작할 수 있는 Zero Configuration 철학을 가지고 있다. 테스트 코드의 모양이 직관적이고 문서화가 잘 이루어져 있어 많이 활용되고 있다.&lt;/p&gt;
&lt;h2&gt;간단한 테스트 해보기&lt;/h2&gt;
&lt;p&gt;간단히 사용해보기 위해 작은 프로젝트 디렉터리를 만들고 Jest를 설치해 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ npm init -y   # default package.json 생성

Wrote to ~/jest-tutorial/package.json:
{
  &quot;name&quot;: &quot;jest-tutorial&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;#x26;&amp;#x26; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}

&gt; npm install jest --save-dev   # jest 설치
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Jest를 설치한 후 &lt;code&gt;package.json&lt;/code&gt;의 test scripts를 jest로 수정한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;jest-tutorial&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;jest&quot; // 다음과 같이 수정
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;jest&quot;: &quot;^29.2.1&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;디렉터리에 테스트 대상이 될 함수 &lt;code&gt;funcAdd.js&lt;/code&gt;를 생성했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const funcAdd = {
  // 두 개의 인수를 받아 그 합을 리턴
  add: (num1, num2) =&gt; num1 + num2,
}

module.exports = funcAdd // 테스트 파일에서 사용할 수 있도록 내보내기
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;함수 파일 작성을 마쳤다면 이제 테스트 파일을 작성할 차례다. &lt;code&gt;funcAdd.test.js&lt;/code&gt;를 만들고 테스트 코드를 다음과 같이 작성하였다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const funcAdd = require(&quot;./funcAdd&quot;) // funcAdd 불러오기

test(&quot;1 = 1&quot;, () =&gt; {
  expect(1).toBe(1) // expect: 검증값 , toBe: 기대값
})

test(&quot;2 + 3 = 5&quot;, () =&gt; {
  expect(funcAdd.add(2, 3)).toBe(5) // funcAdd.add 성공 케이스
})

test(&quot;3 + 3 = 5&quot;, () =&gt; {
  expect(funcAdd.add(3, 3)).toBe(5) // funcAdd.add 실패 케이스
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;npm test&lt;/code&gt;를 실행하여 테스트 결과를 확인해보자. &lt;code&gt;npm test&lt;/code&gt;는 프로젝트 내에서 &lt;code&gt;~.test.js&lt;/code&gt;와 같은 형식으로 되어 있거나, &lt;code&gt;__tests__&lt;/code&gt; 디렉터리 안에 있는 모든 파일을 테스트 파일로 인식하고 테스트를 실행시킨다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ npm test

&gt; jest-tutorial@1.0.0 test
&gt; jest

 FAIL  ./funcAdd.test.js
  ✓ 1 =&gt; 1 (1 ms)
  ✓ 2 + 3 = 5
  ✕ 3 + 3 = 5 (1 ms)

  ● 3 + 3 = 5

    expect(received).toBe(expected) // Object.is equality

    Expected: 5
    Received: 6

      10 |
      11 | test(&quot;3 + 3 = 5&quot;, () =&gt; {
    &gt; 12 |   expect(funcAdd.add(3, 3)).toBe(5);
         |                             ^
      13 | });
      14 |

      at Object.toBe (funcAdd.test.js:12:29)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 2 passed, 3 total
Snapshots:   0 total
Time:        0.189 s
Ran all test suites.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아래 &lt;code&gt;Tests&lt;/code&gt;에서 총 3개 중 2개 성공, 1개 실패했음을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;세 번째 테스트 함수를 아래처럼 변경하여 테스트를 진행해볼 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;test(&quot;3 + 3 ≠ 5&quot;, () =&gt; {
  expect(funcAdd.add(3, 3)).not.toBe(5) // not을 사용
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ npm test

&gt; jest-tutorial@1.0.0 test
&gt; jest

 PASS  ./funcAdd.test.js
  ✓ 1 =&gt; 1 (1 ms)
  ✓ 2 + 3 = 5 (1 ms)
  ✓ 3 + 3 ≠ 5

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        0.166 s, estimated 1 s
Ran all test suites.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이처럼 Jest는 여러가지 방법으로 값을 테스트할 수 있게 다양한 &lt;code&gt;matchers&lt;/code&gt;를 지원한다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://jestjs.io/docs/tutorial-async&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;An Async Example · Jest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.daleseo.com/jest-basic/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Jest로 기본적인 테스트 작성하기 | Engineering Blog by Dale Seo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLZKTXPmaJk8L1xCg_1cRjL5huINlP2JKt&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Jest 강좌 | 코딩앙마&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lacommune.tistory.com/160&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;commune :: NPM 사용법 : npm init 다운받기/ npm install 모듈설치&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://m.blog.naver.com/ckdgh930314/221801015725&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;npm init이란? : 네이버 블로그&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[동적 타입 언어]]></title><description><![CDATA[자바스크립트는 대표적인 동적 언어로, 어떤 특정한 타입과 연결되지 않고, 따로 명시하지 않아도 모든 타입으로 유연하게 할당 및 재할당이 가능하다. 정적 타입 언어 C, C++, Java, C#, Swift…]]></description><link>https://yhuj79.github.io/Javascript/221013/</link><guid isPermaLink="false">https://yhuj79.github.io/Javascript/221013/</guid><pubDate>Thu, 13 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;자바스크립트는 대표적인 동적 언어로, 어떤 특정한 타입과 연결되지 않고, 따로 명시하지 않아도 모든 타입으로 유연하게 할당 및 재할당이 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;정적 타입 언어&lt;/h2&gt;
&lt;p&gt;C, C++, Java, C#, Swift 등의 정적 타입 언어는 &lt;strong&gt;변수를 선언할 경우 데이터 타입을 사전에 선언해야 한다.&lt;/strong&gt; 정적 타입 언어는 컴파일 시 선언한 데이터 타입에 맞는 값을 할당했는지 검사하고, 맞지 않을 경우 에러를 보낸다. 변수 선언 시점에서 타입이 결정되고, 타입을 변경할 수 없다. 이는 컴파일 시 타입을 결정하기 때문에 실행 속도가 빠르고, 타입의 일관성을 강제함으로써 안정적인 코드를 구축 가능한 이점이 있다.&lt;/p&gt;
&lt;h2&gt;동적 타입 언어&lt;/h2&gt;
&lt;p&gt;반면 자바스크립트는 동적 타입 언어이다. var, let, const로 변수를 선언하고 데이터 타입은 선언하지 않는다. &lt;strong&gt;값을 할당하는 시점에, 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다.&lt;/strong&gt; 이를 &lt;strong&gt;동적 타이핑(Dynamic Typing)&lt;/strong&gt; 이라 한다. 타입 없이 변수를 선언하기 때문에 느슨한 타입(Loosely Typed)언어로도 불린다. 동적 타입 언어는 JavaScript, Ruby, Python, PHP, SmallTalk, Lisp 등이 있다.&lt;/p&gt;
&lt;h2&gt;동적 타이핑의 장단점&lt;/h2&gt;
&lt;p&gt;동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있어 입문자가 이해하기 쉽고, 사용하기 편리하다. 또한 런타임까지 타입에 대한 결정을 끌고 갈 수 있기 때문에 많은 선택의 여지가 있다.&lt;/p&gt;
&lt;p&gt;하지만 이러한 구조가 유연성(Flexibility)은 높지만 신뢰성(Reliability)은 떨어지는 단점이 생기는데, 동적으로 결정되는 부분에 있어 프로그램이 복잡할 경우 때때로 변수 값의 추적이 어려워질 수 있다. 자바스크립트는 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다. 이러한 잘못된 예측은 코드의 양이 방대할수록 타입 에러를 찾아내기가 어려워진다.&lt;/p&gt;
&lt;h2&gt;변수를 사용할 때 주의할 사항&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1. 변수의 개수가 많아지만 오류가 발생할 확률이 높아지므로,
   꼭 필요한 경우에 한해 제한적으로 사용한다.

2. 변수의 유효 범위(Scope)는 최대한 좁게 만들어 변수의 부작용을 억제한다.

3. 전역 변수는 최대한 사용하지 않는다.

4. 상수를 사용하여 값의 변경을 억제한다.

5. 변수의 목적이나 의미를 파악할 수 있도록 네이밍하는 습관을 기른다.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;컴퓨터가 이해하는 코드는 어떤 바보도 쓸 수 있다. 하지만 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 쓴다.&lt;/p&gt;
&lt;p&gt;-- Martin Fowler&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://wikibook.co.kr/mjs/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;모던 자바스크립트 Deep Dive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;JavaScript data types and data structures - JavaScript | MDN&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTTP 헤더 분석]]></title><description><![CDATA[브라우저의 Http(Hyper Text Transfer Protocol) 헤더에서 서버와 클라이언트의 요청, 응답 과정에서 전송한 부가 정보를 확인할 수 있다. HTTP란? HTTP(Hyper Text Transfer Protocol…]]></description><link>https://yhuj79.github.io/Computer Science/221004/</link><guid isPermaLink="false">https://yhuj79.github.io/Computer Science/221004/</guid><pubDate>Tue, 04 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;브라우저의 Http(Hyper Text Transfer Protocol) 헤더에서 서버와 클라이언트의 요청, 응답 과정에서 전송한 부가 정보를 확인할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;HTTP란?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HTTP(Hyper Text Transfer Protocol)&lt;/strong&gt; 라는 영문 그대로 인터넷에서 하이퍼텍스트를 빠르게 교환하기 위한 프로토콜의 일종이다. 여기서 하이퍼텍스트는 링크를 통해 다른 문서로 이동할 수 있게 해주는 텍스트, 하이퍼링크를 나타내는 텍스트를 의미한다.&lt;/p&gt;
&lt;p&gt;HTTP는 OSI 7계층 중에 응용 계층(Application layer)의 프로토콜이며, TCP/IP Suite 위에서 작동한다. (OSI계층과 관련된 자세한 내용은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/OSI_%EB%AA%A8%ED%98%95&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;OSI_모형&lt;/a&gt; 참고.) HTTP는 인터넷 할당 번호 관리 기관(IANA)의 가이드라인에 의거하여 80번 포트를 사용하며, 요청(Request)과 응답(Response)으로 구성되어 데이터를 주고받는다. 클라이언트가 80번 포트로 요청을 보내면, 서버에서 응답을 하는 방식이다.&lt;/p&gt;
&lt;h2&gt;HTTPS란?&lt;/h2&gt;
&lt;p&gt;기존의 HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이라 비밀번호 등의 개인정보를 제 3자가 조회할 수 있었다. 이러한 문제를 해결하기 위해 HTTPS가 등장하게 되었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HyperText Transfer Protocol over Secure Socket Layer&lt;br&gt;
HTTP over TLS&lt;br&gt;
HTTP over SSL&lt;br&gt;
HTTP Secure&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;영문에서 알 수 있듯이 제 3자가 정보를 볼 수 없도록 암호화가 첨가되었다. 80번 포트가 아닌 443번 포트를 사용하며, 보안 소켓 계층(SECURE SOCKETS LAYER)을 사용한다. 이 SSL 인증서는 사용자가 사이트에서 제공하는 정보를 암호화하는데, 제 3자가 개인정보에 접근했을 경우 데이터가 이미 암호화된 상태이기 때문에 확인이 불가능하다. 전송 계층 보안(Transport Layer Security) 또한 사용되는데, 클라이언트와 서버 간의 커뮤니케이션을 암호화해준다.&lt;/p&gt;
&lt;h2&gt;네트워크 헤더&lt;/h2&gt;
&lt;p&gt;브라우저 개발자 도구의 네트워크 탭에서 헤더를 확인할 수 있는데, 요청과 응답의 부가적인 정보가 명시되어 있다. 구글과 함께 국내 트래픽 1위를 다투고 있는 네이버의 헤더 내용을 분석해 보았다.&lt;/p&gt;
&lt;p&gt;헤더는 &lt;strong&gt;일반, 응답, 요청&lt;/strong&gt; 3가지로 분류되어 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;▾ 일반

요청 URL: https://www.naver.com/
요청 메서드: GET
상태 코드: 200
원격 주소: xxx.xxx.xxx.xxx:xxx
리퍼러 정책: unsafe-url
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;요청 URL&lt;/strong&gt; : 페이지의 URL.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;요청 메서드&lt;/strong&gt; : 해당 주소에 대한 동작(GET, POST, PUT, PATCH, DELETE 등등...).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;상태 코드&lt;/strong&gt; : 응답 상태를 3자리 숫자로 표시.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1xx(Information Responses)&lt;/code&gt; : 요청을 받았으며 프로세스를 계속 진행.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2xx(Successful Responses)&lt;/code&gt; : 요청을 성공적으로 받았으며 인식했고 수용.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3xx(Redirection Messages)&lt;/code&gt; : 요청 완료를 위해 추가 작업 조치가 필요.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;4xx(Client Error Responses)&lt;/code&gt; : 요청의 문법이 잘못되었거나 승인 실패.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;5xx(Server Error Responses)&lt;/code&gt; : 서버가 명백히 유효한 요청에 대한 충족 실패.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;원격 주소&lt;/strong&gt; : 도메인이 해석되고 브라우저에 의해 어떤 서버와 소통할지 알기 위해 사용되는 IP 주소.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;리퍼러 정책(Referrer-Policy)&lt;/strong&gt; : 정책에 따라 페이지의 Referrer 데이터의 양을 제한.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;no-referrer&lt;/code&gt; : 전송된 요청에 리퍼러 정보가 포함되지 않음.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;no-referrer-when-downgrade&lt;/code&gt; : 프로토콜 보안 레벨이 동일하거나 향상될 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(HTTP -&gt; HTTP, HTTPS -&gt; HTTP)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;origin&lt;/code&gt; : 도메인 정보만 전송.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;origin-when-cross-origin&lt;/code&gt; : 웹사이트가 같을 경우 전체, 다를 때는 도메인 주소만 전송.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;same-origin&lt;/code&gt; : 웹사이트가 같을 경우 전체 주소를 전송.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strict-origin&lt;/code&gt; : 프로토콜 보안 레벨이 동일할 때만 전송.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strict-origin-when-cross-origin&lt;/code&gt; : 보안 레벨 동일, 웹사이트가 같을 경우 전송.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unsafe-url&lt;/code&gt; : 보안과 관계 없음.
 &lt;/p&gt;
&lt;p&gt;  ▾ 응답 헤더&lt;/p&gt;
&lt;p&gt;  cache-control: no-cache, no-store, must-revalidate
content-encoding: gzip
content-type: text/html; charset=UTF-8
date: Tue, 04 Oct 2022 09:55:10 GMT
p3p: CP=&quot;CAO DSP CURa ADMa TAIa PSAa OUR LAW STP PHY ONL UNI
PUR FIN COM NAV INT DEM STA PRE&quot;
pragma: no-cache
referrer-policy: unsafe-url
server: NWS
strict-transport-security: max-age=63072000; includeSubdomains
x-frame-options: DENY
x-xss-protection: 1; mode=block&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;cache-control&lt;/strong&gt; : 캐시 관리에 대한 여러 정책을 제공.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;no-cache&lt;/code&gt; : 캐시가 유효한지 확인하기 위해 매번 서버에 요청.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;no-store&lt;/code&gt; : 어떤 요청도 캐시로 저장하지 않음.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;must-revalidate&lt;/code&gt; : no-cache 정책을 프록시 서버에게 요청.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;content-encoding&lt;/strong&gt; : 원본 미디어 유형에 대한 정보를 잃지 않고 메시지 데이터를 압축하는 데 사용. gzip, compress, deflate, br 등이 있음.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;content-type&lt;/strong&gt; : 원본 미디어 유형을 명시. UTF-8의 경우 최근 가장 통상적인 인코딩 방식이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;date&lt;/strong&gt; : HTTP 메시지가 만들어진 시각.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;p3p&lt;/strong&gt; : 프라이버시 보호정책을 전달하는 기준을 제공.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pragma&lt;/strong&gt; : HTTP/1.0의 유물. cache-control 역할과 동일.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;server&lt;/strong&gt; : 응답 서버.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;strict-transport-security&lt;/strong&gt; : HTTP로 액세스하여 보안에 문제가 생기게 되는 상황을 방지.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;max-age&lt;/code&gt; : strict-transport-security가 브라우저에 설정될 시간.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;includeSubdomains&lt;/code&gt; : 서브 도메인까지 확장 적용함.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;x-frame-options&lt;/strong&gt; : 클릭 재킹(Click Jacking)을 이용한 공격을 막아주는 역할.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DENY&lt;/code&gt; : 무조건 frame을 화면에 띄우지 않음.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SAMEORIGIN&lt;/code&gt; : 같은 도메인의 경우 frame 가능.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ALLOW-FROM https://www.example.com/&lt;/code&gt; : 신뢰할 수 있는 출처인 경우 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;h4&gt;클릭 재킹(Click Jacking)이란?&lt;/h4&gt;
&lt;p&gt;HTML 삽입 취약점이 존재할 경우 iframe과 같은 태그를 삽입하여 사용자의 의도와 다른 클릭 이벤트를 실행시키거나, 순간적으로 수백, 수천 개의 request를 발생시켜 디도스를 발생시킬 수 있는 해킹 기법.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;x-xss-protection&lt;/strong&gt; : 위의 클릭 재킹(Click Jacking) 공격을 감지했을 경우 페이지 로드를 중지하는 기능을 가짐. 그러나 현재 비표준으로 분류되어 향후 변동 가능성이 있음.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;▾ 요청 헤더

:authority: www.naver.com
:method: GET
:path: /
:scheme: https
accept: text/html,application/xhtml+xml,application/xml;q=0.9,
accept-encoding: gzip, deflate, br
accept-language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
cache-control: max-age=0
cookie: NNB=OOOOOOOOOOOOO; (생략)
referer: https://www.naver.com/
sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;105&quot;, &quot;Not)A;Brand&quot;;v=&quot;8&quot;,
    &quot;Chromium&quot;;v=&quot;105&quot;
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: &quot;macOS&quot;
sec-fetch-dest: document
sec-fetch-mode: navigate
sec-fetch-site: same-origin
sec-fetch-user: ?1
upgrade-insecure-requests: 1
user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)
            AppleWebKit/537.36 (KHTML, like Gecko)
            Chrome/105.0.0.0 Safari/537.36
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;accept&lt;/strong&gt; : 요청을 보낼 때 데이터의 타입(MIME)을 명시할 때 사용.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;accept-encoding&lt;/strong&gt; : 원본 미디어 유형 압축 방식.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cookie&lt;/strong&gt; : 서버로부터 받은 쿠키를 다시 서버에게 전송.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sec-ch-ua&lt;/strong&gt; : user-agent의 버전 정보를 제공. (user-agent에 대한 내용은 하단 참조.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sec-ch-ua-mobile&lt;/strong&gt; : 브라우저가 모바일 장치에 있는지에 대한 여부.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sec-ch-ua-platform&lt;/strong&gt; : user-agent가 실행 중인 플랫폼 또는 운영 체제를 제공.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sec-fetch-dest&lt;/strong&gt; : 요청의 대상을 의미, document이면 HTML 문서의 최상위 탐색 결과.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sec-fetch-mode&lt;/strong&gt; : 요청 모드를 설정.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cors&lt;/code&gt; : 교차 출처 리소스 공유(cors). 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;no-cors&lt;/code&gt; : 메소드가 HEAD, GET또는 POST, 헤더가 아닌 다른 헤더가 되지 않도록 함.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;navigate&lt;/code&gt; : 탐색 지원 모드. 탐색 요청은 문서를 탐색하는 동안 생성됨.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;websocket&lt;/code&gt; : WebSocket 연결을 설정할 때만 사용되는 특수 모드.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;sec-fetch-site&lt;/strong&gt; : 요청 개시자의 출처와 요청된 리소스의 출처 간의 관계.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sec-fetch-user&lt;/strong&gt; : 사용자 활성화에 의해 시작된 요청에 대해서만 전송. 값이 항상 ?1이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt; : 암호화되고 인증된 응답에 대한 클라이언트의 기본 설정과 CSP 지시문을 성공적으로 처리할 수 있음을 나타내는 신호를 서버에 전송.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;user-agent&lt;/strong&gt; : HTTP 요청을 보내는 디바이스, 브라우저 등의 사용자 소프트웨어 식별 정보.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zerocho.com/category/HTTP&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;HTTP - ZeroCho Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.whatap.io/ko/blog/40/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;HTTP 상태 코드 정리 | 와탭 블로그&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cloudflare.com/ko-kr/learning/ssl/transport-layer-security-tls/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;TLS란? | 네트워크 보안 프로토콜 | Cloudflare&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://csbankstorage.blogspot.com/2016/11/http_10.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;HTTP 프로토콜 ~ CS_Bank&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;HTTP | MDN&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Stack, Queue]]></title><description><![CDATA[비원시 자료구조이며 데이터를 선형적으로 구성하는 스택(Stack), 큐(Queue)를 javascript pop, push, shift 메서드로 구현해보자. 비원시 자료구조, 선형적 자료구조 스택(Stack) 과 큐(Queue…]]></description><link>https://yhuj79.github.io/Data Structure/220929/</link><guid isPermaLink="false">https://yhuj79.github.io/Data Structure/220929/</guid><pubDate>Thu, 29 Sep 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;비원시 자료구조이며 데이터를 선형적으로 구성하는 스택(Stack), 큐(Queue)를 javascript pop, push, shift 메서드로 구현해보자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;비원시 자료구조, 선형적 자료구조&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;스택(Stack)&lt;/strong&gt; 과 &lt;strong&gt;큐(Queue)&lt;/strong&gt; 는 &lt;strong&gt;비원시 자료구조(Non-Primitive Data Structure)&lt;/strong&gt; 이며, &lt;strong&gt;선형적 자료구조(Linear Structure)&lt;/strong&gt; 이다. 먼저 이것이 무엇일까?&lt;/p&gt;
&lt;p&gt;원시 자료구조가 정수형(Integer), 실수형(Float), 문자형(Character)과 같은 자료 구성의 기본 단위라면, 비원시 자료구조는 Stack, Queue, Linked List처럼 &lt;strong&gt;한 번에 여러 값을 가지며 고정되지 않은 동적 공간을 사용하는 데이터 구조 유형&lt;/strong&gt;이다. 컴퓨터 과학에서는 자료 연산에 구체적인 방법을 명시하지 않는다는 부분에서 &lt;strong&gt;추상 자료형(Abstact Data Type)&lt;/strong&gt; 이라고도 한다.&lt;/p&gt;
&lt;p&gt;또한 비원시 자료구조는 선형 구조와 비선형 구조로 분류된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;선형 구조(linear)&lt;/strong&gt; : 데이터 구조의 순차 유형으로, 1:1의 관계를 가짐.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex ) Stack, Queue, Linked List, Deque&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;비선형 구조(Nonlinear)&lt;/strong&gt; : 무작위 자료구조 형태이며, 데이터가 1:n 또는 n:n 관계를 가짐.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex ) Tree, Graph&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 중에서 &lt;strong&gt;Stack&lt;/strong&gt;과 &lt;strong&gt;Queue&lt;/strong&gt;를 javascript로 간단하게 구현해 보았다.&lt;/p&gt;
&lt;h2&gt;Stack&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/220929/stack1.png&quot; alt=&quot;stack1&quot;&gt;&lt;/p&gt;
&lt;p&gt;책을 쌓는 것처럼 차곡차곡 쌓아 올린 형태의 자료구조를 &lt;strong&gt;Stack&lt;/strong&gt;이라고 한다.&lt;/p&gt;
&lt;p&gt;한 쪽 끝에서만 자료를 넣고 뺄 수 있으므로 &lt;strong&gt;Last In First Out(LIFO)&lt;/strong&gt; 형식이라고 부른다.
따라서 마지막으로 들어온 값, 나중에 넣은 값이 먼저 나오게 된다.&lt;/p&gt;
&lt;p&gt;Stack은 &lt;code&gt;push()&lt;/code&gt;와 &lt;code&gt;pop()&lt;/code&gt;을 사용하여 javascript로 쉽게 구현할 수 있는데,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// stack
const stack = []

function addStack(item) {
  stack.push(item)
}

function delStack() {
  stack.pop()
}

addStack(1)
addStack(2)
addStack(3)
addStack(4)

delStack()

console.log(`stack = ${stack}`)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;javascript의 &lt;code&gt;pop()&lt;/code&gt; 함수는 배열의 가장 맨 끝 값을 제거해 준다.&lt;br&gt;
addStack으로 값을 추가, delStack은 가장 마지막에 push되었던 값 4를 제거하며 최종적으로 1,2,3이 남아있는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/220929/stack2.png&quot; alt=&quot;stack2&quot;&gt;&lt;/p&gt;
&lt;p&gt;Stack의 LIFO 원리는 이전의 작업 내용을 저장해 둘 필요한 경우에 활용 될 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;웹 브라우저 방문 기록&lt;/strong&gt; - 가장 나중에 열린 페이지부터 방문 리스트에 표시&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;역순 문자열 만들기&lt;/strong&gt; - 가장 나중에 입력된 문자부터 출력&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;실행 취소 (undo)&lt;/strong&gt; - 가장 나중에 실행된 것부터 취소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재귀 알고리즘&lt;/strong&gt; - stack에 담아 두었던 재귀 함수를 backtrack 시 임시 데이터를 빼주는 형식&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;후위 표기법 계산&lt;/strong&gt; - postfix notation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;수식의 괄호 검사&lt;/strong&gt; - 연산자 우선순위 표현을 위한 괄호 검사&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Queue&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/220929/queue1.png&quot; alt=&quot;queue1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Queue&lt;/strong&gt;는 한쪽으로 데이터를 넣고 다른 쪽으로 데이터를 가져오는 구조이다.&lt;/p&gt;
&lt;p&gt;맨 처음 입력된 데이터가 먼저 나오게 된다. &lt;strong&gt;First In First Out(FIFO), Last In Last Out(LILO)&lt;/strong&gt; 형식으로 불린다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// queue
const queue = []

function addQueue(item) {
  queue.push(item)
}

function delQueue() {
  queue.shift()
}

addQueue(1)
addQueue(2)
addQueue(3)
addQueue(4)

delQueue()

console.log(`queue = ${queue}`)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/220929/queue2.png&quot; alt=&quot;queue2&quot;&gt;&lt;/p&gt;
&lt;p&gt;javascript의 &lt;code&gt;shift()&lt;/code&gt; 함수는 배열의 가장 맨 앞 값을 제거해 준다. 결과는 2, 3, 4만 남게 된다.&lt;/p&gt;
&lt;p&gt;실제 Queue의 활용 예시는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU, 디스크 스케줄링&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;너비 우선 탐색 (BFS, Breadth-First Search)&lt;/strong&gt; - 가까운 곳을 먼저, 먼 곳을 나중에 방문하는 순회 방식&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;프로세스 관리&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비동기 전송&lt;/strong&gt; - 자료 일시 저장 시&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;캐시 (Cache)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.javatpoint.com/primitive-vs-non-primitive-data-structure&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Primitive vs non-primitive data structure | What&apos;s the difference? - javatpoint&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_data_type&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Abstract data type - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.booksr.co.kr/product/9788970509716/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;자료구조 (개정3판) | 생능출판사&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yoongrammer.tistory.com/45&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;[자료구조] 스택 (Stack)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://helloworldjavascript.net/pages/282-data-structures.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;큐, 스택, 트리 | JavaScript로 만나는 세상&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[딕셔너리(Dictionary)]]></title><description><![CDATA[Swift가 제공하는 컬렉션 타입 중 key와 value로 묶어서 구성할 수 있는 딕셔너리와, typealias, for in, sorted 등의 메서드 활용하기 딕셔너리(Dictionary…]]></description><link>https://yhuj79.github.io/Swift/220925/</link><guid isPermaLink="false">https://yhuj79.github.io/Swift/220925/</guid><pubDate>Sun, 25 Sep 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Swift가 제공하는 컬렉션 타입 중 key와 value로 묶어서 구성할 수 있는 딕셔너리와, typealias, for in, sorted 등의 메서드 활용하기&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;딕셔너리(Dictionary) 사용&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;딕셔너리&lt;/strong&gt; 는 컬렉션 타입으로, 키와 값 쌍으로 구성된다. 딕셔너리 안에는 키가 하나이거나 여러 개일 수 있다.
Dictionary 키워드를 키의 타입과 값의 타입 이름의 조합으로 써서 생성한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;// 기본적인 빈 딕셔너리 생성 (Int)
// var을 사용하여 딕셔너리가 변경 가능하게 하거나, let을 사용하여 변경 불가능한 딕셔너리로 생성
var userList: Dictionary&amp;#x3C;String, Int&gt; = Dictionary&amp;#x3C;String, Int&gt;()
let userList: Dictionary&amp;#x3C;String, Int&gt; = Dictionary&amp;#x3C;String, Int&gt;()

// 다음과 같이 초깃값을 부여할 수 있음
let userList: Dictionary&amp;#x3C;String, Int&gt;
    = [&quot;user1&quot;: 1, &quot;user2&quot;: 2,&quot;user3&quot;: 3]

// 다음과 같이 작성도 가능
let userList: [String: Int]
    = [&quot;user1&quot;: 1, &quot;user2&quot;: 2,&quot;user3&quot;: 3]

print(userList[&quot;user1&quot;]) // 결과 : Optional(1)
print(userList.count) // 결과 : 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;typealias&lt;/strong&gt;라는 별칭 키워드는 이미 존재하는 데이터 타입에 임의로 다른 이름을 부여하여 사용할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;이 기능을 사용하여 보다 간결하게 딕셔너리를 생성할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;// 이미 존재하는 데이터 타입에 임의로 다른 이름을 부여
typealias StringDict = [String: Int]

// 빈 딕셔너리 생성
var userList: StringDict = [:]
// 딕셔너리 초깃값 부여
var userList: StringDict = [&quot;user1&quot;: 1, &quot;user2&quot;: 2,&quot;user3&quot;: 3]

print(userList[&quot;user1&quot;]) // 결과 : Optional(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;딕셔너리의 키는 각각의 값에 접근할 수 있게 도와준다. 딕셔너리 내부에서 키는 유일해야 하며, 값은 유일하지 않다.&lt;/p&gt;
&lt;p&gt;만약 딕셔너리 내부에 존재하지 않는 키로 접근하게 되면 &lt;code&gt;nil&lt;/code&gt;을 출력하게 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;typealias MyDict = [String: Int]
var userList: MyDict = [&quot;user1&quot;: 1, &quot;user2&quot;: 2,&quot;user3&quot;: 3]

// user1 값 수정
userList[&quot;user1&quot;] = 77
// user2 값 삭제
userList.removeValue(forKey: &quot;user2&quot;)

print(userList) // 결과 : [&quot;user3&quot;: 3, &quot;user1&quot;: 77]
print(userList[&quot;user2&quot;]) // 결과 : nil
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;반복, 조건, 정렬을 사용하여 응용해보기&lt;/h2&gt;
&lt;p&gt;딕셔너리를 &lt;code&gt;for in&lt;/code&gt;으로 반복시키고, 조건문을 작성하여 알맞게 값이 출력될 수 있게끔 만들어 보았다.&lt;/p&gt;
&lt;p&gt;딕셔너리에 user를 key, 해당 user의 시험 점수를 value로 하여 시험 성적표를 담았다.&lt;/p&gt;
&lt;p&gt;그리고 이 딕셔너리에서 시험 점수가 80점이 넘는 user만 출력시켰다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;typealias MyDict = [String: Int]

var examScore: MyDict = [
    &quot;user1&quot;: 53,
    &quot;user2&quot;: 81,
    &quot;user3&quot;: 84,
    &quot;user4&quot;: 96,
    &quot;user5&quot;: 95,
    &quot;user6&quot;: 49,
    &quot;user7&quot;: 77,
    &quot;user8&quot;: 32,
    &quot;user9&quot;: 76,
    &quot;user10&quot;: 72
]

for result in examScore {
    if(result.value &gt; 80) {
        print(&quot;\(result.key)의 점수는 \(result.value)&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/220925/dict1.png&quot; alt=&quot;dict1&quot;&gt;&lt;/p&gt;
&lt;p&gt;결과에서 볼 수 있듯이 딕셔너리는 요소들이 순서 없이 구성되기 때문에 코드와 무관하게, 값의 크고 작은 순 없이 순서가 무작위로 출력되는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;그렇다면 이를 정렬하려면 어떤 방법이 필요할까?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sorted&lt;/code&gt;를 활용하면 원하는 대로 나열할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;typealias MyDict = [String: Int]

var examScore: MyDict = [
    &quot;user1&quot;: 53,
    &quot;user2&quot;: 81,
    &quot;user3&quot;: 84,
    &quot;user4&quot;: 96,
    &quot;user5&quot;: 95,
    &quot;user6&quot;: 49,
    &quot;user7&quot;: 77,
    &quot;user8&quot;: 32,
    &quot;user9&quot;: 76,
    &quot;user10&quot;: 72
]

let sortedDict = examScore.sorted { (first, second) in
    return first.value &gt; second.value
}

for result in sortedDict {
    print(&quot;\(result.key)의 점수는 \(result.value)&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/220925/dict2.png&quot; alt=&quot;dict2&quot;&gt;&lt;/p&gt;
&lt;p&gt;사본 &lt;code&gt;sortedDict&lt;/code&gt;를 만들고 &lt;code&gt;sorted&lt;/code&gt;를 value가 높은 순서대로 정렬하게끔 사용하였다.&lt;/p&gt;
&lt;p&gt;원본 딕셔너리의 무작위 순서가 아닌 정렬된 결과를 얻었고, 그 결과를 반복문과 &lt;code&gt;print()&lt;/code&gt;를 사용하여 최종적으로 나타냈다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9421379018&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;스위프트 프로그래밍(3판)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2unbini.github.io/%F0%9F%93%82%20all/swift/dictionary-sorted/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;스위프트 딕셔너리 정렬, Swift Dictionary sorted() - SeriOSly&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[마크다운(Markdown)]]></title><description><![CDATA[블로그 테스트 게시글입니다. 아래 링크의 내용으로 작성되었습니다. Markdown - Wikipedia Daring Fireball: Markdown Syntax Documentation Philosophy Markdown is intended to…]]></description><link>https://yhuj79.github.io/Markdown/220924/</link><guid isPermaLink="false">https://yhuj79.github.io/Markdown/220924/</guid><pubDate>Sat, 24 Sep 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;블로그 테스트 게시글입니다. 아래 링크의 내용으로 작성되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Markdown&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Markdown - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Daring Fireball: Markdown Syntax Documentation&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Philosophy&lt;/h2&gt;
&lt;p&gt;Markdown is intended to be as easy-to-read and easy-to-write as is feasible.&lt;/p&gt;
&lt;p&gt;Readability, however, is emphasized above all else. A Markdown-formatted
document should be publishable as-is, as plain text, without looking
like it&apos;s been marked up with tags or formatting instructions. While
Markdown&apos;s syntax has been influenced by several existing text-to-HTML
filters -- including &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Setext&lt;/a&gt;, &lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;atx&lt;/a&gt;, &lt;a href=&quot;http://textism.com/tools/textile/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Textile&lt;/a&gt;, &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;reStructuredText&lt;/a&gt;,
&lt;a href=&quot;http://www.triptico.com/software/grutatxt.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Grutatext&lt;/a&gt;, and &lt;a href=&quot;http://ettext.taint.org/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;EtText&lt;/a&gt; -- the single biggest source of
inspiration for Markdown&apos;s syntax is the format of plain text email.&lt;/p&gt;
&lt;h2&gt;Block Elements&lt;/h2&gt;
&lt;h3&gt;Paragraphs and Line Breaks&lt;/h3&gt;
&lt;p&gt;A paragraph is simply one or more consecutive lines of text, separated
by one or more blank lines. (A blank line is any line that looks like a
blank line -- a line containing nothing but spaces or tabs is considered
blank.) Normal paragraphs should not be indented with spaces or tabs.&lt;/p&gt;
&lt;p&gt;The implication of the &quot;one or more consecutive lines of text&quot; rule is
that Markdown supports &quot;hard-wrapped&quot; text paragraphs. This differs
significantly from most other text-to-HTML formatters (including Movable
Type&apos;s &quot;Convert Line Breaks&quot; option) which translate every line break
character in a paragraph into a &lt;code&gt;&amp;#x3C;br /&gt;&lt;/code&gt; tag.&lt;/p&gt;
&lt;p&gt;When you &lt;em&gt;do&lt;/em&gt; want to insert a &lt;code&gt;&amp;#x3C;br /&gt;&lt;/code&gt; break tag using Markdown, you
end a line with two or more spaces, then type return.&lt;/p&gt;
&lt;h3&gt;Headers&lt;/h3&gt;
&lt;p&gt;Markdown supports two styles of headers, [Setext] [1] and [atx] [2].&lt;/p&gt;
&lt;p&gt;Optionally, you may &quot;close&quot; atx-style headers. This is purely
cosmetic -- you can use this if you think it looks better. The
closing hashes don&apos;t even need to match the number of hashes
used to open the header. (The number of opening hashes
determines the header level.)&lt;/p&gt;
&lt;h3&gt;Blockquotes&lt;/h3&gt;
&lt;p&gt;Markdown uses email-style &lt;code&gt;&gt;&lt;/code&gt; characters for blockquoting. If you&apos;re
familiar with quoting passages of text in an email message, then you
know how to create a blockquote in Markdown. It looks best if you hard
wrap the text and put a &lt;code&gt;&gt;&lt;/code&gt; before every line:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&lt;/p&gt;
&lt;p&gt;Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Markdown allows you to be lazy and only put the &lt;code&gt;&gt;&lt;/code&gt; before the first
line of a hard-wrapped paragraph:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by
adding additional levels of &lt;code&gt;&gt;&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is the first level of quoting.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is nested blockquote.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Back to the first level.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Blockquotes can contain other Markdown elements, including headers, lists,
and code blocks:&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;This is a header&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;This is the first list item.&lt;/li&gt;
&lt;li&gt;This is the second list item.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here&apos;s some example code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return shell_exec(&quot;echo $input | $markdown_script&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Any decent text editor should make email-style quoting easy. For
example, with BBEdit, you can make a selection and choose Increase
Quote Level from the Text menu.&lt;/p&gt;
&lt;h3&gt;Lists&lt;/h3&gt;
&lt;p&gt;Markdown supports ordered (numbered) and unordered (bulleted) lists.&lt;/p&gt;
&lt;p&gt;Unordered lists use asterisks, pluses, and hyphens -- interchangably
-- as list markers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;is equivalent to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ordered lists use numbers followed by periods:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It&apos;s important to note that the actual numbers you use to mark the
list have no effect on the HTML output Markdown produces. The HTML
Markdown produces from the above list is:&lt;/p&gt;
&lt;p&gt;If you instead wrote the list in Markdown like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;or even:&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;you&apos;d get the exact same HTML output. The point is, if you want to,
you can use ordinal numbers in your ordered Markdown lists, so that
the numbers in your source match the numbers in your published HTML.
But if you want to be lazy, you don&apos;t have to.&lt;/p&gt;
&lt;p&gt;To make lists look nice, you can wrap items with hanging indents:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.&lt;/li&gt;
&lt;li&gt;Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But if you want to be lazy, you don&apos;t have to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.&lt;/li&gt;
&lt;li&gt;Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;List items may consist of multiple paragraphs. Each subsequent
paragraph in a list item must be indented by either 4 spaces
or one tab:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;This is a list item with two paragraphs. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit. Aliquam hendrerit
mi posuere lectus.&lt;/p&gt;
&lt;p&gt;Vestibulum enim wisi, viverra nec, fringilla in, laoreet
vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
sit amet velit.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Suspendisse id sem consectetuer libero luctus adipiscing.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It looks nice if you indent every line of the subsequent
paragraphs, but here again, Markdown will allow you to be
lazy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;This is a list item with two paragraphs.&lt;/p&gt;
&lt;p&gt;  This is the second paragraph in the list item. You&apos;re&lt;/p&gt;
&lt;p&gt;only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Another item in the same list.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To put a blockquote within a list item, the blockquote&apos;s &lt;code&gt;&gt;&lt;/code&gt;
delimiters need to be indented:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A list item with a blockquote:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote
inside a list item.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To put a code block within a list item, the code block needs
to be indented &lt;em&gt;twice&lt;/em&gt; -- 8 spaces or two tabs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A list item with a code block:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#x3C;code goes here&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Code Blocks&lt;/h3&gt;
&lt;p&gt;Pre-formatted code blocks are used for writing about programming or
markup source code. Rather than forming normal paragraphs, the lines
of a code block are interpreted literally. Markdown wraps a code block
in both &lt;code&gt;&amp;#x3C;pre&gt;&lt;/code&gt; and &lt;code&gt;&amp;#x3C;code&gt;&lt;/code&gt; tags.&lt;/p&gt;
&lt;p&gt;To produce a code block in Markdown, simply indent every line of the
block by at least 4 spaces or 1 tab.&lt;/p&gt;
&lt;p&gt;This is a normal paragraph:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is a code block.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A code block continues until it reaches a line that is not indented
(or the end of the article).&lt;/p&gt;
&lt;p&gt;Within a code block, ampersands (&lt;code&gt;&amp;#x26;&lt;/code&gt;) and angle brackets (&lt;code&gt;&amp;#x3C;&lt;/code&gt; and &lt;code&gt;&gt;&lt;/code&gt;)
are automatically converted into HTML entities. This makes it very
easy to include example HTML source code using Markdown -- just paste
it and indent it, and Markdown will handle the hassle of encoding the
ampersands and angle brackets. For example, this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#x3C;div class=&quot;footer&quot;&gt;
    &amp;#x26;copy; 2004 Foo Corporation
&amp;#x3C;/div&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Regular Markdown syntax is not processed within code blocks. E.g.,
asterisks are just literal asterisks within a code block. This means
it&apos;s also easy to use Markdown to write about Markdown&apos;s own syntax.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Span Elements&lt;/h2&gt;
&lt;h3&gt;Links&lt;/h3&gt;
&lt;p&gt;Markdown supports two style of links: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;reference&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In both styles, the link text is delimited by [square brackets].&lt;/p&gt;
&lt;p&gt;To create an inline link, use a set of regular parentheses immediately
after the link text&apos;s closing square bracket. Inside the parentheses,
put the URL where you want the link to point, along with an &lt;em&gt;optional&lt;/em&gt;
title for the link, surrounded in quotes. For example:&lt;/p&gt;
&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://example.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt;
&lt;h3&gt;Emphasis&lt;/h3&gt;
&lt;p&gt;Markdown treats asterisks (&lt;code&gt;*&lt;/code&gt;) and underscores (&lt;code&gt;_&lt;/code&gt;) as indicators of
emphasis. Text wrapped with one &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt; will be wrapped with an
HTML &lt;code&gt;&amp;#x3C;em&gt;&lt;/code&gt; tag; double &lt;code&gt;*&lt;/code&gt;&apos;s or &lt;code&gt;_&lt;/code&gt;&apos;s will be wrapped with an HTML
&lt;code&gt;&amp;#x3C;strong&gt;&lt;/code&gt; tag. E.g., this input:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;single asterisks&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;double underscores&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Code&lt;/h3&gt;
&lt;p&gt;To indicate a span of code, wrap it with backtick quotes (&lt;code&gt;`&lt;/code&gt;).
Unlike a pre-formatted code block, a code span indicates code within a
normal paragraph. For example:&lt;/p&gt;
&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Markdown&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Markdown - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Daring Fireball: Markdown Syntax Documentation&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Terminal App]]></title><description><![CDATA[블로그 테스트 게시글입니다. 아래 링크의 내용으로 작성되었습니다. wikipedia : macOS apple : 터미널 사용 설명서 Terminal App Terminal 터미널(Terminal, Terminal.app) 은 애플이 개발한 macOS…]]></description><link>https://yhuj79.github.io/MacOS/220920/</link><guid isPermaLink="false">https://yhuj79.github.io/MacOS/220920/</guid><pubDate>Tue, 20 Sep 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;블로그 테스트 게시글입니다. 아래 링크의 내용으로 작성되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%84%B0%EB%AF%B8%EB%84%90_%28macOS%29&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;wikipedia : macOS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.apple.com/ko-kr/guide/terminal/apd5265185d-f365-44cb-8b09-71a064a42125/mac&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;apple : 터미널 사용 설명서&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yhuj79/blog-assets/main/220920/Terminal%20App.png&quot; alt=&quot;Terminal App&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Terminal&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;터미널(Terminal, Terminal.app)&lt;/strong&gt; 은 애플이 개발한 macOS 운영 체제에 포함된 단말 에뮬레이터이다.
터미널은 macOS의 전작 운영 체제인 NeXTSTEP, 오픈스텝에서 기원이 된다.&lt;/p&gt;
&lt;p&gt;단말 에뮬레이터로서 이 애플리케이션은 bash(맥 OS X 10.2 이후의 기본 셸) 등의 유닉스 셸과 결합하여 사용할 때 명령 줄 인터페이스를 운영 체제에 제공함으로써 운영 체제에 대한 텍스트 기반 접근을 제공하며, 이는 macOS의 그래픽 사용자 경험에 대비된다. 사용자는 macOS와 사용할 콘 셸, Tcsh, Z 셸과 같은 다른 셸을 지정할 수 있다.&lt;/p&gt;
&lt;h3&gt;터미널 열기&lt;/h3&gt;
&lt;p&gt;Mac에서 다음 중 하나를 수행하십시오.
Dock에서 Launchpad 아이콘을 클릭하고 검색 필드에 터미널을 입력한 다음 터미널을 클릭하십시오.
Finder에서 /응용 프로그램/유틸리티 폴더를 연 다음, 터미널을 이중 클릭하십시오.&lt;/p&gt;
&lt;h3&gt;셸 세션 종료하기&lt;/h3&gt;
&lt;p&gt;Mac용 터미널 앱의 종료할 셸 프로세스가 실행 중인 윈도우에서 exit를 입력한 다음, Return을 누르십시오.
셸에서 실행되고 있는 명령어가 종료됩니다. 작업이 진행 중인 경우 대화상자가 나타납니다.
셸 종료 동작을 변경하려면 프로파일 셸 환경설정 변경하기를 참조하십시오.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%84%B0%EB%AF%B8%EB%84%90_%28macOS%29&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;wikipedia : macOS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.apple.com/ko-kr/guide/terminal/apd5265185d-f365-44cb-8b09-71a064a42125/mac&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;apple : 터미널 사용 설명서&lt;/a&gt;&lt;/p&gt;</content:encoded></item></channel></rss>