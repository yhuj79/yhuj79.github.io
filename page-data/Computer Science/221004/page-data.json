{"componentChunkName":"component---src-templates-blog-post-js","path":"/Computer Science/221004/","result":{"data":{"site":{"siteMetadata":{"author":"yhuj79","comment":{"utterances":"yhuj79/blog-comments"},"sponsor":{"buyMeACoffeeId":"yhuj79"}}},"markdownRemark":{"excerpt":"브라우저의 Http(Hyper Text Transfer Protocol) 헤더에서 서버와 클라이언트의 요청, 응답 과정에서 전송한 부가 정보를 확인할 수 있다. HTTP란? HTTP(Hyper Text Transfer Protocol) 라는 영문 그대로 인터넷에서 하이퍼텍스트를 빠르게 교환하기 위한 프로토콜의 일종이다. 여기서 하이퍼텍스트는 링크를 통해 …","html":"<blockquote>\n<p>브라우저의 Http(Hyper Text Transfer Protocol) 헤더에서 서버와 클라이언트의 요청, 응답 과정에서 전송한 부가 정보를 확인할 수 있다.</p>\n</blockquote>\n<h2>HTTP란?</h2>\n<p><strong>HTTP(Hyper Text Transfer Protocol)</strong> 라는 영문 그대로 인터넷에서 하이퍼텍스트를 빠르게 교환하기 위한 프로토콜의 일종이다. 여기서 하이퍼텍스트는 링크를 통해 다른 문서로 이동할 수 있게 해주는 텍스트, 하이퍼링크를 나타내는 텍스트를 의미한다.</p>\n<p>HTTP는 OSI 7계층 중에 응용 계층(Application layer)의 프로토콜이며, TCP/IP Suite 위에서 작동한다. (OSI계층과 관련된 자세한 내용은 <a href=\"https://ko.wikipedia.org/wiki/OSI_%EB%AA%A8%ED%98%95\" target=\"_blank\" rel=\"noopener noreferrer\">OSI_모형</a> 참고.) HTTP는 인터넷 할당 번호 관리 기관(IANA)의 가이드라인에 의거하여 80번 포트를 사용하며, 요청(Request)과 응답(Response)으로 구성되어 데이터를 주고받는다. 클라이언트가 80번 포트로 요청을 보내면, 서버에서 응답을 하는 방식이다.</p>\n<h2>HTTPS란?</h2>\n<p>기존의 HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이라 비밀번호 등의 개인정보를 제 3자가 조회할 수 있었다. 이러한 문제를 해결하기 위해 HTTPS가 등장하게 되었다.</p>\n<blockquote>\n<p>HyperText Transfer Protocol over Secure Socket Layer<br>\nHTTP over TLS<br>\nHTTP over SSL<br>\nHTTP Secure</p>\n</blockquote>\n<p>영문에서 알 수 있듯이 제 3자가 정보를 볼 수 없도록 암호화가 첨가되었다. 80번 포트가 아닌 443번 포트를 사용하며, 보안 소켓 계층(SECURE SOCKETS LAYER)을 사용한다. 이 SSL 인증서는 사용자가 사이트에서 제공하는 정보를 암호화하는데, 제 3자가 개인정보에 접근했을 경우 데이터가 이미 암호화된 상태이기 때문에 확인이 불가능하다. 전송 계층 보안(Transport Layer Security) 또한 사용되는데, 클라이언트와 서버 간의 커뮤니케이션을 암호화해준다.</p>\n<h2>네트워크 헤더</h2>\n<p>브라우저 개발자 도구의 네트워크 탭에서 헤더를 확인할 수 있는데, 요청과 응답의 부가적인 정보가 명시되어 있다. 구글과 함께 국내 트래픽 1위를 다투고 있는 네이버의 헤더 내용을 분석해 보았다.</p>\n<p>헤더는 <strong>일반, 응답, 요청</strong> 3가지로 분류되어 있다.</p>\n<pre><code>▾ 일반\n\n요청 URL: https://www.naver.com/\n요청 메서드: GET\n상태 코드: 200\n원격 주소: xxx.xxx.xxx.xxx:xxx\n리퍼러 정책: unsafe-url\n</code></pre>\n<p><strong>요청 URL</strong> : 페이지의 URL.</p>\n<p><strong>요청 메서드</strong> : 해당 주소에 대한 동작(GET, POST, PUT, PATCH, DELETE 등등...).</p>\n<p><strong>상태 코드</strong> : 응답 상태를 3자리 숫자로 표시.</p>\n<ul>\n<li><code>1xx(Information Responses)</code> : 요청을 받았으며 프로세스를 계속 진행.</li>\n<li><code>2xx(Successful Responses)</code> : 요청을 성공적으로 받았으며 인식했고 수용.</li>\n<li><code>3xx(Redirection Messages)</code> : 요청 완료를 위해 추가 작업 조치가 필요.</li>\n<li><code>4xx(Client Error Responses)</code> : 요청의 문법이 잘못되었거나 승인 실패.</li>\n<li><code>5xx(Server Error Responses)</code> : 서버가 명백히 유효한 요청에 대한 충족 실패.</li>\n</ul>\n<p><strong>원격 주소</strong> : 도메인이 해석되고 브라우저에 의해 어떤 서버와 소통할지 알기 위해 사용되는 IP 주소.</p>\n<p><strong>리퍼러 정책(Referrer-Policy)</strong> : 정책에 따라 페이지의 Referrer 데이터의 양을 제한.</p>\n<ul>\n<li><code>no-referrer</code> : 전송된 요청에 리퍼러 정보가 포함되지 않음.</li>\n<li>\n<p><code>no-referrer-when-downgrade</code> : 프로토콜 보안 레벨이 동일하거나 향상될 경우</p>\n<ul>\n<li>(HTTP -> HTTP, HTTPS -> HTTP)</li>\n</ul>\n</li>\n<li><code>origin</code> : 도메인 정보만 전송.</li>\n<li><code>origin-when-cross-origin</code> : 웹사이트가 같을 경우 전체, 다를 때는 도메인 주소만 전송.</li>\n<li><code>same-origin</code> : 웹사이트가 같을 경우 전체 주소를 전송.</li>\n<li><code>strict-origin</code> : 프로토콜 보안 레벨이 동일할 때만 전송.</li>\n<li><code>strict-origin-when-cross-origin</code> : 보안 레벨 동일, 웹사이트가 같을 경우 전송.</li>\n<li>\n<p><code>unsafe-url</code> : 보안과 관계 없음.\n </p>\n<p>  ▾ 응답 헤더</p>\n<p>  cache-control: no-cache, no-store, must-revalidate\ncontent-encoding: gzip\ncontent-type: text/html; charset=UTF-8\ndate: Tue, 04 Oct 2022 09:55:10 GMT\np3p: CP=\"CAO DSP CURa ADMa TAIa PSAa OUR LAW STP PHY ONL UNI\nPUR FIN COM NAV INT DEM STA PRE\"\npragma: no-cache\nreferrer-policy: unsafe-url\nserver: NWS\nstrict-transport-security: max-age=63072000; includeSubdomains\nx-frame-options: DENY\nx-xss-protection: 1; mode=block</p>\n</li>\n</ul>\n<p><strong>cache-control</strong> : 캐시 관리에 대한 여러 정책을 제공.</p>\n<ul>\n<li><code>no-cache</code> : 캐시가 유효한지 확인하기 위해 매번 서버에 요청.</li>\n<li><code>no-store</code> : 어떤 요청도 캐시로 저장하지 않음.</li>\n<li><code>must-revalidate</code> : no-cache 정책을 프록시 서버에게 요청.</li>\n</ul>\n<p><strong>content-encoding</strong> : 원본 미디어 유형에 대한 정보를 잃지 않고 메시지 데이터를 압축하는 데 사용. gzip, compress, deflate, br 등이 있음.</p>\n<p><strong>content-type</strong> : 원본 미디어 유형을 명시. UTF-8의 경우 최근 가장 통상적인 인코딩 방식이다.</p>\n<p><strong>date</strong> : HTTP 메시지가 만들어진 시각.</p>\n<p><strong>p3p</strong> : 프라이버시 보호정책을 전달하는 기준을 제공.</p>\n<p><strong>pragma</strong> : HTTP/1.0의 유물. cache-control 역할과 동일.</p>\n<p><strong>server</strong> : 응답 서버.</p>\n<p><strong>strict-transport-security</strong> : HTTP로 액세스하여 보안에 문제가 생기게 되는 상황을 방지.</p>\n<ul>\n<li><code>max-age</code> : strict-transport-security가 브라우저에 설정될 시간.</li>\n<li><code>includeSubdomains</code> : 서브 도메인까지 확장 적용함.</li>\n</ul>\n<p><strong>x-frame-options</strong> : 클릭 재킹(Click Jacking)을 이용한 공격을 막아주는 역할.</p>\n<ul>\n<li><code>DENY</code> : 무조건 frame을 화면에 띄우지 않음.</li>\n<li><code>SAMEORIGIN</code> : 같은 도메인의 경우 frame 가능.</li>\n<li><code>ALLOW-FROM https://www.example.com/</code> : 신뢰할 수 있는 출처인 경우 가능.</li>\n</ul>\n<blockquote>\n<h4>클릭 재킹(Click Jacking)이란?</h4>\n<p>HTML 삽입 취약점이 존재할 경우 iframe과 같은 태그를 삽입하여 사용자의 의도와 다른 클릭 이벤트를 실행시키거나, 순간적으로 수백, 수천 개의 request를 발생시켜 디도스를 발생시킬 수 있는 해킹 기법.</p>\n</blockquote>\n<p><strong>x-xss-protection</strong> : 위의 클릭 재킹(Click Jacking) 공격을 감지했을 경우 페이지 로드를 중지하는 기능을 가짐. 그러나 현재 비표준으로 분류되어 향후 변동 가능성이 있음.</p>\n<p> </p>\n<pre><code>▾ 요청 헤더\n\n:authority: www.naver.com\n:method: GET\n:path: /\n:scheme: https\naccept: text/html,application/xhtml+xml,application/xml;q=0.9,\naccept-encoding: gzip, deflate, br\naccept-language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\ncache-control: max-age=0\ncookie: NNB=OOOOOOOOOOOOO; (생략)\nreferer: https://www.naver.com/\nsec-ch-ua: \"Google Chrome\";v=\"105\", \"Not)A;Brand\";v=\"8\",\n    \"Chromium\";v=\"105\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"macOS\"\nsec-fetch-dest: document\nsec-fetch-mode: navigate\nsec-fetch-site: same-origin\nsec-fetch-user: ?1\nupgrade-insecure-requests: 1\nuser-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)\n            AppleWebKit/537.36 (KHTML, like Gecko)\n            Chrome/105.0.0.0 Safari/537.36\n</code></pre>\n<p><strong>accept</strong> : 요청을 보낼 때 데이터의 타입(MIME)을 명시할 때 사용.</p>\n<p><strong>accept-encoding</strong> : 원본 미디어 유형 압축 방식.</p>\n<p><strong>cookie</strong> : 서버로부터 받은 쿠키를 다시 서버에게 전송.</p>\n<p><strong>sec-ch-ua</strong> : user-agent의 버전 정보를 제공. (user-agent에 대한 내용은 하단 참조.)</p>\n<p><strong>sec-ch-ua-mobile</strong> : 브라우저가 모바일 장치에 있는지에 대한 여부.</p>\n<p><strong>sec-ch-ua-platform</strong> : user-agent가 실행 중인 플랫폼 또는 운영 체제를 제공.</p>\n<p><strong>sec-fetch-dest</strong> : 요청의 대상을 의미, document이면 HTML 문서의 최상위 탐색 결과.</p>\n<p><strong>sec-fetch-mode</strong> : 요청 모드를 설정.</p>\n<ul>\n<li><code>cors</code> : 교차 출처 리소스 공유(cors). 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제.</li>\n<li><code>no-cors</code> : 메소드가 HEAD, GET또는 POST, 헤더가 아닌 다른 헤더가 되지 않도록 함.</li>\n<li><code>navigate</code> : 탐색 지원 모드. 탐색 요청은 문서를 탐색하는 동안 생성됨.</li>\n<li><code>websocket</code> : WebSocket 연결을 설정할 때만 사용되는 특수 모드.</li>\n</ul>\n<p><strong>sec-fetch-site</strong> : 요청 개시자의 출처와 요청된 리소스의 출처 간의 관계.</p>\n<p><strong>sec-fetch-user</strong> : 사용자 활성화에 의해 시작된 요청에 대해서만 전송. 값이 항상 ?1이다.</p>\n<p><strong>upgrade-insecure-requests</strong> : 암호화되고 인증된 응답에 대한 클라이언트의 기본 설정과 CSP 지시문을 성공적으로 처리할 수 있음을 나타내는 신호를 서버에 전송.</p>\n<p><strong>user-agent</strong> : HTTP 요청을 보내는 디바이스, 브라우저 등의 사용자 소프트웨어 식별 정보.</p>\n<hr>\n<h2>Reference</h2>\n<p><a href=\"https://www.zerocho.com/category/HTTP\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP - ZeroCho Blog</a></p>\n<p><a href=\"https://www.whatap.io/ko/blog/40/\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP 상태 코드 정리 | 와탭 블로그</a></p>\n<p><a href=\"https://www.cloudflare.com/ko-kr/learning/ssl/transport-layer-security-tls/\" target=\"_blank\" rel=\"noopener noreferrer\">TLS란? | 네트워크 보안 프로토콜 | Cloudflare</a></p>\n<p><a href=\"https://csbankstorage.blogspot.com/2016/11/http_10.html\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP 프로토콜 ~ CS_Bank</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP | MDN</a></p>","tableOfContents":"<ul>\n<li><a href=\"/Computer%20Science/221004/#http%EB%9E%80\">HTTP란?</a></li>\n<li><a href=\"/Computer%20Science/221004/#https%EB%9E%80\">HTTPS란?</a></li>\n<li><a href=\"/Computer%20Science/221004/#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%97%A4%EB%8D%94\">네트워크 헤더</a></li>\n<li><a href=\"/Computer%20Science/221004/#reference\">Reference</a></li>\n</ul>","frontmatter":{"date":"2022년 10월 04일","title":"HTTP 헤더 분석","tags":["Network","HTTPS"]}}},"pageContext":{"slug":"/Computer Science/221004/","previous":{"fields":{"slug":"/Data Structure/220929/"},"frontmatter":{"title":"Stack, Queue"}},"next":{"fields":{"slug":"/Javascript/221013/"},"frontmatter":{"title":"동적 타입 언어"}}}},"staticQueryHashes":["1081905842","3911196313"]}