{"componentChunkName":"component---src-templates-blog-post-js","path":"/Typescript/240827/","result":{"data":{"site":{"siteMetadata":{"author":"yhuj79","comment":{"utterances":"yhuj79/blog-comments"},"sponsor":{"buyMeACoffeeId":"yhuj79"}}},"markdownRemark":{"excerpt":"'바퀴를 다시 발명하지 마라(Don't reinvent the wheel)'라는 유명한 프로그래밍 격언이 있다. 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다. 디자인 패턴이란? 디자인 패턴(Design Pattern)은 소프트웨어 개발에서 자주 발생하는 문제들을 해결하기…","html":"<blockquote>\n<p><strong>'바퀴를 다시 발명하지 마라(Don't reinvent the wheel)'</strong>라는 유명한 프로그래밍 격언이 있다. 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다.</p>\n</blockquote>\n<h2>디자인 패턴이란?</h2>\n<p><strong>디자인 패턴(Design Pattern)</strong>은 소프트웨어 개발에서 자주 발생하는 문제들을 해결하기 위한 반복 가능한 솔루션을 제공하는 중요한 개념이다. 이러한 패턴들은 코드의 재사용성을 높이고, 유지보수를 쉽게 하며, 코드의 가독성을 향상시키는 데 도움을 준다. 이번 포스트에서는 <strong>TypeScript</strong>를 사용해 여러 디자인 패턴을 구현해 보았다. TypeScript는 정적 타입 검사와 객체 지향 프로그래밍 기능을 제공하므로 디자인 패턴을 적용하는 데 매우 적합한 언어다.</p>\n<br>\n<h2>GoF 디자인 패턴 목적 분류</h2>\n<p><strong>GoF 디자인 패턴</strong>은 소프트웨어 개발에서 자주 사용되는 설계 패턴을 정의한 것이다. <strong>GoF</strong>는 'Gang of Four'의 약자로, 이 패턴을 정의한 네 명의 저자들(Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides)을 가리킨다. 이들은 1994년에 출판한 책 <em>\"Design Patterns: Elements of Reusable Object-Oriented Software\"</em>에서 23개의 디자인 패턴을 소개했는데, 여기서 목적에 따른 세 가지 카테고리로 분류하였다.</p>\n<ul>\n<li>\n<p><strong>생성 패턴(Creational Pattern)</strong> : 객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해 준다.</p>\n<p><strong>ex )</strong> 추상 팩토리(Abstract Factory), 빌더(Builder), 팩토리 메서드(Factory Method), 프로토타입(Prototype), 싱글톤(Singleton)</p>\n</li>\n<li>\n<p><strong>행위 패턴(Behavioral Pattern)</strong> : 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로, 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와준다.</p>\n<p><strong>ex )</strong> 책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(Interpreter), 전략(Strategy), 옵저버(Observer)</p>\n</li>\n<li>\n<p><strong>구조 패턴(Structural Pattern)</strong> : 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴으로, 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.</p>\n<p><strong>ex )</strong> 어댑터(Adapter), 브리지(Bridge), 컴포지트(Composite), 데코레이터(Decorator), 프록시(Proxy)</p>\n</li>\n</ul>\n<br>\n<h2>생성 패턴</h2>\n<h3>싱글톤 패턴 (Singleton Pattern)</h3>\n<p>특정 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 패턴이다. 이 패턴은 주로 애플리케이션 내에서 전역적으로 접근 가능한 하나의 객체가 필요할 때 사용된다.</p>\n<pre><code class=\"language-typescript\">class Singleton {\n  private static instance: Singleton\n\n  private constructor() {\n    // private constructor를 사용하여 외부에서 인스턴스 생성을 방지\n  }\n\n  public static getInstance(): Singleton {\n    if (!Singleton.instance) {\n      Singleton.instance = new Singleton()\n    }\n    return Singleton.instance\n  }\n\n  public someMethod() {\n    console.log(\"This is a method in the Singleton class.\")\n  }\n}\n\nconst singleton1 = Singleton.getInstance()\nconst singleton2 = Singleton.getInstance()\n\nconsole.log(singleton1 === singleton2) // true\n</code></pre>\n<p>Singleton 클래스의 인스턴스를 하나만 생성할 수 있으며, getInstance() 메서드를 통해 언제나 같은 인스턴스를 반환한다. 이를 통해 메모리 사용을 절약하고, 전역 상태를 관리하는 데 유용하다.</p>\n<br>\n<h3>팩토리 메서드 패턴 (Factory Method Pattern)</h3>\n<p>객체 생성의 로직을 서브클래스에서 정의하도록 하여 객체 생성의 유연성을 제공하는 패턴이다. 이 패턴은 객체 생성의 책임을 팩토리 클래스에 위임함으로써 코드의 결합도를 낮추고, 객체 생성 로직을 중앙 집중화할 수 있다.</p>\n<pre><code class=\"language-typescript\">abstract class Product {\n  abstract use(): void\n}\n\nclass ConcreteProductA extends Product {\n  use(): void {\n    console.log(\"Using Product A\")\n  }\n}\n\nclass ConcreteProductB extends Product {\n  use(): void {\n    console.log(\"Using Product B\")\n  }\n}\n\nabstract class Creator {\n  abstract factoryMethod(): Product\n\n  createProduct(): Product {\n    return this.factoryMethod()\n  }\n}\n\nclass ConcreteCreatorA extends Creator {\n  factoryMethod(): Product {\n    return new ConcreteProductA()\n  }\n}\n\nclass ConcreteCreatorB extends Creator {\n  factoryMethod(): Product {\n    return new ConcreteProductB()\n  }\n}\n\nconst creatorA = new ConcreteCreatorA()\nconst productA = creatorA.createProduct()\nproductA.use()\n\nconst creatorB = new ConcreteCreatorB()\nconst productB = creatorB.createProduct()\nproductB.use()\n</code></pre>\n<p>Product 클래스를 상속받아 ConcreteProductA와 ConcreteProductB를 구현했다. 각각의 Creator 서브클래스에서 팩토리 메서드를 통해 특정 제품의 인스턴스를 생성하게 된다. 이 패턴은 새로운 제품이 추가될 때 기존 코드를 수정하지 않고도 확장할 수 있도록 도와준다.</p>\n<br>\n<h2>행위 패턴</h2>\n<h3>전략 패턴 (Strategy Pattern)</h3>\n<p>알고리즘 군을 정의하고, 각 알고리즘을 캡슐화하여 교환 가능하게 만드는 패턴이다. 이 패턴은 런타임 시에 알고리즘을 선택할 수 있도록 유연성을 제공한다.</p>\n<pre><code class=\"language-typescript\">interface Strategy {\n  execute(a: number, b: number): number\n}\n\nclass AddStrategy implements Strategy {\n  execute(a: number, b: number): number {\n    return a + b\n  }\n}\n\nclass SubtractStrategy implements Strategy {\n  execute(a: number, b: number): number {\n    return a - b\n  }\n}\n\nclass Context {\n  private strategy: Strategy\n\n  constructor(strategy: Strategy) {\n    this.strategy = strategy\n  }\n\n  setStrategy(strategy: Strategy) {\n    this.strategy = strategy\n  }\n\n  executeStrategy(a: number, b: number): number {\n    return this.strategy.execute(a, b)\n  }\n}\n\nconst context = new Context(new AddStrategy())\nconsole.log(context.executeStrategy(10, 5)) // 15\n\ncontext.setStrategy(new SubtractStrategy())\nconsole.log(context.executeStrategy(10, 5)) // 5\n</code></pre>\n<p>Strategy 인터페이스를 통해 다양한 알고리즘을 정의하고, Context 클래스에서 이들을 실행할 수 있다. 이를 통해 서로 다른 알고리즘을 쉽게 교체할 수 있으며, 새로운 전략을 추가할 때 기존 코드를 수정하지 않아도 된다.</p>\n<br>\n<h3>옵저버 패턴 (Observer Pattern)</h3>\n<p>객체의 상태 변화를 관찰하는 옵저버들에게 알리는 패턴이다. 이 패턴은 이벤트 기반 시스템에서 자주 사용되며, 상태 변화에 따라 여러 객체가 동기화되어야 하는 경우 유용하다.</p>\n<pre><code class=\"language-typescript\">interface Observer {\n  update(data: any): void\n}\n\nclass ConcreteObserver implements Observer {\n  private observerState: any\n\n  update(data: any) {\n    this.observerState = data\n    console.log(`Observer state updated with data: ${data}`)\n  }\n}\n\nclass Subject {\n  private observers: Observer[] = []\n\n  addObserver(observer: Observer) {\n    this.observers.push(observer)\n  }\n\n  removeObserver(observer: Observer) {\n    this.observers = this.observers.filter((obs) => obs !== observer)\n  }\n\n  notifyObservers(data: any) {\n    this.observers.forEach((observer) => observer.update(data))\n  }\n}\n\nconst subject = new Subject()\n\nconst observer1 = new ConcreteObserver()\nconst observer2 = new ConcreteObserver()\n\nsubject.addObserver(observer1)\nsubject.addObserver(observer2)\n\nsubject.notifyObservers(\"Hello, Observers!\")\n\nsubject.removeObserver(observer1)\nsubject.notifyObservers(\"Observer1 removed.\")\n</code></pre>\n<p>Observer 인터페이스를 구현한 ConcreteObserver가 주체(Subject)의 상태 변화를 감지하고, 주체는 notifyObservers 메서드를 통해 모든 옵저버들에게 변경 사항을 알린다. 옵저버 패턴은 이벤트 핸들링, 데이터 스트리밍 등 다양한 상황에서 유용하게 활용된다.</p>\n<br>\n<h2>구조 패턴</h2>\n<h3>데코레이터 패턴 (Decorator Pattern)</h3>\n<p>객체에 새로운 기능을 동적으로 추가할 수 있는 패턴이다. 이 패턴은 상속 대신 컴포지션을 사용하여 기능 확장이 가능하도록 도와준다.</p>\n<pre><code class=\"language-typescript\">interface Component {\n  operation(): string\n}\n\nclass ConcreteComponent implements Component {\n  operation(): string {\n    return \"ConcreteComponent\"\n  }\n}\n\nclass Decorator implements Component {\n  protected component: Component\n\n  constructor(component: Component) {\n    this.component = component\n  }\n\n  operation(): string {\n    return this.component.operation()\n  }\n}\n\nclass ConcreteDecoratorA extends Decorator {\n  operation(): string {\n    return `ConcreteDecoratorA(${super.operation()})`\n  }\n}\n\nclass ConcreteDecoratorB extends Decorator {\n  operation(): string {\n    return `ConcreteDecoratorB(${super.operation()})`\n  }\n}\n\nconst simple = new ConcreteComponent()\nconsole.log(simple.operation())\n\nconst decoratorA = new ConcreteDecoratorA(simple)\nconsole.log(decoratorA.operation())\n\nconst decoratorB = new ConcreteDecoratorB(decoratorA)\nconsole.log(decoratorB.operation())\n</code></pre>\n<p>Component 인터페이스를 구현한 ConcreteComponent에 Decorator 클래스를 통해 기능을 동적으로 추가할 수 있다. 데코레이터 패턴을 사용하면 기존 객체에 새로운 기능을 추가하면서도 코드의 유연성을 유지할 수 있다.</p>\n<br>\n<h3>프록시 패턴 (Proxy Pattern)</h3>\n<p>실제 객체에 대한 접근을 제어하기 위해 대리 객체를 사용하는 패턴이다. 프록시는 원래 객체의 기능을 확장하거나, 접근 제어를 위한 용도로 자주 사용된다.</p>\n<pre><code class=\"language-typescript\">interface Subject {\n  request(): void\n}\n\nclass RealSubject implements Subject {\n  request(): void {\n    console.log(\"RealSubject: Handling request.\")\n  }\n}\n\nclass Proxy implements Subject {\n  private realSubject: RealSubject\n\n  constructor(realSubject: RealSubject) {\n    this.realSubject = realSubject\n  }\n\n  request(): void {\n    if (this.checkAccess()) {\n      this.realSubject.request()\n      this.logAccess()\n    }\n  }\n\n  private checkAccess(): boolean {\n    console.log(\"Proxy: Checking access prior to firing a real request.\")\n    return true\n  }\n\n  private logAccess(): void {\n    console.log(\"Proxy: Logging the time of request.\")\n  }\n}\n\nconst realSubject = new RealSubject()\nconst proxy = new Proxy(realSubject)\nproxy.request()\n</code></pre>\n<p>Proxy 클래스가 실제 객체인 RealSubject에 대한 접근을 제어한다. 프록시 패턴은 원격 서버와의 통신, 캐싱, 접근 제어와 같은 다양한 시나리오에서 유용하게 사용된다.</p>\n<br>\n<h3>어댑터 패턴 (Adapter Pattern)</h3>\n<p>기존 인터페이스를 클라이언트가 원하는 인터페이스로 변환해주는 패턴이다. 이 패턴은 서로 다른 인터페이스를 사용하는 클래스 간의 협력을 가능하게 해준다.</p>\n<pre><code class=\"language-typescript\">class Target {\n  request(): string {\n    return \"Target: The default target's behavior.\"\n  }\n}\n\nclass Adaptee {\n  specificRequest(): string {\n    return \".eetpadA eht fo roivaheb laicepS\"\n  }\n}\n\nclass Adapter extends Target {\n  private adaptee: Adaptee\n\n  constructor(adaptee: Adaptee) {\n    super()\n    this.adaptee = adaptee\n  }\n\n  request(): string {\n    const result = this.adaptee.specificRequest().split(\"\").reverse().join(\"\")\n    return `Adapter: (TRANSLATED) ${result}`\n  }\n}\n\nconst adaptee = new Adaptee()\nconsole.log(`Adaptee: ${adaptee.specificRequest()}`)\n\nconst adapter = new Adapter(adaptee)\nconsole.log(`Adapter: ${adapter.request()}`)\n</code></pre>\n<p>Adaptee 클래스의 인터페이스를 Adapter를 통해 Target 인터페이스로 변환한다. 어댑터 패턴은 기존 클래스를 수정하지 않고도 서로 다른 인터페이스를 사용하는 클래스들을 통합할 수 있는 강력한 방법이다.</p>\n<p>여기까지 TypeScript를 사용하여 여러가지 디자인 패턴을 구현해 보았다. 각각의 패턴이 해결하는 문제와 구현 방법을 이해함으로써 더 나은 소프트웨어 개발에 많은 도움이 될 것이다.</p>\n<hr>\n<h2>Reference</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Software_design_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">Software design pattern - Wikipedia</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Design_Patterns\" target=\"_blank\" rel=\"noopener noreferrer\">Design Patterns - Wikipedia</a></p>\n<p><a href=\"https://velog.io/@waoderboy/Gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4\" target=\"_blank\" rel=\"noopener noreferrer\">Gof 디자인 패턴</a></p>\n<p><a href=\"https://refactoring.guru/ko/design-patterns/typescript\" target=\"_blank\" rel=\"noopener noreferrer\">타입스크립트로 작성된 디자인 패턴들</a></p>\n<p><a href=\"https://www.hanbit.co.kr/channel/category/category_view.html?cms_code=CMS8616098823\" target=\"_blank\" rel=\"noopener noreferrer\">[Design pattern] 많이 쓰는 14가지 핵심 GoF 디자인 패턴의 종류 - 한빛출판네트워크</a></p>","tableOfContents":"<ul>\n<li><a href=\"/Typescript/240827/#%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\">디자인 패턴이란?</a></li>\n<li><a href=\"/Typescript/240827/#gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EB%AA%A9%EC%A0%81-%EB%B6%84%EB%A5%98\">GoF 디자인 패턴 목적 분류</a></li>\n<li>\n<p><a href=\"/Typescript/240827/#%EC%83%9D%EC%84%B1-%ED%8C%A8%ED%84%B4\">생성 패턴</a></p>\n<ul>\n<li><a href=\"/Typescript/240827/#%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-singleton-pattern\">싱글톤 패턴 (Singleton Pattern)</a></li>\n<li><a href=\"/Typescript/240827/#%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-factory-method-pattern\">팩토리 메서드 패턴 (Factory Method Pattern)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/Typescript/240827/#%ED%96%89%EC%9C%84-%ED%8C%A8%ED%84%B4\">행위 패턴</a></p>\n<ul>\n<li><a href=\"/Typescript/240827/#%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4-strategy-pattern\">전략 패턴 (Strategy Pattern)</a></li>\n<li><a href=\"/Typescript/240827/#%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4-observer-pattern\">옵저버 패턴 (Observer Pattern)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/Typescript/240827/#%EA%B5%AC%EC%A1%B0-%ED%8C%A8%ED%84%B4\">구조 패턴</a></p>\n<ul>\n<li><a href=\"/Typescript/240827/#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4-decorator-pattern\">데코레이터 패턴 (Decorator Pattern)</a></li>\n<li><a href=\"/Typescript/240827/#%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-proxy-pattern\">프록시 패턴 (Proxy Pattern)</a></li>\n<li><a href=\"/Typescript/240827/#%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4-adapter-pattern\">어댑터 패턴 (Adapter Pattern)</a></li>\n</ul>\n</li>\n<li><a href=\"/Typescript/240827/#reference\">Reference</a></li>\n</ul>","frontmatter":{"date":"2024년 08월 27일","title":"Typescript로 작성하는 디자인 패턴","tags":["Typescript","OOP","Design Pattern"]}}},"pageContext":{"slug":"/Typescript/240827/","previous":{"fields":{"slug":"/React/240804/"},"frontmatter":{"title":"react-device-detect로 기기별 최적화된 화면 만들기"}},"next":{"fields":{"slug":"/React/240909/"},"frontmatter":{"title":"React에서 ApexCharts로 차트 그리기"}}}},"staticQueryHashes":["1081905842","3911196313"]}