{"componentChunkName":"component---src-templates-blog-post-js","path":"/Algorithm/230224/","result":{"data":{"site":{"siteMetadata":{"author":"yhuj79","comment":{"utterances":"yhuj79/blog-comments"},"sponsor":{"buyMeACoffeeId":"yhuj79"}}},"markdownRemark":{"excerpt":"온라인 저지, 알고리즘 대회 등에서 문제를 출제할 때 출제자의 의도에 맞는 효율적인 구조로 유도하기 위해 적절한 시간 제한을 두기 때문에, 알고리즘 설계 시 시간 복잡도를 고려하여 작성해야 한다. 알고리즘의 분석 기준 알고리즘의 성능을 분석하는 판단 기준에는 정확성, 명확성, 수행량, 메모리 사용량, 최적성 등이 있다. 이러한 기준을 바탕으로 알고리즘을 …","html":"<blockquote>\n<p>온라인 저지, 알고리즘 대회 등에서 문제를 출제할 때 출제자의 의도에 맞는 효율적인 구조로 유도하기 위해 적절한 시간 제한을 두기 때문에, 알고리즘 설계 시 시간 복잡도를 고려하여 작성해야 한다.</p>\n</blockquote>\n<h2>알고리즘의 분석 기준</h2>\n<p>알고리즘의 성능을 분석하는 판단 기준에는 정확성, 명확성, 수행량, 메모리 사용량, 최적성 등이 있다.</p>\n<pre><code>정확성 : 자료 입력 시 유한한 시간 내에 올바른 결과를 출력\n\n명확성 : 알고리즘의 표현이 이해하기 쉽고 명확하게 작성\n\n수행량 : 일반적인 연산을 제외하고 알고리즘의 특성을 나타내는 중요 연산을 분석\n\n메모리 사용량 : 명령어, 변수, 입출력 자료와 정보를 저장하기 위한 메모리 사용 정도 판단\n\n최적성 : 사용 환경에 따른 수행량과 메모리 사용량 변화에 대한 최적화를 판단\n</code></pre>\n<p>이러한 기준을 바탕으로 알고리즘을 분석하는 방법에는 실행에 필요한 공간적 측면에서 분석하는 공간 복잡도, 소요 시간 측면의 시간 복잡도가 있다. 이 포스팅에서는 시간 복잡도를 나타내는 Big-O(빅오) 표기법과 간단한 예제들을 다룬다.</p>\n<h2>Big-O(빅오) 표기법</h2>\n<p>시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법을 <strong>Big-O(빅오) 표기법</strong>이라고 한다. Big-O에서는 최악의 상황을 가정하여 연산 횟수를 짐작한다.</p>\n<h3>:one: O(1) : Constant Time</h3>\n<p>입력 데이터의 크기에 상관없이 일정한 시간이 걸린다면 <strong>O(1)의 시간 복잡도를 가진 알고리즘(Constant Time)</strong>이라고 한다. 어떤 배열이 있다고 할 경우, 배열의 길이와 상관없이 해당 index에 접근해 즉시 값을 얻을 수 있다.</p>\n<pre><code class=\"language-c\">// C\nint arr[3] = {0,1,2};\n\nvoid printArr(int arr[]) {\n    printf(\"%d\\n\", arr[0]);\n    printf(\"%d\\n\", arr[1]);\n    printf(\"%d\\n\", arr[2]);\n}\n\nint main(void) {\n    printArr(arr);\n}\n</code></pre>\n<pre><code class=\"language-javascript\">// Javascript\nfunction printArr(arr, index) {\n  return arr[index]\n}\n\nconst arr = [0, 1, 2]\n\nconsole.log(printArr(arr, 0))\nconsole.log(printArr(arr, 1))\nconsole.log(printArr(arr, 2))\n</code></pre>\n<h3>:two: O(log n) : Logarithmic Time</h3>\n<p>O(log n)은 <strong>로그 복잡도(Logarithmic Time)</strong>라고 부르며, Big-O표기법중 O(1) 다음으로 가장 빠르다.<br>\n다음 코드는 <code>i = i * 2</code> 에 의해 1, 2, 4, 8, 16 ...인 2의 거듭제곱으로 증가한다. 이는 log2 N번 연산하므로, 시간 복잡도는 O(log n)이다.</p>\n<pre><code class=\"language-c\">// C\nvoid printNum(int n){\n    int i = 1;\n    while(i &#x3C; n){\n        printf(\"%d\\n\", i);\n        i = i * 2;\n    }\n}\n\nint main(void) {\n    printNum(20);\n}\n</code></pre>\n<pre><code class=\"language-javascript\">// Javascript\nfunction printNum(n) {\n  let i = 1\n  while (i &#x3C; n) {\n    console.log(i)\n    i = i * 2\n  }\n}\n\nprintNum(20)\n</code></pre>\n<p><strong>이진 탐색(Binary Search)</strong>의 경우 또한 O(log n)의 시간 복잡도를 가진다. 찾고자 하는 값을 정렬된 배열의 중간 값과 비교하여 절반을 탐색 대상에서 제외시키기 때문이다.</p>\n<img alt=\"bs\" width=\"100%\" src=\"https://raw.githubusercontent.com/yhuj79/blog-assets/main/230224/bs.gif\">\n<h3>:three: O(n) : Linear Time</h3>\n<p>입력 데이터의 크기에 비례해서 처리시간이 늘어나는 경우 <strong>O(n)</strong>이다. 입력된 값이 1일 때의 시간이 1초 걸린다면, 입력된 값이 100일 때 100초일 것이다.</p>\n<pre><code class=\"language-c\">// C\nvoid printNum(int n){\n    for (int i=0; i &#x3C; n; i++) {\n        printf(\"%d\\n\", i);\n    }\n}\n\nint main(void) {\n    printNum(10);\n}\n</code></pre>\n<pre><code class=\"language-javascript\">// Javascript\nconst arr = [\"a\", \"b\", \"c\", \"d\"]\n\nfunction printArr() {\n  for (let i = 0; i &#x3C; arr.length; i++) {\n    console.log(`arr[${i}] = ${arr[i]}`)\n  }\n}\n\nprintArr(10)\n</code></pre>\n<h3>:four: O(n log n) : Linearithmic Time</h3>\n<p>위에서 다룬 O(log n)의 시간복잡도를 가진 while문에 for문이 중첩된 구조이다. for문의 반복횟수는 n에 비례하는 반면, while문의 반복횟수는 log n에 비례한다.</p>\n<pre><code class=\"language-c\">// C\nvoid printNum(int n){\n    for(int i=1; i&#x3C;n; i++){\n        int j=1;\n        while(j&#x3C;n){\n            printf(\"%d %d\\n\",i,j);\n            j = j * 2;\n        }\n    }\n}\n\nint main(void) {\n    printNum(10);\n}\n</code></pre>\n<pre><code class=\"language-javascript\">// Javascript\nfunction printNum(n) {\n  for (let i = 0; i &#x3C; n; i++) {\n    let j = 1\n    while (j &#x3C; n) {\n      console.log(`${i} x ${j} = ${i * j}`)\n      j = j * 2\n    }\n  }\n}\n\nprintNum(5)\n</code></pre>\n<h3>:five: O(n^2) : Quadratic Time</h3>\n<p>이중 for문을 돌면서 수행하는 알고리즘은 <strong>O(n^2)</strong>의 시간 복잡도를 갖는다. 입력 데이터가 증가함에 따라 시간이 n의 제곱수의 비율로 증가한다. 2 이상의 제곱이 주어져도 영향력이 미비하기 때문에 통상적으로 O(n^2)으로 표시한다.</p>\n<pre><code class=\"language-c\">// C\nvoid printNum(int n){\n    for(int i=1; i&#x3C;=n; i++){\n        for(int j=1; j&#x3C;=n*2; j++) {\n            printf(\"%d %d\\n\", i, j);\n        }\n    }\n}\n\nint main(void) {\n    printNum(3);\n}\n</code></pre>\n<pre><code class=\"language-javascript\">// Javascript\nfunction multiplication(n, m) {\n  for (let i = 1; i &#x3C;= n; i++) {\n    for (let j = 1; j &#x3C;= m; j++) {\n      console.log(`${i} x ${j} = ${i * j}`)\n    }\n    console.log()\n  }\n}\n\nmultiplication(9, 9)\n</code></pre>\n<h3>:six: O(2n) : Exponential Time</h3>\n<p><strong>O(2n)</strong>은 Big-O(빅오) 표기법 중에서 O(n!)을 제외한다면 가장 느리며, 입력 데이터가 어느 정도 커지면 소요 시간은 무한대에 가까워질 수 있다. 대표적으로 재귀적 수행을 하는 <strong>피보나치 수열</strong>이 있다.</p>\n<p><a href=\"https://www.acmicpc.net/problem/10870\" target=\"_blank\" rel=\"noopener noreferrer\">10870번: 피보나치 수 5 | Baekjoon Online Judge</a></p>\n<pre><code class=\"language-javascript\">function fibonacci(input) {\n  if (input == 0) return 0\n  else if (input == 1) return 1\n  else return fibonacci(input - 1) + fibonacci(input - 2)\n}\nconsole.log(fibonacci(input))\n</code></pre>\n<h3>:seven: O(n!) : Factorial Time</h3>\n<p>Big O 최악의 런타임이다. 입력 데이터의 원소들로 만들 수 있는 모든 순열을 생성한다.<br>\n다음 코드는 Factorial Time에 대한 정의이다.</p>\n<pre><code class=\"language-c\">void nFacRuntimeFunc(int n) {\n  for(int i=0; i&#x3C;n; i++) {\n    nFacRuntimeFunc(n-1);\n  }\n}\n</code></pre>\n<h2>시간 복잡도 그래프</h2>\n<p>속도는 <code>O(1)</code> <code>O(log N)</code> <code>O(N)</code> <code>O(N log N)</code> <code>O(N^2)</code> <code>O(2^N)</code> <code>O(N!)</code> 순서대로 빠르다.</p>\n<p><img src=\"https://raw.githubusercontent.com/yhuj79/blog-assets/main/230224/bigochart.png\" alt=\"bigochart\"></p>\n<hr>\n<h2>Reference</h2>\n<p><a href=\"https://www.acmicpc.net/\" target=\"_blank\" rel=\"noopener noreferrer\">Baekjoon Online Judge</a></p>\n<p><a href=\"https://levelup.gitconnected.com/time-complexity-and-bigo-notation-linear-time-constant-time-and-quadratic-time-686c279ecd88\" target=\"_blank\" rel=\"noopener noreferrer\">Time Complexity and BigO Notation... | by Sebastian De Lima</a></p>\n<p><a href=\"https://www.bigocheatsheet.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Big-O Algorithm Complexity Cheat Sheet (Know Thy Complexities!) @ericdrowell</a></p>\n<p><a href=\"https://overcome-the-limits.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-with-JavaScript\" target=\"_blank\" rel=\"noopener noreferrer\">[자료구조] 시간복잡도 with JavaScript</a></p>\n<p><a href=\"https://insight-bgh.tistory.com/505\" target=\"_blank\" rel=\"noopener noreferrer\">[Algorithm] 시간 복잡도(Time Complexity) - 2WEEKS</a></p>\n<p><a href=\"https://jongbeom-dev.tistory.com/159\" target=\"_blank\" rel=\"noopener noreferrer\">알고리즘 복잡도와 빅 오 표기법 :: 비전공 개발자</a></p>\n<p><a href=\"https://yoongrammer.tistory.com/75\" target=\"_blank\" rel=\"noopener noreferrer\">이진 탐색 (Binary search) 개념 및 구현</a></p>\n<p><a href=\"https://velog.io/@kimdukbae/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-Binary-Search\" target=\"_blank\" rel=\"noopener noreferrer\">[알고리즘] 이분 탐색 / 이진 탐색 (Binary Search)</a></p>","tableOfContents":"<ul>\n<li><a href=\"/Algorithm/230224/#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EB%B6%84%EC%84%9D-%EA%B8%B0%EC%A4%80\">알고리즘의 분석 기준</a></li>\n<li>\n<p><a href=\"/Algorithm/230224/#big-o%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95\">Big-O(빅오) 표기법</a></p>\n<ul>\n<li><a href=\"/Algorithm/230224/#one-o1--constant-time\">:one: O(1) : Constant Time</a></li>\n<li><a href=\"/Algorithm/230224/#two-olog-n--logarithmic-time\">:two: O(log n) : Logarithmic Time</a></li>\n<li><a href=\"/Algorithm/230224/#three-on--linear-time\">:three: O(n) : Linear Time</a></li>\n<li><a href=\"/Algorithm/230224/#four-on-log-n--linearithmic-time\">:four: O(n log n) : Linearithmic Time</a></li>\n<li><a href=\"/Algorithm/230224/#five-on2--quadratic-time\">:five: O(n^2) : Quadratic Time</a></li>\n<li><a href=\"/Algorithm/230224/#six-o2n--exponential-time\">:six: O(2n) : Exponential Time</a></li>\n<li><a href=\"/Algorithm/230224/#seven-on--factorial-time\">:seven: O(n!) : Factorial Time</a></li>\n</ul>\n</li>\n<li><a href=\"/Algorithm/230224/#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B7%B8%EB%9E%98%ED%94%84\">시간 복잡도 그래프</a></li>\n<li><a href=\"/Algorithm/230224/#reference\">Reference</a></li>\n</ul>","frontmatter":{"date":"2023년 02월 24일","title":"시간 복잡도, Big-O(빅오) 표기법","tags":["Algorithm","C","Javascript"]}}},"pageContext":{"slug":"/Algorithm/230224/","previous":{"fields":{"slug":"/React/230214/"},"frontmatter":{"title":"React-Quill Editor 이미지 처리하기 (Firebase Storage)"}},"next":{"fields":{"slug":"/Computer Science/230312/"},"frontmatter":{"title":"클라우드 서비스 IaaS, PaaS, SaaS"}}}},"staticQueryHashes":["1081905842","3911196313"]}